        -:    0:Source:../zma_parse_process.cpp
        -:    0:Programs:105
        -:    1:// --------------------------------------------------------------------
        -:    2://	Z80 Macro Assembler parse
        -:    3:// ====================================================================
        -:    4://	2019/05/04	t.hara
        -:    5:// --------------------------------------------------------------------
        -:    6:
        -:    7:#include "zma_parse.hpp"
        -:    8:#include "zma_text.hpp"
        -:    9:#include "zma_parse_process.hpp"
        -:   10:#include <string>
        -:   11:#include <cctype>
        -:   12:#include <iostream>
        -:   13:#include <fstream>
        -:   14:#include <sstream>
        -:   15:#include <algorithm>
        -:   16:
        -:   17:// --------------------------------------------------------------------
        -:   18:int CZMA_PARSE::number_of_error = 0;
        -:   19:
        -:   20:// --------------------------------------------------------------------
       12:   21:static std::map< std::string, CZMA_COMMAND_TYPE > command_list = {
        -:   22:	{ "ALIGN", CZMA_COMMAND_TYPE::CZMA_ALIGN },
        -:   23:	{ "SPACE", CZMA_COMMAND_TYPE::CZMA_SPACE },
        -:   24:	{ "REPEAT", CZMA_COMMAND_TYPE::CZMA_REPEAT },
        -:   25:	{ "ENDR", CZMA_COMMAND_TYPE::CZMA_ENDR },
        -:   26:	{ "ENDM", CZMA_COMMAND_TYPE::CZMA_ENDM },
        -:   27:	{ "IF", CZMA_COMMAND_TYPE::CZMA_IF },
        -:   28:	{ "ELSEIF", CZMA_COMMAND_TYPE::CZMA_ELSEIF },
        -:   29:	{ "ELSE", CZMA_COMMAND_TYPE::CZMA_ELSE },
        -:   30:	{ "ENDIF", CZMA_COMMAND_TYPE::CZMA_ENDIF },
        -:   31:	{ "ORG", CZMA_COMMAND_TYPE::CZMA_ORG },
        -:   32:	{ "INCLUDE", CZMA_COMMAND_TYPE::CZMA_INCLUDE },
        -:   33:	{ "ADD_INCLUDE_PATH", CZMA_COMMAND_TYPE::CZMA_ADD_INCLUDE_PATH },
        -:   34:	{ "ERROR", CZMA_COMMAND_TYPE::CZMA_USER_ERROR },
        -:   35:	{ "MESSAGE", CZMA_COMMAND_TYPE::CZMA_USER_MESSAGE },
        -:   36:	{ "SCOPE", CZMA_COMMAND_TYPE::CZMA_SCOPE },
        -:   37:	{ "ENDSCOPE", CZMA_COMMAND_TYPE::CZMA_ENDSCOPE },
        -:   38:	{ "BINARY_LINK", CZMA_COMMAND_TYPE::CZMA_BINARY_LINK },
        -:   39:	{ "DEFB", CZMA_COMMAND_TYPE::CZMA_DEFB },
        -:   40:	{ "DEFW", CZMA_COMMAND_TYPE::CZMA_DEFW },
        -:   41:	{ "DEFD", CZMA_COMMAND_TYPE::CZMA_DEFD },
        -:   42:	{ "DEFS", CZMA_COMMAND_TYPE::CZMA_DEFS },
        -:   43:	{ "DB", CZMA_COMMAND_TYPE::CZMA_DEFB },
        -:   44:	{ "DW", CZMA_COMMAND_TYPE::CZMA_DEFW },
        -:   45:	{ "DD", CZMA_COMMAND_TYPE::CZMA_DEFD },
        -:   46:	{ "DS", CZMA_COMMAND_TYPE::CZMA_DEFS },
        -:   47:	{ "LD", CZMA_COMMAND_TYPE::CZMA_LD },
        -:   48:	{ "LDI", CZMA_COMMAND_TYPE::CZMA_LDI },
        -:   49:	{ "LDIR", CZMA_COMMAND_TYPE::CZMA_LDIR },
        -:   50:	{ "LDD", CZMA_COMMAND_TYPE::CZMA_LDD },
        -:   51:	{ "LDDR", CZMA_COMMAND_TYPE::CZMA_LDDR },
        -:   52:	{ "EX", CZMA_COMMAND_TYPE::CZMA_EX },
        -:   53:	{ "EXX", CZMA_COMMAND_TYPE::CZMA_EXX },
        -:   54:	{ "PUSH", CZMA_COMMAND_TYPE::CZMA_PUSH },
        -:   55:	{ "POP", CZMA_COMMAND_TYPE::CZMA_POP },
        -:   56:	{ "RLCA", CZMA_COMMAND_TYPE::CZMA_RLCA },
        -:   57:	{ "RLA", CZMA_COMMAND_TYPE::CZMA_RLA },
        -:   58:	{ "RLC", CZMA_COMMAND_TYPE::CZMA_RLC },
        -:   59:	{ "RL", CZMA_COMMAND_TYPE::CZMA_RL },
        -:   60:	{ "RRCA", CZMA_COMMAND_TYPE::CZMA_RRCA },
        -:   61:	{ "RRA", CZMA_COMMAND_TYPE::CZMA_RRA },
        -:   62:	{ "RRC", CZMA_COMMAND_TYPE::CZMA_RRC },
        -:   63:	{ "RR", CZMA_COMMAND_TYPE::CZMA_RR },
        -:   64:	{ "SLA", CZMA_COMMAND_TYPE::CZMA_SLA },
        -:   65:	{ "SRA", CZMA_COMMAND_TYPE::CZMA_SRA },
        -:   66:	{ "SRL", CZMA_COMMAND_TYPE::CZMA_SRL },
        -:   67:	{ "SLL", CZMA_COMMAND_TYPE::CZMA_SLL },
        -:   68:	{ "ADD", CZMA_COMMAND_TYPE::CZMA_ADD },
        -:   69:	{ "ADC", CZMA_COMMAND_TYPE::CZMA_ADC },
        -:   70:	{ "INC", CZMA_COMMAND_TYPE::CZMA_INC },
        -:   71:	{ "SUB", CZMA_COMMAND_TYPE::CZMA_SUB },
        -:   72:	{ "SBC", CZMA_COMMAND_TYPE::CZMA_SBC },
        -:   73:	{ "DEC", CZMA_COMMAND_TYPE::CZMA_DEC },
        -:   74:	{ "AND", CZMA_COMMAND_TYPE::CZMA_AND },
        -:   75:	{ "OR", CZMA_COMMAND_TYPE::CZMA_OR },
        -:   76:	{ "XOR", CZMA_COMMAND_TYPE::CZMA_XOR },
        -:   77:	{ "CPL", CZMA_COMMAND_TYPE::CZMA_CPL },
        -:   78:	{ "NEG", CZMA_COMMAND_TYPE::CZMA_NEG },
        -:   79:	{ "CCF", CZMA_COMMAND_TYPE::CZMA_CCF },
        -:   80:	{ "SCF", CZMA_COMMAND_TYPE::CZMA_SCF },
        -:   81:	{ "BIT", CZMA_COMMAND_TYPE::CZMA_BIT },
        -:   82:	{ "RES", CZMA_COMMAND_TYPE::CZMA_RES },
        -:   83:	{ "SET", CZMA_COMMAND_TYPE::CZMA_SET },
        -:   84:	{ "CPI", CZMA_COMMAND_TYPE::CZMA_CPI },
        -:   85:	{ "CPIR", CZMA_COMMAND_TYPE::CZMA_CPIR },
        -:   86:	{ "CPD", CZMA_COMMAND_TYPE::CZMA_CPD },
        -:   87:	{ "CPDR", CZMA_COMMAND_TYPE::CZMA_CPDR },
        -:   88:	{ "CP", CZMA_COMMAND_TYPE::CZMA_CP },
        -:   89:	{ "JP", CZMA_COMMAND_TYPE::CZMA_JP },
        -:   90:	{ "JR", CZMA_COMMAND_TYPE::CZMA_JR },
        -:   91:	{ "DJNZ", CZMA_COMMAND_TYPE::CZMA_DJNZ },
        -:   92:	{ "CALL", CZMA_COMMAND_TYPE::CZMA_CALL },
        -:   93:	{ "RET", CZMA_COMMAND_TYPE::CZMA_RET },
        -:   94:	{ "RETI", CZMA_COMMAND_TYPE::CZMA_RETI },
        -:   95:	{ "RETN", CZMA_COMMAND_TYPE::CZMA_RETN },
        -:   96:	{ "RST", CZMA_COMMAND_TYPE::CZMA_RST },
        -:   97:	{ "NOP", CZMA_COMMAND_TYPE::CZMA_NOP },
        -:   98:	{ "HALT", CZMA_COMMAND_TYPE::CZMA_HALT },
        -:   99:	{ "DI", CZMA_COMMAND_TYPE::CZMA_DI },
        -:  100:	{ "EI", CZMA_COMMAND_TYPE::CZMA_EI },
        -:  101:	{ "IM0", CZMA_COMMAND_TYPE::CZMA_IM0 },
        -:  102:	{ "IM1", CZMA_COMMAND_TYPE::CZMA_IM1 },
        -:  103:	{ "IM2", CZMA_COMMAND_TYPE::CZMA_IM2 },
        -:  104:	{ "IN", CZMA_COMMAND_TYPE::CZMA_IN },
        -:  105:	{ "INI", CZMA_COMMAND_TYPE::CZMA_INI },
        -:  106:	{ "INIR", CZMA_COMMAND_TYPE::CZMA_INIR },
        -:  107:	{ "IND", CZMA_COMMAND_TYPE::CZMA_IND },
        -:  108:	{ "INDR", CZMA_COMMAND_TYPE::CZMA_INDR },
        -:  109:	{ "OUT", CZMA_COMMAND_TYPE::CZMA_OUT },
        -:  110:	{ "OUTI", CZMA_COMMAND_TYPE::CZMA_OUTI },
        -:  111:	{ "OTIR", CZMA_COMMAND_TYPE::CZMA_OTIR },
        -:  112:	{ "OUTD", CZMA_COMMAND_TYPE::CZMA_OUTD },
        -:  113:	{ "OTDR", CZMA_COMMAND_TYPE::CZMA_OTDR },
        -:  114:	{ "DAA", CZMA_COMMAND_TYPE::CZMA_DAA },
        -:  115:	{ "RLD", CZMA_COMMAND_TYPE::CZMA_RLD },
        -:  116:	{ "RRD", CZMA_COMMAND_TYPE::CZMA_RRD },
        -:  117:	{ "MULUB", CZMA_COMMAND_TYPE::CZMA_MULUB },
        -:  118:	{ "MULUW", CZMA_COMMAND_TYPE::CZMA_MULUW },
        -:  119:	{ "CHG_CHAR_SET", CZMA_COMMAND_TYPE::CZMA_CHG_CHAR_SET },
        -:  120:	{ "MAPPING_CHAR", CZMA_COMMAND_TYPE::CZMA_MAPPING_CHAR },
        -:  121:};
        -:  122:
        -:  123:// --------------------------------------------------------------------
        -:  124:#define OPE_CASE( operation )																			\
        -:  125:	case CZMA_COMMAND_TYPE::CZMA_##operation:																			\
        -:  126:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_##operation( words, p_file_name, line_no ))
        -:  127:
        -:  128:// --------------------------------------------------------------------
     6307:  129:CZMA_PARSE* CZMA_PARSE::create( CZMA_INFORMATION& info, std::vector<std::string> &words, const char* p_file_name, int line_no ) {
        -:  130:
    12614:  131:	if( words.size() == 0 ) {
     5772:  132:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_BLANK( words, p_file_name, line_no ));
        -:  133:	}
     3586:  134:	if( words.size() == 2 && words[1] == ":" ) {
       28:  135:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_LABEL( words, p_file_name, line_no ));
        -:  136:	}
     3558:  137:	if( words.size() == 2 && words[1] == "::" ) {
        4:  138:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_GLOBAL_LABEL( words, p_file_name, line_no ));
        -:  139:	}
     5049:  140:	if( words.size() >= 3 && words[1] == "=" ) {
    #####:  141:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_SYMBOL( words, p_file_name, line_no ));
        -:  142:	}
     6693:  143:	if( words.size() >= 3 && (words[1] == ":=" || words[ 1 ] == "EQU") ) {
    #####:  144:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_GLOBAL_SYMBOL( words, p_file_name, line_no ));
        -:  145:	}
     5198:  146:	if( words.size() >= 2 && words[1] == "MACRO" ) {
    #####:  147:		info.macro_list[words[0]] = nullptr;
    #####:  148:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_MACRO( words, p_file_name, line_no ));
        -:  149:	}
        -:  150:	if( words.size() >= 1 && info.macro_list.count( words[0] ) ) {
    #####:  151:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_MACRO_INS( words, p_file_name, line_no ));
        -:  152:	}
     3405:  153:	switch( command_list[words[0]] ) {
        6:  154:		OPE_CASE( ORG );
    #####:  155:		OPE_CASE( INCLUDE );
    #####:  156:		OPE_CASE( ADD_INCLUDE_PATH );
        4:  157:		OPE_CASE( ALIGN );
        4:  158:		OPE_CASE( SPACE );
    #####:  159:		OPE_CASE( REPEAT );
    #####:  160:		OPE_CASE( ENDR );
    #####:  161:		OPE_CASE( ENDM );
    #####:  162:		OPE_CASE( IF );
    #####:  163:		OPE_CASE( ELSEIF );
    #####:  164:		OPE_CASE( ELSE );
    #####:  165:		OPE_CASE( ENDIF );
    #####:  166:		OPE_CASE( USER_ERROR );
        8:  167:		OPE_CASE( USER_MESSAGE );
    #####:  168:		OPE_CASE( SCOPE );
    #####:  169:		OPE_CASE( ENDSCOPE );
        2:  170:		OPE_CASE( BINARY_LINK );
     1980:  171:		OPE_CASE( DEFB );
        4:  172:		OPE_CASE( DEFW );
        4:  173:		OPE_CASE( DEFD );
       10:  174:		case CZMA_COMMAND_TYPE::CZMA_DEFS:
       10:  175:			if( info.defs_is_space ){
    #####:  176:				return reinterpret_cast<CZMA_PARSE *> ( new CZMA_PARSE_SPACE( words, p_file_name, line_no ) );
        -:  177:			}
       20:  178:			return reinterpret_cast<CZMA_PARSE *> ( new CZMA_PARSE_DEFS( words, p_file_name, line_no ) );
      390:  179:		OPE_CASE( LD );
       12:  180:		OPE_CASE( PUSH );
       12:  181:		OPE_CASE( POP );
       10:  182:		OPE_CASE( EX );
        2:  183:		OPE_CASE( EXX );
        2:  184:		OPE_CASE( LDI );
        2:  185:		OPE_CASE( LDIR );
        2:  186:		OPE_CASE( LDD );
        2:  187:		OPE_CASE( LDDR );
        2:  188:		OPE_CASE( RLCA );
        2:  189:		OPE_CASE( RLA );
       20:  190:		OPE_CASE( RLC );
       20:  191:		OPE_CASE( RL );
        2:  192:		OPE_CASE( RRCA );
        2:  193:		OPE_CASE( RRA );
       20:  194:		OPE_CASE( RRC );
       20:  195:		OPE_CASE( RR );
       20:  196:		OPE_CASE( SLA );
       20:  197:		OPE_CASE( SRA );
       20:  198:		OPE_CASE( SRL );
    #####:  199:		OPE_CASE( SLL );
       54:  200:		OPE_CASE( ADD );
       38:  201:		OPE_CASE( ADC );
       44:  202:		OPE_CASE( INC );
       30:  203:		OPE_CASE( SUB );
       38:  204:		OPE_CASE( SBC );
       40:  205:		OPE_CASE( DEC );
       30:  206:		OPE_CASE( AND );
       30:  207:		OPE_CASE( OR );
       30:  208:		OPE_CASE( XOR );
        2:  209:		OPE_CASE( CPL );
        2:  210:		OPE_CASE( NEG );
        2:  211:		OPE_CASE( CCF );
        2:  212:		OPE_CASE( SCF );
      160:  213:		OPE_CASE( BIT );
      160:  214:		OPE_CASE( RES );
      160:  215:		OPE_CASE( SET );
        2:  216:		OPE_CASE( CPI );
        2:  217:		OPE_CASE( CPIR );
        2:  218:		OPE_CASE( CPD );
        2:  219:		OPE_CASE( CPDR );
       30:  220:		OPE_CASE( CP );
       26:  221:		OPE_CASE( JP );
       10:  222:		OPE_CASE( JR );
        2:  223:		OPE_CASE( DJNZ );
       18:  224:		OPE_CASE( CALL );
       22:  225:		OPE_CASE( RET );
        2:  226:		OPE_CASE( RETI );
        2:  227:		OPE_CASE( RETN );
       16:  228:		OPE_CASE( RST );
     3146:  229:		OPE_CASE( NOP );
        2:  230:		OPE_CASE( HALT );
        2:  231:		OPE_CASE( EI );
        2:  232:		OPE_CASE( DI );
        2:  233:		OPE_CASE( IM0 );
        2:  234:		OPE_CASE( IM1 );
        2:  235:		OPE_CASE( IM2 );
       16:  236:		OPE_CASE( IN );
        2:  237:		OPE_CASE( INI );
        2:  238:		OPE_CASE( INIR );
        2:  239:		OPE_CASE( IND );
        2:  240:		OPE_CASE( INDR );
       16:  241:		OPE_CASE( OUT );
        2:  242:		OPE_CASE( OUTI );
        2:  243:		OPE_CASE( OTIR );
        2:  244:		OPE_CASE( OUTD );
        2:  245:		OPE_CASE( OTDR );
        2:  246:		OPE_CASE( DAA );
        2:  247:		OPE_CASE( RLD );
        2:  248:		OPE_CASE( RRD );
        8:  249:		OPE_CASE( MULUB );
        4:  250:		OPE_CASE( MULUW );
        6:  251:		OPE_CASE( CHG_CHAR_SET );
        8:  252:		OPE_CASE( MAPPING_CHAR );
        -:  253:	default:
        -:  254:		break;
        -:  255:	}
    #####:  256:	return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_ERROR( words, p_file_name, line_no ));
        -:  257:}
        -:  258:
        -:  259:// --------------------------------------------------------------------
    #####:  260:void CZMA_PARSE::log_data_dump( void ) {
        -:  261:	int address, count;
    #####:  262:	std::stringstream line;
    #####:  263:	address = this->get_code_address();
        -:  264:	count = 0;
    #####:  265:	line.str("");
    #####:  266:	for( auto d : data ) {
    #####:  267:		if( count == 0 ) {
    #####:  268:			line << std::hex << std::setw( 6 ) << std::setfill( '0' ) << address << ":";
        -:  269:		}
    #####:  270:		line << " " << std::hex << std::setw( 2 ) << std::setfill( '0' ) << (int)d;
    #####:  271:		address++;
    #####:  272:		count++;
    #####:  273:		if( count == 8 ) {
    #####:  274:			log.push_back( line.str() );
    #####:  275:			line.str( "" );
        -:  276:			count = 0;
        -:  277:		}
        -:  278:	}
    #####:  279:	if( count != 0 ) {
    #####:  280:		log.push_back( line.str() );
        -:  281:	}
    #####:  282:}
        -:  283:
        -:  284:// --------------------------------------------------------------------
     3412:  285:std::string CZMA_PARSE::get_line( void ) {
        -:  286:	std::string r, ss;
        -:  287:
        -:  288:	r = "";
    16420:  289:	for( auto &s : words ) {
    26016:  290:		if( s.size() > 0 && (s[0] == '\"' || s[0] == '\'') ){
       25:  291:			ss = s[ 0 ];
      267:  292:			for( int i = 1; i < (int)s.size(); i++ ) {
      242:  293:				switch( s[i] ) {
    #####:  294:				case '\a':	ss = ss + "\\a";	break;
    #####:  295:				case '\b':	ss = ss + "\\b";	break;
    #####:  296:				case '\f':	ss = ss + "\\f";	break;
    #####:  297:				case '\n':	ss = ss + "\\n";	break;
    #####:  298:				case '\r':	ss = ss + "\\r";	break;
    #####:  299:				case '\t':	ss = ss + "\\t";	break;
    #####:  300:				case '\\':	ss = ss + "\\\\";	break;
    #####:  301:				case '\'':	ss = ss + "\\'";	break;
    #####:  302:				case '\"':	ss = ss + "\\\"";	break;
      242:  303:				default:	ss = ss + s[i];		break;
        -:  304:				}
        -:  305:			}
       50:  306:			ss = ss + s[0];
        -:  307:		}
        -:  308:		else {
        -:  309:			ss = s;
        -:  310:		}
    13008:  311:		if( r == "" ) {
        -:  312:			r = ss;
        -:  313:		}
     9596:  314:		else if( ss == "," ){
     7160:  315:			r = r + ss;
        -:  316:		}
     6016:  317:		else if( ss[ 0 ] == '0' && ss[ 1 ] == 'X' ){
     2992:  318:			ss[ 1 ] = 'x';
     8976:  319:			r = r + " " + ss;
        -:  320:		}
     4162:  321:		else if( ss[ 0 ] == '0' && ss[ 1 ] == 'B' ){
    #####:  322:			ss[ 1 ] = 'b';
    #####:  323:			r = r + " " + ss;
        -:  324:		}
        -:  325:		else {
    12096:  326:			r = r + " " + ss;
        -:  327:		}
        -:  328:	}
     3412:  329:	return r;
       18:  330:}
