        -:    0:Source:../zma_parse_process.cpp
        -:    0:Programs:4
        -:    1:// --------------------------------------------------------------------
        -:    2://	Z80 Macro Assembler parse
        -:    3:// ====================================================================
        -:    4://	2019/05/04	t.hara
        -:    5:// --------------------------------------------------------------------
        -:    6:
        -:    7:#include "zma_parse.hpp"
        -:    8:#include "zma_text.hpp"
        -:    9:#include <string>
        -:   10:#include <cctype>
        -:   11:#include <iostream>
        -:   12:#include <fstream>
        -:   13:#include <sstream>
        -:   14:#include <algorithm>
        -:   15:
        -:   16:#define CLASS_CZMA_PARSE( name ) \
        -:   17:	class CZMA_PARSE_##name: public CZMA_PARSE {													\
        -:   18:	public:																							\
        -:   19:		using CZMA_PARSE::CZMA_PARSE;																\
        -:   20:		bool process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line = nullptr ) override;			\
        -:   21:	};
        -:   22:
       11:   23:CLASS_CZMA_PARSE( USER_ERROR );
       66:   24:CLASS_CZMA_PARSE( USER_MESSAGE );
        5:   25:CLASS_CZMA_PARSE( ADD_INCLUDE_PATH );
        2:   26:CLASS_CZMA_PARSE( ALIGN );
        2:   27:CLASS_CZMA_PARSE( SPACE );
     3387:   28:CLASS_CZMA_PARSE( BLANK );
       28:   29:CLASS_CZMA_PARSE( MACRO );
       30:   30:CLASS_CZMA_PARSE( LABEL );
        6:   31:CLASS_CZMA_PARSE( GLOBAL_LABEL );
       12:   32:CLASS_CZMA_PARSE( SYMBOL );
        8:   33:CLASS_CZMA_PARSE( GLOBAL_SYMBOL );
       20:   34:CLASS_CZMA_PARSE( SCOPE );
       14:   35:CLASS_CZMA_PARSE( ENDSCOPE );
        1:   36:CLASS_CZMA_PARSE( BINARY_LINK );
     1251:   37:CLASS_CZMA_PARSE( DEFB );
      473:   38:CLASS_CZMA_PARSE( DEFW );
        8:   39:CLASS_CZMA_PARSE( DEFD );
       24:   40:CLASS_CZMA_PARSE( DEFS );
       21:   41:CLASS_CZMA_PARSE( ORG );
      380:   42:CLASS_CZMA_PARSE( LD );
        2:   43:CLASS_CZMA_PARSE( LDI );
        2:   44:CLASS_CZMA_PARSE( LDIR );
        2:   45:CLASS_CZMA_PARSE( LDD );
        2:   46:CLASS_CZMA_PARSE( LDDR );
        7:   47:CLASS_CZMA_PARSE( EX );
        2:   48:CLASS_CZMA_PARSE( EXX );
        7:   49:CLASS_CZMA_PARSE( PUSH );
        7:   50:CLASS_CZMA_PARSE( POP );
        2:   51:CLASS_CZMA_PARSE( RLCA );
        2:   52:CLASS_CZMA_PARSE( RLA );
       11:   53:CLASS_CZMA_PARSE( RLC );
       12:   54:CLASS_CZMA_PARSE( RL );
        2:   55:CLASS_CZMA_PARSE( RRCA );
        2:   56:CLASS_CZMA_PARSE( RRA );
       11:   57:CLASS_CZMA_PARSE( RRC );
       12:   58:CLASS_CZMA_PARSE( RR );
       11:   59:CLASS_CZMA_PARSE( SLA );
       12:   60:CLASS_CZMA_PARSE( SRA );
       12:   61:CLASS_CZMA_PARSE( SRL );
        1:   62:CLASS_CZMA_PARSE( SLL );
       39:   63:CLASS_CZMA_PARSE( ADD );
       20:   64:CLASS_CZMA_PARSE( ADC );
       39:   65:CLASS_CZMA_PARSE( INC );
       16:   66:CLASS_CZMA_PARSE( SUB );
       20:   67:CLASS_CZMA_PARSE( SBC );
       21:   68:CLASS_CZMA_PARSE( DEC );
       16:   69:CLASS_CZMA_PARSE( AND );
       16:   70:CLASS_CZMA_PARSE( OR );
       16:   71:CLASS_CZMA_PARSE( XOR );
        2:   72:CLASS_CZMA_PARSE( CPL );
        2:   73:CLASS_CZMA_PARSE( NEG );
        2:   74:CLASS_CZMA_PARSE( CCF );
        2:   75:CLASS_CZMA_PARSE( SCF );
       82:   76:CLASS_CZMA_PARSE( BIT );
       82:   77:CLASS_CZMA_PARSE( SET );
       82:   78:CLASS_CZMA_PARSE( RES );
        2:   79:CLASS_CZMA_PARSE( CPI );
        2:   80:CLASS_CZMA_PARSE( CPIR );
        2:   81:CLASS_CZMA_PARSE( CPD );
        2:   82:CLASS_CZMA_PARSE( CPDR );
       20:   83:CLASS_CZMA_PARSE( CP );
       15:   84:CLASS_CZMA_PARSE( JP );
       10:   85:CLASS_CZMA_PARSE( JR );
        5:   86:CLASS_CZMA_PARSE( DJNZ );
       12:   87:CLASS_CZMA_PARSE( CALL );
       13:   88:CLASS_CZMA_PARSE( RET );
        2:   89:CLASS_CZMA_PARSE( RETI );
        2:   90:CLASS_CZMA_PARSE( RETN );
       13:   91:CLASS_CZMA_PARSE( RST );
     1574:   92:CLASS_CZMA_PARSE( NOP );
        2:   93:CLASS_CZMA_PARSE( HALT );
        2:   94:CLASS_CZMA_PARSE( DI );
        2:   95:CLASS_CZMA_PARSE( EI );
        2:   96:CLASS_CZMA_PARSE( IM0 );
        2:   97:CLASS_CZMA_PARSE( IM1 );
        2:   98:CLASS_CZMA_PARSE( IM2 );
       10:   99:CLASS_CZMA_PARSE( IN );
        2:  100:CLASS_CZMA_PARSE( INI );
        2:  101:CLASS_CZMA_PARSE( INIR );
        2:  102:CLASS_CZMA_PARSE( IND );
        2:  103:CLASS_CZMA_PARSE( INDR );
       10:  104:CLASS_CZMA_PARSE( OUT );
        2:  105:CLASS_CZMA_PARSE( OUTI );
        2:  106:CLASS_CZMA_PARSE( OTIR );
        2:  107:CLASS_CZMA_PARSE( OUTD );
        2:  108:CLASS_CZMA_PARSE( OTDR );
        2:  109:CLASS_CZMA_PARSE( DAA );
        2:  110:CLASS_CZMA_PARSE( RLD );
        2:  111:CLASS_CZMA_PARSE( RRD );
        5:  112:CLASS_CZMA_PARSE( MULUB );
        3:  113:CLASS_CZMA_PARSE( MULUW );
       64:  114:CLASS_CZMA_PARSE( IF );
        -:  115:
        -:  116:// --------------------------------------------------------------------
        -:  117:class CZMA_PARSE_ERROR: public CZMA_PARSE {
        -:  118:public:
        -:  119:	CZMA_REPEAT_T* p_repeat = nullptr;
        -:  120:
       18:  121:	using CZMA_PARSE::CZMA_PARSE;
        -:  122:	bool process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line = nullptr ) override;
       26:  123:	virtual bool is_parse_error( void ) {
       26:  124:		return true;
        -:  125:	}
        -:  126:};
        -:  127:
        -:  128:// --------------------------------------------------------------------
        -:  129:class CZMA_PARSE_REPEAT: public CZMA_PARSE {
        -:  130:public:
        -:  131:	CZMA_REPEAT_T *p_repeat = nullptr;
        -:  132:
       26:  133:	using CZMA_PARSE::CZMA_PARSE;
        -:  134:	bool process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line = nullptr ) override;
        -:  135:};
        -:  136:
        -:  137:// --------------------------------------------------------------------
        -:  138:class CZMA_PARSE_ELSEIF: public CZMA_PARSE_IF {
        -:  139:public:
        9:  140:	using CZMA_PARSE_IF::CZMA_PARSE_IF;
        -:  141:	bool process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line = nullptr ) override;
        -:  142:};
        -:  143:
        -:  144:// --------------------------------------------------------------------
        -:  145:class CZMA_PARSE_ELSE: public CZMA_PARSE_IF {
        -:  146:public:
       21:  147:	using CZMA_PARSE_IF::CZMA_PARSE_IF;
        -:  148:	bool process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line = nullptr ) override;
        -:  149:};
        -:  150:
        -:  151:// --------------------------------------------------------------------
        -:  152:class CZMA_PARSE_ENDIF: public CZMA_PARSE {
        -:  153:public:
        -:  154:	CZMA_IF_T* p_if = nullptr;
        -:  155:	bool is_loaded = false;
        -:  156:
       36:  157:	using CZMA_PARSE::CZMA_PARSE;
        -:  158:	bool process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line = nullptr ) override;
        -:  159:	bool write( CZMA_INFORMATION& info, std::ofstream* f ) override;
        -:  160:};
        -:  161:
        -:  162:// --------------------------------------------------------------------
        -:  163:class CZMA_PARSE_INCLUDE: public CZMA_PARSE {
        -:  164:public:
        -:  165:	CZMA_TEXT text;
        -:  166:	bool is_loaded = false;
        -:  167:	std::string s_file_name;
        -:  168:
       19:  169:	using CZMA_PARSE::CZMA_PARSE;
        -:  170:	bool process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line = nullptr ) override;
        -:  171:	bool write( CZMA_INFORMATION& info, std::ofstream* f ) override;
        -:  172:};
        -:  173:
        -:  174:// --------------------------------------------------------------------
       18:  175:bool CZMA_PARSE_INCLUDE::write( CZMA_INFORMATION& info, std::ofstream* f ) {
        -:  176:
       36:  177:	for( auto line : log ) {
       18:  178:		info.log << line << " begin" << std::endl;
        -:  179:	}
       18:  180:	bool result = this->text.write( info, f );
       36:  181:	for( auto line : log ) {
       18:  182:		info.log << line << " end" << std::endl;
       18:  183:		info.log << std::endl;
        -:  184:	}
       18:  185:	return result;
        -:  186:}
        -:  187:
        -:  188:// --------------------------------------------------------------------
        -:  189:class CZMA_PARSE_ENDR: public CZMA_PARSE {
        -:  190:public:
        -:  191:	std::vector< CZMA_TEXT* > text_list;
        -:  192:	CZMA_REPEAT_T* p_repeat = nullptr;
        -:  193:	bool is_loaded = false;
        -:  194:
       26:  195:	using CZMA_PARSE::CZMA_PARSE;
        -:  196:	bool process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line = nullptr ) override;
        -:  197:	bool write( CZMA_INFORMATION& info, std::ofstream* f ) override;
        -:  198:};
        -:  199:
        -:  200:// --------------------------------------------------------------------
        -:  201:class CZMA_PARSE_ENDM: public CZMA_PARSE {
        -:  202:public:
        -:  203:	CZMA_MACRO* p_macro = nullptr;
        -:  204:	bool is_loaded = false;
        -:  205:
       27:  206:	using CZMA_PARSE::CZMA_PARSE;
        -:  207:	bool process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line = nullptr ) override;
        -:  208:};
        -:  209:
        -:  210:// --------------------------------------------------------------------
       21:  211:bool CZMA_PARSE_ENDR::write( CZMA_INFORMATION& info, std::ofstream* f ) {
        -:  212:	bool result;
        -:  213:
       21:  214:	info.log << "\trepeat begin" << std::endl;
       21:  215:	for( auto line : log ) {
        -:  216:	}
       21:  217:	result = true;
      131:  218:	for( auto text : this->text_list ) {
      110:  219:		result = result & text->write( info, f );
        -:  220:	}
       21:  221:	info.log << "\trepeat end" << std::endl;
       59:  222:	for( auto line : log ) {
       38:  223:		info.log << line << std::endl;
       38:  224:		info.log << std::endl;
        -:  225:	}
       21:  226:	return result;
        -:  227:}
        -:  228:
        -:  229:// --------------------------------------------------------------------
        -:  230:class CZMA_PARSE_MACRO_INS: public CZMA_PARSE {
        -:  231:public:
        -:  232:	CZMA_TEXT text;
        -:  233:	bool is_loaded = false;
        -:  234:
       97:  235:	using CZMA_PARSE::CZMA_PARSE;
        -:  236:	bool process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line = nullptr ) override;
        -:  237:	bool write( CZMA_INFORMATION& info, std::ofstream* f ) override;
        -:  238:};
        -:  239:
        -:  240:// --------------------------------------------------------------------
       94:  241:bool CZMA_PARSE_MACRO_INS::write( CZMA_INFORMATION& info, std::ofstream* f ) {
       94:  242:	bool result = true;
        -:  243:
      282:  244:	for( auto line : log ) {
      188:  245:		info.log << line << std::endl;
        -:  246:	}
       94:  247:	text.write( info, f );
       94:  248:	return result;
        -:  249:}
        -:  250:
        -:  251:// --------------------------------------------------------------------
        -:  252:typedef enum {
        -:  253:	CZMA_ERROR, CZMA_BLANK, CZMA_INCLUDE, CZMA_ADD_INCLUDE_PATH, CZMA_USER_ERROR, CZMA_USER_MESSAGE, CZMA_LABEL, CZMA_GLOBAL_LABEL, 
        -:  254:	CZMA_SCOPE, CZMA_ENDSCOPE, CZMA_IF, CZMA_ELSEIF, CZMA_ELSE, CZMA_ENDIF, CZMA_ENDM,
        -:  255:	CZMA_ALIGN, CZMA_SPACE, CZMA_REPEAT, CZMA_ENDR, CZMA_ORG, CZMA_GLOBAL_SYMBOL, CZMA_BINARY_LINK, CZMA_DEFB, CZMA_DEFW, CZMA_DEFD, CZMA_DEFS,
        -:  256:	CZMA_LD, CZMA_LDI, CZMA_LDIR, CZMA_LDD, CZMA_LDDR, CZMA_EX, CZMA_EXX, CZMA_PUSH, CZMA_POP, 
        -:  257:	CZMA_RLCA, CZMA_RLA, CZMA_RLC, CZMA_RL, CZMA_RRCA, CZMA_RRA, CZMA_RRC, CZMA_RR,
        -:  258:	CZMA_SLA, CZMA_SRA, CZMA_SRL, CZMA_SLL, CZMA_ADD, CZMA_ADC, CZMA_INC, CZMA_SUB, CZMA_SBC,
        -:  259:	CZMA_DEC, CZMA_AND, CZMA_OR, CZMA_XOR, CZMA_CPL, CZMA_NEG, CZMA_CCF, CZMA_SCF,
        -:  260:	CZMA_BIT, CZMA_RES, CZMA_SET, CZMA_CPI, CZMA_CPIR, CZMA_CPD, CZMA_CPDR, CZMA_CP, 
        -:  261:	CZMA_JP, CZMA_JR, CZMA_DJNZ, CZMA_CALL, CZMA_RET, CZMA_RETI, CZMA_RETN, CZMA_RST, 
        -:  262:	CZMA_NOP, CZMA_HALT, CZMA_DI, CZMA_EI, CZMA_IM0, CZMA_IM1, CZMA_IM2, CZMA_IN, 
        -:  263:	CZMA_INI, CZMA_INIR, CZMA_IND, CZMA_INDR, CZMA_OUT, CZMA_OUTI, CZMA_OTIR, 
        -:  264:	CZMA_OUTD, CZMA_OTDR, CZMA_DAA, CZMA_RLD, CZMA_RRD, CZMA_MULUB, CZMA_MULUW,
        -:  265:} CZMA_COMMAND_TYPE;
        -:  266:
        -:  267:int CZMA_PARSE::number_of_error = 0;
        -:  268:
        -:  269:// --------------------------------------------------------------------
     5488:  270:static std::map< std::string, CZMA_COMMAND_TYPE > command_list = {
        -:  271:	{ "ALIGN", CZMA_ALIGN },
        -:  272:	{ "SPACE", CZMA_SPACE },
        -:  273:	{ "REPEAT", CZMA_REPEAT },
        -:  274:	{ "ENDR", CZMA_ENDR },
        -:  275:	{ "ENDM", CZMA_ENDM },
        -:  276:	{ "IF", CZMA_IF },
        -:  277:	{ "ELSEIF", CZMA_ELSEIF },
        -:  278:	{ "ELSE", CZMA_ELSE },
        -:  279:	{ "ENDIF", CZMA_ENDIF },
        -:  280:	{ "ORG", CZMA_ORG },
        -:  281:	{ "INCLUDE", CZMA_INCLUDE },
        -:  282:	{ "ADD_INCLUDE_PATH", CZMA_ADD_INCLUDE_PATH },
        -:  283:	{ "ERROR", CZMA_USER_ERROR },
        -:  284:	{ "MESSAGE", CZMA_USER_MESSAGE },
        -:  285:	{ "SCOPE", CZMA_SCOPE },
        -:  286:	{ "ENDSCOPE", CZMA_ENDSCOPE },
        -:  287:	{ "BINARY_LINK", CZMA_BINARY_LINK },
        -:  288:	{ "DEFB", CZMA_DEFB },
        -:  289:	{ "DEFW", CZMA_DEFW },
        -:  290:	{ "DEFD", CZMA_DEFD },
        -:  291:	{ "DEFS", CZMA_DEFS },
        -:  292:	{ "DB", CZMA_DEFB },
        -:  293:	{ "DW", CZMA_DEFW },
        -:  294:	{ "DD", CZMA_DEFD },
        -:  295:	{ "DS", CZMA_DEFS },
        -:  296:	{ "LD", CZMA_LD },
        -:  297:	{ "LDI", CZMA_LDI }, 
        -:  298:	{ "LDIR", CZMA_LDIR },
        -:  299:	{ "LDD", CZMA_LDD }, 
        -:  300:	{ "LDDR", CZMA_LDDR },
        -:  301:	{ "EX", CZMA_EX },
        -:  302:	{ "EXX", CZMA_EXX },
        -:  303:	{ "PUSH", CZMA_PUSH },
        -:  304:	{ "POP", CZMA_POP },
        -:  305:	{ "RLCA", CZMA_RLCA },
        -:  306:	{ "RLA", CZMA_RLA },
        -:  307:	{ "RLC", CZMA_RLC },
        -:  308:	{ "RL", CZMA_RL },
        -:  309:	{ "RRCA", CZMA_RRCA },
        -:  310:	{ "RRA", CZMA_RRA },
        -:  311:	{ "RRC", CZMA_RRC },
        -:  312:	{ "RR", CZMA_RR },
        -:  313:	{ "SLA", CZMA_SLA },
        -:  314:	{ "SRA", CZMA_SRA },
        -:  315:	{ "SRL", CZMA_SRL },
        -:  316:	{ "SLL", CZMA_SLL },
        -:  317:	{ "ADD", CZMA_ADD },
        -:  318:	{ "ADC", CZMA_ADC },
        -:  319:	{ "INC", CZMA_INC },
        -:  320:	{ "SUB", CZMA_SUB },
        -:  321:	{ "SBC", CZMA_SBC },
        -:  322:	{ "DEC", CZMA_DEC },
        -:  323:	{ "AND", CZMA_AND },
        -:  324:	{ "OR", CZMA_OR },
        -:  325:	{ "XOR", CZMA_XOR },
        -:  326:	{ "CPL", CZMA_CPL },
        -:  327:	{ "NEG", CZMA_NEG },
        -:  328:	{ "CCF", CZMA_CCF },
        -:  329:	{ "SCF", CZMA_SCF },
        -:  330:	{ "BIT", CZMA_BIT },
        -:  331:	{ "RES", CZMA_RES },
        -:  332:	{ "SET", CZMA_SET },
        -:  333:	{ "CPI", CZMA_CPI },
        -:  334:	{ "CPIR", CZMA_CPIR },
        -:  335:	{ "CPD", CZMA_CPD },
        -:  336:	{ "CPDR", CZMA_CPDR },
        -:  337:	{ "CP", CZMA_CP },
        -:  338:	{ "JP", CZMA_JP },
        -:  339:	{ "JR", CZMA_JR },
        -:  340:	{ "DJNZ", CZMA_DJNZ },
        -:  341:	{ "CALL", CZMA_CALL },
        -:  342:	{ "RET", CZMA_RET },
        -:  343:	{ "RETI", CZMA_RETI },
        -:  344:	{ "RETN", CZMA_RETN },
        -:  345:	{ "RST", CZMA_RST },
        -:  346:	{ "NOP", CZMA_NOP },
        -:  347:	{ "HALT", CZMA_HALT },
        -:  348:	{ "DI", CZMA_DI },
        -:  349:	{ "EI", CZMA_EI },
        -:  350:	{ "IM0", CZMA_IM0 },
        -:  351:	{ "IM1", CZMA_IM1 },
        -:  352:	{ "IM2", CZMA_IM2 },
        -:  353:	{ "IN", CZMA_IN },
        -:  354:	{ "INI", CZMA_INI },
        -:  355:	{ "INIR", CZMA_INIR },
        -:  356:	{ "IND", CZMA_IND },
        -:  357:	{ "INDR", CZMA_INDR },
        -:  358:	{ "OUT", CZMA_OUT },
        -:  359:	{ "OUTI", CZMA_OUTI },
        -:  360:	{ "OTIR", CZMA_OTIR },
        -:  361:	{ "OUTD", CZMA_OUTD },
        -:  362:	{ "OTDR", CZMA_OTDR },
        -:  363:	{ "DAA", CZMA_DAA },
        -:  364:	{ "RLD", CZMA_RLD },
        -:  365:	{ "RRD", CZMA_RRD },
        -:  366:	{ "MULUB", CZMA_MULUB },
        -:  367:	{ "MULUW", CZMA_MULUW },
     5432:  368:};
        -:  369:
        -:  370:// --------------------------------------------------------------------
        -:  371:#define OPE_CASE( operation )																			\
        -:  372:	case CZMA_##operation:																			\
        -:  373:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_##operation( words, p_file_name, line_no ))
        -:  374:
        -:  375:// --------------------------------------------------------------------
     8376:  376:CZMA_PARSE* CZMA_PARSE::create( CZMA_INFORMATION& info, std::vector<std::string> words, const char* p_file_name, int line_no ) {
        -:  377:
     8376:  378:	if( words.size() == 0 ) {
     3387:  379:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_BLANK( words, p_file_name, line_no ));
        -:  380:	}
     4989:  381:	if( words.size() == 2 && words[1] == ":" ) {
       30:  382:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_LABEL( words, p_file_name, line_no ));
        -:  383:	}
     4959:  384:	if( words.size() == 2 && words[1] == "::" ) {
        6:  385:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_GLOBAL_LABEL( words, p_file_name, line_no ));
        -:  386:	}
     4953:  387:	if( words.size() >= 3 && words[1] == "=" ) {
       12:  388:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_SYMBOL( words, p_file_name, line_no ));
        -:  389:	}
     4941:  390:	if( words.size() >= 3 && words[1] == ":=" ) {
        8:  391:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_GLOBAL_SYMBOL( words, p_file_name, line_no ));
        -:  392:	}
     4933:  393:	if( words.size() >= 2 && words[1] == "MACRO" ) {
       28:  394:		info.macro_list[words[0]] = nullptr;
       28:  395:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_MACRO( words, p_file_name, line_no ));
        -:  396:	}
     4905:  397:	if( words.size() >= 1 && info.macro_list.count( words[0] ) ) {
       97:  398:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_MACRO_INS( words, p_file_name, line_no ));
        -:  399:	}
     4808:  400:	switch( command_list[words[0]] ) {
       21:  401:		OPE_CASE( ORG );
       19:  402:		OPE_CASE( INCLUDE );
        5:  403:		OPE_CASE( ADD_INCLUDE_PATH );
        2:  404:		OPE_CASE( ALIGN );
        2:  405:		OPE_CASE( SPACE );
       26:  406:		OPE_CASE( REPEAT );
       26:  407:		OPE_CASE( ENDR );
       27:  408:		OPE_CASE( ENDM );
       34:  409:		OPE_CASE( IF );
        9:  410:		OPE_CASE( ELSEIF );
       21:  411:		OPE_CASE( ELSE );
       36:  412:		OPE_CASE( ENDIF );
       11:  413:		OPE_CASE( USER_ERROR );
       66:  414:		OPE_CASE( USER_MESSAGE );
       20:  415:		OPE_CASE( SCOPE );
       14:  416:		OPE_CASE( ENDSCOPE );
        1:  417:		OPE_CASE( BINARY_LINK );
     1251:  418:		OPE_CASE( DEFB );
      473:  419:		OPE_CASE( DEFW );
        8:  420:		OPE_CASE( DEFD );
       24:  421:		OPE_CASE( DEFS );
      380:  422:		OPE_CASE( LD );
        7:  423:		OPE_CASE( PUSH );
        7:  424:		OPE_CASE( POP );
        7:  425:		OPE_CASE( EX );
        2:  426:		OPE_CASE( EXX );
        2:  427:		OPE_CASE( LDI );
        2:  428:		OPE_CASE( LDIR );
        2:  429:		OPE_CASE( LDD );
        2:  430:		OPE_CASE( LDDR );
        2:  431:		OPE_CASE( RLCA );
        2:  432:		OPE_CASE( RLA );
       11:  433:		OPE_CASE( RLC );
       12:  434:		OPE_CASE( RL );
        2:  435:		OPE_CASE( RRCA );
        2:  436:		OPE_CASE( RRA );
       11:  437:		OPE_CASE( RRC );
       12:  438:		OPE_CASE( RR );
       11:  439:		OPE_CASE( SLA );
       12:  440:		OPE_CASE( SRA );
       12:  441:		OPE_CASE( SRL );
        1:  442:		OPE_CASE( SLL );
       39:  443:		OPE_CASE( ADD );
       20:  444:		OPE_CASE( ADC );
       39:  445:		OPE_CASE( INC );
       16:  446:		OPE_CASE( SUB );
       20:  447:		OPE_CASE( SBC );
       21:  448:		OPE_CASE( DEC );
       16:  449:		OPE_CASE( AND );
       16:  450:		OPE_CASE( OR );
       16:  451:		OPE_CASE( XOR );
        2:  452:		OPE_CASE( CPL );
        2:  453:		OPE_CASE( NEG );
        2:  454:		OPE_CASE( CCF );
        2:  455:		OPE_CASE( SCF );
       82:  456:		OPE_CASE( BIT );
       82:  457:		OPE_CASE( RES );
       82:  458:		OPE_CASE( SET );
        2:  459:		OPE_CASE( CPI );
        2:  460:		OPE_CASE( CPIR );
        2:  461:		OPE_CASE( CPD );
        2:  462:		OPE_CASE( CPDR );
       20:  463:		OPE_CASE( CP );
       15:  464:		OPE_CASE( JP );
       10:  465:		OPE_CASE( JR );
        5:  466:		OPE_CASE( DJNZ );
       12:  467:		OPE_CASE( CALL );
       13:  468:		OPE_CASE( RET );
        2:  469:		OPE_CASE( RETI );
        2:  470:		OPE_CASE( RETN );
       13:  471:		OPE_CASE( RST );
     1574:  472:		OPE_CASE( NOP );
        2:  473:		OPE_CASE( HALT );
        2:  474:		OPE_CASE( EI );
        2:  475:		OPE_CASE( DI );
        2:  476:		OPE_CASE( IM0 );
        2:  477:		OPE_CASE( IM1 );
        2:  478:		OPE_CASE( IM2 );
       10:  479:		OPE_CASE( IN );
        2:  480:		OPE_CASE( INI );
        2:  481:		OPE_CASE( INIR );
        2:  482:		OPE_CASE( IND );
        2:  483:		OPE_CASE( INDR );
       10:  484:		OPE_CASE( OUT );
        2:  485:		OPE_CASE( OUTI );
        2:  486:		OPE_CASE( OTIR );
        2:  487:		OPE_CASE( OUTD );
        2:  488:		OPE_CASE( OTDR );
        2:  489:		OPE_CASE( DAA );
        2:  490:		OPE_CASE( RLD );
        2:  491:		OPE_CASE( RRD );
        5:  492:		OPE_CASE( MULUB );
        3:  493:		OPE_CASE( MULUW );
       18:  494:	default:
       18:  495:		break;
        -:  496:	}
       18:  497:	return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_ERROR( words, p_file_name, line_no ));
        -:  498:}
        -:  499:
        -:  500:// --------------------------------------------------------------------
     4156:  501:void CZMA_PARSE::log_data_dump( void ) {
        -:  502:	int address, count;
     8312:  503:	std::stringstream line;
     4156:  504:	address = this->get_code_address();
     4156:  505:	count = 0;
     4156:  506:	line.str("");
    29356:  507:	for( auto d : data ) {
    25200:  508:		if( count == 0 ) {
     6224:  509:			line << std::hex << std::setw( 6 ) << std::setfill( '0' ) << address << ":";
        -:  510:		}
    25200:  511:		line << " " << std::hex << std::setw( 2 ) << std::setfill( '0' ) << (int)d;
    25200:  512:		address++;
    25200:  513:		count++;
    25200:  514:		if( count == 8 ) {
     2070:  515:			log.push_back( line.str() );
     2070:  516:			line.str( "" );
     2070:  517:			count = 0;
        -:  518:		}
        -:  519:	}
     4156:  520:	if( count != 0 ) {
     4154:  521:		log.push_back( line.str() );
        -:  522:	}
     4156:  523:}
        -:  524:
        -:  525:// --------------------------------------------------------------------
     4471:  526:std::string CZMA_PARSE::get_line( void ) {
     8942:  527:	std::string r, ss;
        -:  528:
     4471:  529:	r = "";
    20194:  530:	for( auto s : words ) {
    15723:  531:		if( s.size() > 0 && s[0] == '\"' ) {
       35:  532:			ss = "\"";
      144:  533:			for( int i = 1; i < (int)s.size(); i++ ) {
      109:  534:				switch( s[i] ) {
    #####:  535:				case '\a':	ss = ss + "\\a";	break;
    #####:  536:				case '\b':	ss = ss + "\\b";	break;
    #####:  537:				case '\f':	ss = ss + "\\f";	break;
        1:  538:				case '\n':	ss = ss + "\\n";	break;
        1:  539:				case '\r':	ss = ss + "\\r";	break;
    #####:  540:				case '\t':	ss = ss + "\\t";	break;
    #####:  541:				case '\\':	ss = ss + "\\\\";	break;
    #####:  542:				case '\'':	ss = ss + "\\'";	break;
    #####:  543:				case '\"':	ss = ss + "\\\"";	break;
      107:  544:				default:	ss = ss + s[i];		break;
        -:  545:				}
        -:  546:			}
       35:  547:			ss = ss + '\"';
        -:  548:		}
        -:  549:		else {
    15688:  550:			ss = s;
        -:  551:		}
    15723:  552:		if( r == "" ) {
     4471:  553:			r = ss;
        -:  554:		}
        -:  555:		else {
    11252:  556:			r = r + " " + ss;
        -:  557:		}
        -:  558:	}
     8942:  559:	return r;
        -:  560:}
        -:  561:
        -:  562:// --------------------------------------------------------------------
     7616:  563:CZMA_PARSE* CZMA_PARSE::create( CZMA_INFORMATION& info, std::string s, const char* p_file_name, int line_no ) {
    15232:  564:	std::vector<std::string> words;
        -:  565:
     7616:  566:	words = CZMA_PARSE::get_word_split( s );
    15232:  567:	return create( info, words, p_file_name, line_no );
        -:  568:}
        -:  569:
        -:  570:// --------------------------------------------------------------------
    10182:  571:bool CZMA_PARSE_BLANK::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -:  572:
    10182:  573:	this->is_data_fixed = true;
    10182:  574:	update_flags( &info, p_last_line );
    10182:  575:	this->set_code_size( &info, 0 );
    10182:  576:	return this->check_all_fixed();
        -:  577:}
        -:  578:
        -:  579:// --------------------------------------------------------------------
       86:  580:bool CZMA_PARSE_MACRO::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
      172:  581:	std::string label;
        -:  582:	CZMA_MACRO* p_macro;
      172:  583:	CZMA_MACRO_ARG arg;
        -:  584:	int i;
        -:  585:
       86:  586:	bool result = update_flags( &info, p_last_line );
       86:  587:	if( !this->is_data_fixed ) {
       36:  588:		if( info.macro_list.count( words[0] ) && info.macro_list[words[0]] != nullptr ) {
        -:  589:			//	同じ名前のマクロを宣言することはできない
        3:  590:			put_error( std::string( "There are declarations of the same macro '" ) + words[0] + "' in multiple places." );
        3:  591:			return false;
        -:  592:		}
        -:  593:		//	引数抽出処理
       33:  594:		p_macro = new CZMA_MACRO;
       58:  595:		for( i = 2; i < ( int) words.size(); ) {
       34:  596:			if( words[i] == "@" ) {
        6:  597:				arg.is_through = true;
        6:  598:				i++;
        -:  599:			}
        -:  600:			else {
       28:  601:				arg.is_through = false;
        -:  602:			}
       34:  603:			if( i >= (int)words.size() ) {
        3:  604:				put_error( "Illegal argument." );
        3:  605:				return false;
        -:  606:			}
       31:  607:			arg.name = words[i];
       31:  608:			if( (i + 1) < (int)words.size() && words[ i + 1 ] != "," ) {
        3:  609:				put_error( "Illegal argument." );
        3:  610:				return false;
        -:  611:			}
       44:  612:			for( auto s : p_macro->parameter_name_list ) {
       19:  613:				if( s.name == words[i] ) {
        3:  614:					put_error( std::string( "Multiple arguments of the same name '" + words[i] + "' exist." ) );
        3:  615:					return false;
        -:  616:				}
        -:  617:			}
       25:  618:			i = i + 2;
       25:  619:			p_macro->parameter_name_list.push_back( arg );
        -:  620:		}
       24:  621:		info.block_type = info.CZMA_INFO_MACRO_BLOCK;
       24:  622:		info.is_block_processing = true;
       24:  623:		info.p_macro = p_macro;
       24:  624:		info.p_text = &(info.p_macro->m_text);
       24:  625:		this->is_data_fixed = true;
       24:  626:		this->set_code_size( &info, 0 );
       24:  627:		info.macro_list[words[0]] = p_macro;
        -:  628:	}
        -:  629:	//	log
       74:  630:	if( !is_analyze_phase ) {
       24:  631:		log.push_back( "Define macro {" + get_line() + "}" );
       24:  632:		log.push_back( "" );
        -:  633:	}
       74:  634:	return result;
        -:  635:}
        -:  636:
        -:  637:// --------------------------------------------------------------------
       85:  638:bool CZMA_PARSE_ENDM::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -:  639:
       85:  640:	update_flags( &info, p_last_line );
       85:  641:	info.is_block_processing = false;
       85:  642:	this->is_data_fixed = true;
       85:  643:	this->set_code_size( &info, 0 );
       85:  644:	return check_all_fixed();
        -:  645:}
        -:  646:
        -:  647:// --------------------------------------------------------------------
        6:  648:bool CZMA_PARSE_ALIGN::process( CZMA_INFORMATION &info, CZMA_PARSE *p_last_line ) {
        -:  649:	int i, address, padding_size, block_size;
       12:  650:	CVALUE v;
        -:  651:
        6:  652:	update_flags( &info, p_last_line );
        6:  653:	if( !this->is_data_fixed ){
        2:  654:		if( this->get_fixed_code_address() ){
        2:  655:			i = this->expression( info, 1, v );
        2:  656:			if( i == 0 ){
    #####:  657:				put_error( std::string( "Cannot evaluate the expression" ) );
    #####:  658:				data.clear();
    #####:  659:				return false;
        -:  660:			}
        2:  661:			if( v.type != CVALUE::CV_INTEGER ){
    #####:  662:				put_error( "Illegal expression." );
    #####:  663:				return false;
        -:  664:			}
        2:  665:			if( v.i < 1 ){
    #####:  666:				put_error( "Illegal parameter." );
    #####:  667:				return false;
        -:  668:			}
        -:  669:			//	パディングの量を計算する
        2:  670:			block_size = v.i;
        2:  671:			address = this->get_code_address();
        2:  672:			padding_size = ( block_size - ( address % block_size ) ) % block_size;
        -:  673:			//	パディングする
        2:  674:			this->set_code_size( &info, padding_size );
    32738:  675:			for( i = 0; i < padding_size; i++ ){
    32736:  676:				this->data.push_back( 0 );
        -:  677:			}
        2:  678:			this->is_data_fixed = true;
        2:  679:			info.is_updated = true;
        -:  680:		}
        -:  681:	}
        -:  682:
        6:  683:	if( !is_analyze_phase ){
        2:  684:		log.push_back( "[" + get_line() + "]" );
        2:  685:		log.push_back( "\tPadding: " + std::to_string( this->get_code_size() ) + "byte(s)" );
        2:  686:		log.push_back( "" );
        -:  687:	}
        6:  688:	return check_all_fixed();
        -:  689:}
        -:  690:
        -:  691:// --------------------------------------------------------------------
        6:  692:bool CZMA_PARSE_SPACE::process( CZMA_INFORMATION &info, CZMA_PARSE *p_last_line ){
        -:  693:	int i, space_size, value;
       12:  694:	CVALUE v;
        -:  695:
        6:  696:	update_flags( &info, p_last_line );
        6:  697:	if( !this->is_data_fixed ){
        2:  698:		if( !this->get_fixed_code_size() ){
        -:  699:			//	サイズ
        2:  700:			i = this->expression( info, 1, v );
        2:  701:			if( i == 0 ){
    #####:  702:				put_error( std::string( "Cannot evaluate the expression" ) );
    #####:  703:				data.clear();
    #####:  704:				return false;
        -:  705:			}
        2:  706:			if( v.type != CVALUE::CV_INTEGER ){
    #####:  707:				put_error( "Illegal expression." );
    #####:  708:				return false;
        -:  709:			}
        2:  710:			if( v.i < 0 || v.i > 65536 ){
    #####:  711:				put_error( "Invalid parameter." );
    #####:  712:				return false;
        -:  713:			}
        2:  714:			space_size = v.i;
        -:  715:			//	, があるか？
        2:  716:			if( i < (int)this->words.size() && this->words[ i ] == "," ){
        1:  717:				i = this->expression( info, i + 1, v );
        1:  718:				if( i == 0 ){
    #####:  719:					put_error( std::string( "Cannot evaluate the expression" ) );
    #####:  720:					data.clear();
    #####:  721:					return false;
        -:  722:				}
        1:  723:				if( v.type != CVALUE::CV_INTEGER ){
    #####:  724:					put_error( "Illegal expression." );
    #####:  725:					return false;
        -:  726:				}
        1:  727:				if( v.i < 0 || v.i > 65536 ){
    #####:  728:					put_error( "Invalid parameter." );
    #####:  729:					return false;
        -:  730:				}
        1:  731:				value = v.i;
        -:  732:			}
        -:  733:			else{
        1:  734:				value = 0;
        -:  735:			}
        -:  736:			//	スペースを確保する
        2:  737:			this->set_code_size( &info, space_size );
       22:  738:			for( i = 0; i < space_size; i++ ){
       20:  739:				this->data.push_back( value );
        -:  740:			}
        2:  741:			this->is_data_fixed = true;
        2:  742:			info.is_updated = true;
        -:  743:		}
        -:  744:	}
        -:  745:
        6:  746:	if( !is_analyze_phase ){
        2:  747:		log.push_back( "[" + get_line() + "]" );
        2:  748:		if( this->get_code_size() ){
        2:  749:			log.push_back( "\tAllocate space: " + std::to_string( this->get_code_size() ) + "byte(s)" );
        2:  750:			log.push_back( "\t\tFill value: " + std::to_string( this->data[0] ) );
        -:  751:		}
        -:  752:		else{
    #####:  753:			log.push_back( "\tNo space was allocated." );
        -:  754:		}
        2:  755:		log.push_back( "" );
        -:  756:	}
        6:  757:	return check_all_fixed();
        -:  758:}
        -:  759:
        -:  760:// --------------------------------------------------------------------
       72:  761:bool CZMA_PARSE_REPEAT::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
      144:  762:	std::string label;
      144:  763:	CVALUE v;
        -:  764:	int index;
        -:  765:
       72:  766:	update_flags( &info, p_last_line );
       72:  767:	this->set_code_size( &info, 0 );
       72:  768:	if( p_repeat == nullptr ) {
       22:  769:		p_repeat = new CZMA_REPEAT_T;
        -:  770:	}
       72:  771:	if( !p_repeat->is_counter_end_fixed ) {
       30:  772:		if( words.size() < 4 ) {
        -:  773:			//	REPEAT 変数名 , 値 で、少なくとも 4[word] なければならない
        3:  774:			put_error( "Illegal parameter." );
        3:  775:			return false;
        -:  776:		}
       27:  777:		if( words[2] != "," ) {
        3:  778:			put_error( "Illegal parameter." );
        3:  779:			return false;
        -:  780:		}
        -:  781:
       24:  782:		info.block_type = info.CZMA_INFO_REPEAT_BLOCK;
       24:  783:		info.p_repeat = p_repeat;
       24:  784:		info.is_block_processing = true;
       24:  785:		info.p_text = &(info.p_repeat->m_text);
        -:  786:
       24:  787:		index = this->expression( info, 3, v );
       24:  788:		if( index == 0 ) {
        4:  789:			put_error( "Illegal expression." );
        4:  790:			return false;
        -:  791:		}
       20:  792:		if( index < ( int) words.size() ) {
        2:  793:			put_error( "Illegal expression." );
        2:  794:			return false;
        -:  795:		}
       18:  796:		if( v.type != CVALUE::CV_INTEGER ) {
        2:  797:			put_error( "Illegal parameter." );
        2:  798:			return false;
        -:  799:		}
       16:  800:		p_repeat->counter_end = v.i;
       16:  801:		p_repeat->is_counter_end_fixed = true;
       16:  802:		p_repeat->scope_name = "@REPEAT" + std::to_string( info.get_auto_label_index() );
       16:  803:		info.scope.push_back( p_repeat->scope_name );
       16:  804:		p_repeat->counter_symbol = info.get_scope_path() + words[1];
       16:  805:		v.type = CVALUE::CV_INTEGER;
       16:  806:		v.i = 0;
       16:  807:		info.dict[p_repeat->counter_symbol] = v;
        -:  808:
       16:  809:		this->is_data_fixed = true;
       16:  810:		info.is_updated = true;
        -:  811:	}
        -:  812:	else {
       42:  813:		info.scope.push_back( p_repeat->scope_name );
        -:  814:
       42:  815:		p_repeat->counter_symbol = info.get_scope_path() + words[1];
        -:  816:	}
        -:  817:
        -:  818:	//	log
       58:  819:	if( !is_analyze_phase ) {
       16:  820:		log.push_back( "[" + get_line() + "]" );
       16:  821:		log.push_back( "\tScope path: " + info.get_scope_path() );
       16:  822:		log.push_back( "" );
        -:  823:	}
       58:  824:	return check_all_fixed();
        -:  825:}
        -:  826:
        -:  827:// --------------------------------------------------------------------
       97:  828:bool CZMA_PARSE_IF::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
      194:  829:	std::string label;
        -:  830:	CZMA_IF_T* p_if;
        -:  831:	CZMA_IF_SUB_T* p_if_sub;
        -:  832:
       97:  833:	update_flags( &info, p_last_line );
       97:  834:	if( !this->is_data_fixed ) {
        -:  835:		//	条件式を取り込む
       31:  836:		p_if				= new CZMA_IF_T;
       31:  837:		p_if_sub			= new CZMA_IF_SUB_T;
       31:  838:		p_if_sub->p_if		= this;
       31:  839:		p_if->m_sub.push_back( p_if_sub );
       31:  840:		p_if_sub->p_text	= new CZMA_TEXT;
       31:  841:		info.block_type				= info.CZMA_INFO_IF_BLOCK;
       31:  842:		info.is_block_processing	= true;
       31:  843:		info.p_if					= p_if;
       31:  844:		info.p_text					= &(p_if_sub->p_text->m_text);
       31:  845:		this->is_data_fixed			= true;
       31:  846:		this->set_code_size( &info, 0 );
        -:  847:	}
        -:  848:	//	log
       97:  849:	if( !is_analyze_phase ) {
       31:  850:		log.push_back( "[" + get_line() + "]" );
       31:  851:		log.push_back( "" );
        -:  852:	}
      194:  853:	return check_all_fixed();
        -:  854:}
        -:  855:
        -:  856:// --------------------------------------------------------------------
       27:  857:bool CZMA_PARSE_ELSEIF::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
       54:  858:	std::string label;
        -:  859:	CZMA_IF_T* p_if;
        -:  860:	CZMA_IF_SUB_T* p_if_sub;
        -:  861:
       27:  862:	update_flags( &info, p_last_line );
       27:  863:	if( !this->is_data_fixed ) {
       11:  864:		if( !info.is_block_processing || info.block_type != info.CZMA_INFO_IF_BLOCK ) {
        3:  865:			put_error( "There is an ELSEIF description at an incorrect position." );
        3:  866:			return false;
        -:  867:		}
        -:  868:		//	条件式を取り込む
        8:  869:		p_if = info.p_if;
        8:  870:		p_if_sub = new CZMA_IF_SUB_T;
        8:  871:		p_if_sub->p_if = this;
        8:  872:		p_if->m_sub.push_back( p_if_sub );
        8:  873:		p_if_sub->p_text = new CZMA_TEXT;
        8:  874:		info.p_text = &(p_if_sub->p_text->m_text);
        8:  875:		this->is_data_fixed = true;
        8:  876:		this->set_code_size( &info, 0 );
        -:  877:	}
        -:  878:	//	log
       24:  879:	if( !is_analyze_phase ) {
        8:  880:		log.push_back( "[" + get_line() + "]" );
        8:  881:		log.push_back( "" );
        -:  882:	}
       24:  883:	return check_all_fixed();
        -:  884:}
        -:  885:
        -:  886:// --------------------------------------------------------------------
       62:  887:bool CZMA_PARSE_ELSE::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
      124:  888:	std::string label;
        -:  889:	CZMA_IF_T* p_if;
        -:  890:	CZMA_IF_SUB_T* p_if_sub;
        -:  891:
       62:  892:	update_flags( &info, p_last_line );
       62:  893:	if( !this->is_data_fixed ) {
       22:  894:		if( !info.is_block_processing || info.block_type != info.CZMA_INFO_IF_BLOCK ) {
        3:  895:			put_error( "There is an ELSE description at an incorrect position." );
        3:  896:			return false;
        -:  897:		}
        -:  898:		//	条件式を取り込む
       19:  899:		p_if = info.p_if;
       19:  900:		p_if_sub = new CZMA_IF_SUB_T;
       19:  901:		p_if_sub->p_if = this;
       19:  902:		p_if->m_sub.push_back( p_if_sub );
       19:  903:		p_if_sub->p_text = new CZMA_TEXT;
       19:  904:		info.p_text = &(p_if_sub->p_text->m_text);
       19:  905:		this->is_data_fixed = true;
       19:  906:		this->set_code_size( &info, 0 );
        -:  907:	}
       59:  908:	if( words.size() != 1 ) {
        3:  909:		put_error( "ELSE is not need parameters." );
        3:  910:		return false;
        -:  911:	}
        -:  912:	//	log
       56:  913:	if( !is_analyze_phase ) {
       18:  914:		log.push_back( "[" + get_line() + "]" );
       18:  915:		log.push_back( "" );
        -:  916:	}
       56:  917:	return check_all_fixed();
        -:  918:}
        -:  919:
        -:  920:// --------------------------------------------------------------------
      102:  921:bool CZMA_PARSE_ENDIF::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
      204:  922:	CVALUE v;
        -:  923:	unsigned int sub_success_count;
        -:  924:	bool result;
        -:  925:	bool do_process;
        -:  926:	bool has_else, no_fixed;
      102:  927:	CZMA_PARSE_IF* p_selected_if = nullptr;
        -:  928:	int index, current_next_code_address;
        -:  929:	CZMA_PARSE* p_last_line_backup;
        -:  930:
      102:  931:	update_flags( &info, p_last_line );
      102:  932:	if( !this->is_loaded ) {
       33:  933:		p_if = info.p_if;
       33:  934:		info.p_if = nullptr;
       33:  935:		this->is_loaded = true;
       33:  936:		info.is_updated = true;
        -:  937:	}
      102:  938:	if( p_if == nullptr ) {
        7:  939:		put_error( "Illegal ENDIF." );
        7:  940:		return false;
        -:  941:	}
       95:  942:	info.is_block_processing = false;
       95:  943:	if( words.size() != 1 ) {
        3:  944:		put_error( "ENDIF is not need parameters." );
        3:  945:		return false;
        -:  946:	}
        -:  947:	//	コードサイズを求める処理
       92:  948:	if( this->next_code_address == -1 ) {
       64:  949:		current_next_code_address = -1;
       64:  950:		p_last_line_backup = p_last_line;
       64:  951:		has_else = false;
       64:  952:		no_fixed = false;
       99:  953:		for( auto i : p_if->m_sub ) {
       77:  954:			if( i->p_if->words[0] == "ELSE" ) {
       10:  955:				has_else = true;
        -:  956:			}
       77:  957:			p_last_line = i->p_text->process( info, sub_success_count, p_last_line_backup, false );
       77:  958:			if( current_next_code_address == -1 ) {
       64:  959:				if( p_last_line->get_next_code_address() == -1 ) {
       42:  960:					no_fixed = true;
       42:  961:					break;
        -:  962:				}
       22:  963:				current_next_code_address = p_last_line->get_next_code_address();
        -:  964:			}
        -:  965:			else {
       13:  966:				if( p_last_line->get_next_code_address() != current_next_code_address ) {
    #####:  967:					no_fixed = true;
    #####:  968:					break;
        -:  969:				}
        -:  970:			}
        -:  971:		}
        -:  972:		//	else句を持っており、かつすべての句の中身のサイズが同じであれば、中身のコードが確定していなくても、サイズを確定させる
       64:  973:		if( current_next_code_address != -1 && has_else && !no_fixed ) {
       10:  974:			this->set_code_size( &info, 0 );
       10:  975:			this->next_code_address = current_next_code_address;
       10:  976:			info.is_updated = true;
        -:  977:		}
       64:  978:		p_last_line = p_last_line_backup;
        -:  979:	}
        -:  980:	//	実際に条件分岐を判断する
       92:  981:	result = true;
       92:  982:	do_process = false;
      128:  983:	for( auto i : p_if->m_sub ) {
      125:  984:		if( i->p_if->words[0] == "ELSE" ) {
        -:  985:			//	ELSE なら 常に条件は true
       15:  986:			v.type = v.CV_INTEGER;
       15:  987:			v.i = 1;
        -:  988:		}
        -:  989:		else {
        -:  990:			//	IF 又は ELSEIF なら、条件式を評価
      110:  991:			index = i->p_if->expression( info, 1, v );
      110:  992:			if( index != 0 && index < (int)i->p_if->words.size() ) {
       12:  993:				i->p_if->put_error( "Illegal expression." );
       62:  994:				return false;
        -:  995:			}
        -:  996:		}
      113:  997:		if( v.type != v.CV_INTEGER ) {
        7:  998:			put_error( "Illegal condition." );
        7:  999:			return false;
        -: 1000:		}
      106: 1001:		i->is_condition_fixed = true;
      106: 1002:		if( !v.i ) {
       36: 1003:			continue;
        -: 1004:		}
       70: 1005:		i->is_condition = true;
       70: 1006:		p_last_line = i->p_text->process( info, sub_success_count, p_last_line, !is_analyze_phase );
       70: 1007:		if( sub_success_count != i->p_text->m_text.size() ) {
       31: 1008:			return false;
        -: 1009:		}
       39: 1010:		p_selected_if = i->p_if;
       39: 1011:		do_process = true;
       39: 1012:		break;
        -: 1013:	}
       42: 1014:	if( !this->is_data_fixed ) {
       14: 1015:		this->is_data_fixed = true;
       14: 1016:		info.is_updated = true;
        -: 1017:	}
       42: 1018:	if( this->next_code_address == -1 && p_last_line->get_next_code_address() != -1 ) {
        3: 1019:		this->next_code_address = p_last_line->get_next_code_address();
        3: 1020:		info.is_updated = true;
        -: 1021:	}
        -: 1022:
       42: 1023:	if( !is_analyze_phase ) {
       14: 1024:		log.push_back( "[" + get_line() + "]" );
       14: 1025:		if( do_process ) {
       13: 1026:			log.push_back( "\tSelected {" + p_selected_if->get_line() + "} block." );
        -: 1027:		}
        -: 1028:		else {
        1: 1029:			log.push_back( "\tAll condition is not selected." );
        -: 1030:		}
       14: 1031:		log.push_back( "" );
        -: 1032:	}
       42: 1033:	return check_all_fixed();
        -: 1034:}
        -: 1035:
        -: 1036:// --------------------------------------------------------------------
       33: 1037:bool CZMA_PARSE_ENDIF::write( CZMA_INFORMATION& info, std::ofstream* f ) {
        -: 1038:	bool result;
       66: 1039:	CVALUE v;
        -: 1040:
       33: 1041:	if( p_if == nullptr ) {
        3: 1042:		return false;
        -: 1043:	}
       30: 1044:	result = true;
       56: 1045:	for( auto i : p_if->m_sub ) {
       48: 1046:		if( !i->is_condition_fixed || !i->is_condition ) {
       26: 1047:			continue;
        -: 1048:		}
       22: 1049:		result = i->p_text->write( info, f );
       22: 1050:		break;
        -: 1051:	}
       75: 1052:	for( auto line : log ) {
       45: 1053:		info.log << line << std::endl;
        -: 1054:	}
       30: 1055:	info.log << std::endl;
       30: 1056:	return result;
        -: 1057:}
        -: 1058:
        -: 1059:// --------------------------------------------------------------------
       72: 1060:bool CZMA_PARSE_ENDR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1061:	CZMA_TEXT* p_text;
        -: 1062:	int i;
        -: 1063:	unsigned int sub_success_count;
        -: 1064:
       72: 1065:	update_flags( &info, p_last_line );
       72: 1066:	if( !this->is_loaded ) {
       32: 1067:		p_repeat = info.p_repeat;
       32: 1068:		if( p_repeat == nullptr ) {
        9: 1069:			put_error( "Illegal ENDR." );
        9: 1070:			return false;
        -: 1071:		}
       23: 1072:		if( !p_repeat->is_counter_end_fixed ) {
        8: 1073:			put_error( "REPEAT counter is not fixed." );
        8: 1074:			return false;
        -: 1075:		}
      125: 1076:		for( i = 0; i < p_repeat->counter_end; i++ ) {
      110: 1077:			info.dict[p_repeat->counter_symbol].i = i;
      110: 1078:			p_text = new CZMA_TEXT;
      240: 1079:			for( auto ins_p : p_repeat->m_text ) {
      130: 1080:				p_text->m_text.push_back( CZMA_PARSE::create( info, ins_p->words, ins_p->get_file_name(), ins_p->get_line_no() ) );
        -: 1081:			}
      110: 1082:			this->text_list.push_back( p_text );
        -: 1083:		}
       15: 1084:		this->is_loaded = true;
       15: 1085:		info.is_updated = true;
        -: 1086:	}
       55: 1087:	info.is_block_processing = false;
      470: 1088:	for( i = 0; i < p_repeat->counter_end; i++ ) {
      415: 1089:		info.dict[p_repeat->counter_symbol].i = i;
      415: 1090:		p_last_line = this->text_list[i]->process( info, sub_success_count, p_last_line, !is_analyze_phase );
        -: 1091:	}
       55: 1092:	if( !this->is_data_fixed ) {
      470: 1093:		for( auto p_text : this->text_list ) {
      875: 1094:			for( auto p : p_text->m_text ) {
      460: 1095:				this->is_data_fixed = this->is_data_fixed && p->get_fixed_code_size();
        -: 1096:			}
        -: 1097:		}
       55: 1098:		if( this->is_data_fixed ) {
    #####: 1099:			info.is_updated = true;
        -: 1100:		}
        -: 1101:	}
       55: 1102:	if( this->code_size == -1 ) {
       15: 1103:		this->code_size = 0;
      125: 1104:		for( auto p_text : this->text_list ) {
      235: 1105:			for( auto p : p_text->m_text ) {
      125: 1106:				if( this->code_size != -1 && p->get_fixed_code_size() ) {
      125: 1107:					this->code_size = this->code_size + p->get_code_size();
        -: 1108:				}
        -: 1109:				else {
    #####: 1110:					this->code_size = -1;
        -: 1111:				}
        -: 1112:			}
        -: 1113:		}
       15: 1114:		if( this->code_size != -1 ) {
       15: 1115:			info.is_updated = true;
        -: 1116:		}
        -: 1117:	}
       55: 1118:	if( info.scope.size() == 0 ) {
        1: 1119:		put_error( "Scope of ENDR does not exist." );
        1: 1120:		return false;
        -: 1121:	}
       54: 1122:	if( info.scope[info.scope.size() - 1] != p_repeat->scope_name ) {
        4: 1123:		put_error( "Scope of ENDR does not exist." );
        4: 1124:		return false;
        -: 1125:	}
       50: 1126:	info.scope.pop_back();
        -: 1127:
       50: 1128:	if( words.size() != 1 ) {
        2: 1129:		put_error( "ENDR is not need parameters." );
        2: 1130:		return false;
        -: 1131:	}
        -: 1132:	//	log
       48: 1133:	if( !is_analyze_phase ) {
       12: 1134:		log.push_back( "\tScope path: " + info.get_scope_path() );
       12: 1135:		log.push_back( "" );
        -: 1136:	}
       48: 1137:	return check_all_fixed();
        -: 1138:}
        -: 1139:
        -: 1140:// --------------------------------------------------------------------
      338: 1141:bool CZMA_PARSE_MACRO_INS::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1142:	CZMA_MACRO* p_macro;
      676: 1143:	std::map< std::string, std::vector< std::string > > argument;
      676: 1144:	std::vector< std::string > parameter, insert_line;
      676: 1145:	std::string replace_name, arg_name;
        -: 1146:	int i, j, id;
        -: 1147:	unsigned int success_count;
      338: 1148:	bool result = true;
      338: 1149:	update_flags( &info, p_last_line );
      338: 1150:	if( !this->is_loaded ) {
       98: 1151:		p_macro = info.macro_list[words[0]];	//	※必ず存在する
        -: 1152:		//	引数を取り込む
       98: 1153:		id = 0;
      133: 1154:		for( i = 1; i < (int)words.size(); i++ ) {
       38: 1155:			parameter.clear();
       38: 1156:			if( id >= (int)p_macro->parameter_name_list.size() ) {
        3: 1157:				put_error( "Too many arguments for " + words[0] + "." );
        3: 1158:				return false;
        -: 1159:			}
       35: 1160:			if( p_macro->parameter_name_list[id].is_through ) {
        3: 1161:				arg_name = "\"";
       10: 1162:				for( j = i; j < ( int) words.size() && words[j] != ","; j++ ) {
        7: 1163:					arg_name = arg_name + words[j];
        7: 1164:					if( (j + 1) < ( int) words.size() && words[j + 1] != "," ) {
        4: 1165:						arg_name = arg_name + " ";
        -: 1166:					}
        -: 1167:				}
        3: 1168:				parameter.push_back( arg_name );
        -: 1169:			}
        -: 1170:			else {
       68: 1171:				for( j = i; j < ( int) words.size() && words[j] != ","; j++ ) {
       36: 1172:					parameter.push_back( words[j] );
        -: 1173:				}
        -: 1174:			}
       35: 1175:			argument[p_macro->parameter_name_list[id].name] = parameter;		//	argument[ 引数名 ] = 実際の引数
       35: 1176:			i = j;
       35: 1177:			id++;
        -: 1178:		}
       95: 1179:		if( id != (int)p_macro->parameter_name_list.size() ) {
        3: 1180:			put_error( "Mismatched number of arguments." );
        3: 1181:			return false;
        -: 1182:		}
        -: 1183:		//	m_text に macro の展開内容をコピーする
      722: 1184:		for( auto p : p_macro->m_text ) {
      630: 1185:			insert_line = p->words;
     2018: 1186:			for( auto word = insert_line.begin(); word != insert_line.end(); ) {
     1388: 1187:				replace_name = *word;
     1388: 1188:				if( argument.count( replace_name ) ) {
        -: 1189:					//	マクロの仮引数を見つけた場合、指定されている式に置き換える
       32: 1190:					word = insert_line.erase( word );
       68: 1191:					for( auto insert_word : argument[replace_name] ) {
       36: 1192:						word = insert_line.insert( word, insert_word );
       36: 1193:						++word;
        -: 1194:					}
        -: 1195:				}
        -: 1196:				else {
     1356: 1197:					++word;
        -: 1198:				}
        -: 1199:			}
      630: 1200:			text.m_text.push_back( CZMA_PARSE::create( info, insert_line, this->p_file_name, this->line_no ) );
        -: 1201:		}
       92: 1202:		this->is_loaded = true;
       92: 1203:		info.is_updated = true;
        -: 1204:	}
      332: 1205:	info.scope.push_back( "@MACRO" + std::to_string( info.get_auto_label_index() ) );
        -: 1206:	//	log
      332: 1207:	if( !is_analyze_phase ) {
       92: 1208:		log.push_back( "((" + get_line() + "))" );
       92: 1209:		log.push_back( "\tScope path: " + info.get_scope_path() );
        -: 1210:	}
      332: 1211:	p_last_line = text.process( info, success_count, p_last_line, !this->is_analyze_phase );
      332: 1212:	if( !this->is_data_fixed ) {
     2778: 1213:		for( auto p : text.m_text ) {
     2446: 1214:			this->is_data_fixed = this->is_data_fixed && p->get_fixed_code_size();
        -: 1215:		}
      332: 1216:		if( this->is_data_fixed ) {
    #####: 1217:			info.is_updated = true;
        -: 1218:		}
        -: 1219:	}
      332: 1220:	if( this->code_size == -1 ) {
       97: 1221:		this->code_size = 0;
      724: 1222:		for( auto p : text.m_text ) {
      627: 1223:			if( this->code_size != -1 && p->get_fixed_code_size() ) {
      619: 1224:				this->code_size = this->code_size + p->get_code_size();
        -: 1225:			}
        -: 1226:			else {
        8: 1227:				this->code_size = -1;
        -: 1228:			}
        -: 1229:		}
       97: 1230:		if( this->code_size != -1 ) {
       89: 1231:			info.is_updated = true;
        -: 1232:		}
        -: 1233:	}
      332: 1234:	if( info.scope.size() > 0 ) {
      332: 1235:		info.scope.pop_back();
        -: 1236:	}
      332: 1237:	this->next_code_address = p_last_line->get_next_code_address();
      332: 1238:	return result && check_all_fixed();
        -: 1239:}
        -: 1240:
        -: 1241:// --------------------------------------------------------------------
       93: 1242:bool CZMA_PARSE_LABEL::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
      186: 1243:	std::string label;
      186: 1244:	CVALUE v;
        -: 1245:
       93: 1246:	update_flags( &info, p_last_line );
        -: 1247:	//	log
       93: 1248:	if( !this->is_analyze_phase ) {
       58: 1249:		std::stringstream s;
       29: 1250:		s << "0x" << std::hex << std::setw( 6 ) << std::setfill( '0' ) << this->get_code_address();
       29: 1251:		log.push_back( "[" + get_line() + "]" );
       29: 1252:		log.push_back( "\tlabel address: " + s.str() );
       29: 1253:		log.push_back( "" );
        -: 1254:	}
       93: 1255:	if( this->is_data_fixed ) {
       52: 1256:		return check_all_fixed();
        -: 1257:	}
       41: 1258:	this->set_code_size( &info, 0 );
       41: 1259:	update_flags( &info, p_last_line );
       41: 1260:	if( words[0][0] == '\"' ) {
        3: 1261:		put_error( "Label name cannot be string." );
        3: 1262:		return false;
        -: 1263:	}
       38: 1264:	if( this->get_fixed_code_address() ) {
       27: 1265:		label = info.get_scope_path() + words[0];
       27: 1266:		if( info.dict.count( label ) ) {
        3: 1267:			put_error( std::string("There are declarations of the same label '") + label + "' in multiple places." );
        3: 1268:			return false;
        -: 1269:		}
        -: 1270:		else {
       24: 1271:			this->is_data_fixed = true;
       24: 1272:			v.type = CVALUE::CV_INTEGER;
       24: 1273:			v.i = this->get_code_address();
       24: 1274:			info.dict[label] = v;
       24: 1275:			info.is_updated = true;
        -: 1276:		}
        -: 1277:	}
        -: 1278:	else {
       11: 1279:		put_error( std::string( "Label '" ) + words[0] + "' is indeterminate." );
       11: 1280:		return false;
        -: 1281:	}
       24: 1282:	return check_all_fixed();
        -: 1283:}
        -: 1284:
        -: 1285:// --------------------------------------------------------------------
       18: 1286:bool CZMA_PARSE_GLOBAL_LABEL::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
       36: 1287:	std::string label;
       36: 1288:	CVALUE v;
        -: 1289:
       18: 1290:	update_flags( &info, p_last_line );
        -: 1291:	//	log
       18: 1292:	if( !this->is_analyze_phase ) {
       12: 1293:		std::stringstream s;
        6: 1294:		s << "0x" << std::hex << std::setw( 6 ) << std::setfill( '0' ) << this->get_code_address();
        6: 1295:		log.push_back( "[" + get_line() + "]" );
        6: 1296:		log.push_back( "\tglobal label address: " + s.str() );
        6: 1297:		log.push_back( "" );
        -: 1298:	}
       18: 1299:	if( this->is_data_fixed ) {
        6: 1300:		return check_all_fixed();
        -: 1301:	}
       12: 1302:	this->set_code_size( &info, 0 );
       12: 1303:	if( words[0][0] == '\"' ) {
        3: 1304:		put_error( "Label name cannot be string." );
        3: 1305:		return false;
        -: 1306:	}
        9: 1307:	if( this->get_fixed_code_address() ) {
        6: 1308:		label = words[0];
        6: 1309:		if( info.dict.count( label ) ) {
        3: 1310:			put_error( std::string( "There are declarations of the same label '" ) + label + "' in multiple places." );
        3: 1311:			return false;
        -: 1312:		}
        -: 1313:		else {
        3: 1314:			this->is_data_fixed = true;
        3: 1315:			v.type = CVALUE::CV_INTEGER;
        3: 1316:			v.i = this->get_code_address();
        3: 1317:			info.dict[label] = v;
        3: 1318:			info.is_updated = true;
        -: 1319:		}
        -: 1320:	}
        -: 1321:	else {
        3: 1322:		put_error( std::string( "Label '" ) + words[0] + "' is indeterminate." );
        3: 1323:		return false;
        -: 1324:	}
        3: 1325:	return check_all_fixed();
        -: 1326:}
        -: 1327:
        -: 1328:// --------------------------------------------------------------------
       36: 1329:bool CZMA_PARSE_SYMBOL::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
       72: 1330:	std::string label;
       72: 1331:	CVALUE v;
        -: 1332:
       36: 1333:	update_flags( &info, p_last_line );
       36: 1334:	if( this->is_data_fixed ) {
       12: 1335:		return check_all_fixed();
        -: 1336:	}
       24: 1337:	this->set_code_size( &info, 0 );
       24: 1338:	if( words[0][0] == '\"' ) {
        3: 1339:		put_error( "Label name cannot be string." );
        3: 1340:		return false;
        -: 1341:	}
       21: 1342:	if( this->expression( info, 2, v ) ) {
       18: 1343:		if( v.type == CVALUE::CV_UNKNOWN ) {
        6: 1344:			put_error( "Illegal expression." );
        6: 1345:			return false;
        -: 1346:		}
       12: 1347:		label = info.get_scope_path() + words[0];
       12: 1348:		if( info.dict.count( label ) ) {
        6: 1349:			put_error( std::string( "There are declarations of the same label '" ) + label + "' in multiple places." );
        6: 1350:			return false;
        -: 1351:		}
        -: 1352:		else {
        6: 1353:			this->is_data_fixed = true;
        6: 1354:			info.dict[label] = v;
        6: 1355:			info.is_updated = true;
        -: 1356:		}
        -: 1357:	}
        -: 1358:	else {
        3: 1359:		put_error( std::string( "Label '" ) + words[0] + "' is indeterminate." );
        3: 1360:		return false;
        -: 1361:	}
        6: 1362:	return check_all_fixed();
        -: 1363:}
        -: 1364:
        -: 1365:// --------------------------------------------------------------------
       24: 1366:bool CZMA_PARSE_GLOBAL_SYMBOL::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
       48: 1367:	std::string label;
       48: 1368:	CVALUE v;
        -: 1369:
       24: 1370:	update_flags( &info, p_last_line );
       24: 1371:	if( this->is_data_fixed ) {
        4: 1372:		return check_all_fixed();
        -: 1373:	}
       20: 1374:	this->set_code_size( &info, 0 );
       20: 1375:	if( words[0][0] == '\"' ) {
        3: 1376:		put_error( "Label name cannot be string." );
        3: 1377:		return false;
        -: 1378:	}
       17: 1379:	if( this->expression( info, 2, v ) ) {
       14: 1380:		if( v.type != CVALUE::CV_INTEGER ) {
        6: 1381:			put_error( "Illegal expression." );
        6: 1382:			return false;
        -: 1383:		}
        8: 1384:		label = words[0];
        8: 1385:		if( info.dict.count( label ) ) {
        6: 1386:			put_error( std::string( "There are declarations of the same label '" ) + label + "' in multiple places." );
        6: 1387:			return false;
        -: 1388:		}
        -: 1389:		else {
        2: 1390:			this->is_data_fixed = true;
        2: 1391:			info.dict[label] = v;
        2: 1392:			info.is_updated = true;
        -: 1393:		}
        -: 1394:	}
        -: 1395:	else {
        3: 1396:		put_error( std::string( "Label '" ) + words[0] + "' is indeterminate." );
        3: 1397:		return false;
        -: 1398:	}
        2: 1399:	return check_all_fixed();
        -: 1400:}
        -: 1401:
        -: 1402:// --------------------------------------------------------------------
       70: 1403:bool CZMA_PARSE_ORG::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
      140: 1404:	CVALUE address;
        -: 1405:	int index;
        -: 1406:
       70: 1407:	update_flags( &info, p_last_line );
       70: 1408:	index = this->expression( info, 1, address );
       70: 1409:	this->code_size = 0;
       70: 1410:	if( index == 0 ) {
        8: 1411:		put_error( "Illegal expression." );
        8: 1412:		return false;
        -: 1413:	}
       62: 1414:	if( address.type != CVALUE::CV_INTEGER ) {
        4: 1415:		put_error( "Illegal parameter." );
        4: 1416:		return false;
        -: 1417:	}
       58: 1418:	if( index < (int)words.size() ) {
        4: 1419:		put_error( "Illegal parameter." );
        4: 1420:		return false;
        -: 1421:	}
       54: 1422:	this->is_data_fixed = true;
       54: 1423:	this->code_address = address.i;
       54: 1424:	this->next_code_address = address.i;
        -: 1425:	//	log
       54: 1426:	if( !this->is_analyze_phase ) {
       34: 1427:		std::stringstream s;
       17: 1428:		s << "0x" << std::hex << std::setw( 6 ) << std::setfill( '0' ) << this->get_code_address();
       17: 1429:		log.push_back( "[\t" + get_line() + "]" );
       17: 1430:		log.push_back( "\tcode address: " + s.str() );
       17: 1431:		log.push_back( "" );
        -: 1432:	}
       54: 1433:	return check_all_fixed();
        -: 1434:}
        -: 1435:
        -: 1436:// --------------------------------------------------------------------
        3: 1437:bool CZMA_PARSE_BINARY_LINK::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1438:	int i, count;
        -: 1439:	unsigned char d;
        6: 1440:	CVALUE path;
        -: 1441:
        3: 1442:	update_flags( &info, p_last_line );
        3: 1443:	if( words.size() < 2 ){
    #####: 1444:		put_error( "Must be set include file name." );
    #####: 1445:		return false;
        -: 1446:	}
        3: 1447:	i = this->expression( info, 1, path );
        3: 1448:	if( i == 0 ){
    #####: 1449:		put_error( "Invalid expression." );
    #####: 1450:		return false;
        -: 1451:	}
        3: 1452:	if( path.type != CVALUE::CV_STRING ){
    #####: 1453:		put_error( "Invalid parameter." );
    #####: 1454:		return false;
        -: 1455:	}
        3: 1456:	if( i < (int)words.size() ){
    #####: 1457:		put_error( "BINARY_LINK command has only one parameter." );
    #####: 1458:		return false;
        -: 1459:	}
        3: 1460:	if( !this->get_fixed_code_size() ) {
        2: 1461:		std::ifstream file;
        1: 1462:		file.open( path.s, std::ios::binary );
        1: 1463:		if( !file ){
    #####: 1464:			put_error( "BINARY_LINK command has only one parameter." );
    #####: 1465:			return false;
        -: 1466:		}
        1: 1467:		file.seekg( 0, std::ifstream::end );
        1: 1468:		count = static_cast<int>( file.tellg() );
        1: 1469:		file.seekg( 0, std::ifstream::beg );
        1: 1470:		this->set_code_size( &info, count );
        -: 1471:
       11: 1472:		for( i = 0; i < count; i++ ){
       10: 1473:			file.read( (char*) &d, 1 );
       10: 1474:			data.push_back( d );
        -: 1475:		}
        1: 1476:		this->is_data_fixed = true;
        -: 1477:	}
        -: 1478:	//	log
        3: 1479:	if( !this->is_analyze_phase ) {
        1: 1480:		log.push_back( "[\t" + get_line() + "]" );
        1: 1481:		this->log_data_dump();
        1: 1482:		log.push_back( "" );
        -: 1483:	}
        3: 1484:	return check_all_fixed();
        -: 1485:}
        -: 1486:
        -: 1487:// --------------------------------------------------------------------
     3777: 1488:bool CZMA_PARSE_DEFB::process( CZMA_INFORMATION &info, CZMA_PARSE *p_last_line ){
        -: 1489:	int i, count;
     7554: 1490:	CVALUE v;
        -: 1491:
     3777: 1492:	update_flags( &info, p_last_line );
     3777: 1493:	if( !this->get_fixed_code_size() ){
     1205: 1494:		count = 1;
     8352: 1495:		for( i = 1; i < (int)words.size(); i++ ){
     7147: 1496:			if( words[ i ] == "," ){
     2961: 1497:				count++;
        -: 1498:			}
        -: 1499:		}
     1205: 1500:		this->set_code_size( &info, count );
        -: 1501:	}
     3777: 1502:	if( !this->is_data_fixed ){
     1242: 1503:		i = 1;
     5404: 1504:		for( count = 0; count < this->get_code_size(); count++ ){
     4207: 1505:			i = this->expression( info, i, v );
     4207: 1506:			if( i == 0 ){
       39: 1507:				put_error( std::string( "Cannot evaluate the expression(" ) + std::to_string( count + 1 ) + ")" );
       39: 1508:				data.clear();
       39: 1509:				return false;
        -: 1510:			}
     4168: 1511:			if( v.type != CVALUE::CV_INTEGER ){
        3: 1512:				put_error( "Illegal expression." );
        3: 1513:				return false;
        -: 1514:			}
     4165: 1515:			if( i < (int)words.size() && words[ i ] != "," ){
        3: 1516:				put_error( std::string( "Illegal expression." ) );
        3: 1517:				data.clear();
        3: 1518:				return false;
        -: 1519:			}
     4162: 1520:			i++;
     4162: 1521:			data.push_back( v.i & 255 );
        -: 1522:		}
     1197: 1523:		this->is_data_fixed = true;
        -: 1524:	}
        -: 1525:	//	log
     3732: 1526:	if( !this->is_analyze_phase ){
     1184: 1527:		log.push_back( "[\t" + get_line() + "]" );
     1184: 1528:		this->log_data_dump();
     1184: 1529:		log.push_back( "" );
        -: 1530:	}
     3732: 1531:	return check_all_fixed();
        -: 1532:}
        -: 1533:
        -: 1534:// --------------------------------------------------------------------
     1828: 1535:bool CZMA_PARSE_DEFW::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1536:	int i, count;
     3656: 1537:	CVALUE v;
        -: 1538:
     1828: 1539:	update_flags( &info, p_last_line );
     1828: 1540:	if( !this->get_fixed_code_size() ) {
      459: 1541:		count = 1;
      956: 1542:		for( i = 1; i < ( int) words.size(); i++ ) {
      497: 1543:			if( words[i] == "," ) {
       19: 1544:				count++;
        -: 1545:			}
        -: 1546:		}
      459: 1547:		this->set_code_size( &info, count * 2 );
        -: 1548:	}
     1828: 1549:	if( !this->is_data_fixed ) {
      472: 1550:		i = 1;
      952: 1551:		for( count = 0; (count * 2) < this->get_code_size(); count++ ) {
      498: 1552:			i = this->expression( info, i, v );
      498: 1553:			if( i == 0 ) {
       12: 1554:				put_error( std::string( "Cannot evaluate the expression(" ) + std::to_string( count + 1 ) + ")" );
       12: 1555:				data.clear();
       12: 1556:				return false;
        -: 1557:			}
      486: 1558:			if( v.type != CVALUE::CV_INTEGER ) {
        3: 1559:				put_error( "Illegal expression." );
        3: 1560:				return false;
        -: 1561:			}
      483: 1562:			if( i < ( int) words.size() && words[i] != "," ) {
        3: 1563:				put_error( std::string( "Illegal expression." ) );
        3: 1564:				data.clear();
        3: 1565:				return false;
        -: 1566:			}
      480: 1567:			i++;
      480: 1568:			data.push_back( v.i & 255 );
      480: 1569:			data.push_back( (v.i >> 8) & 255 );
        -: 1570:		}
      454: 1571:		this->is_data_fixed = true;
        -: 1572:	}
        -: 1573:	//	log
     1810: 1574:	if( !this->is_analyze_phase ) {
      454: 1575:		log.push_back( "[\t" + get_line() + "]" );
      454: 1576:		this->log_data_dump();
      454: 1577:		log.push_back( "" );
        -: 1578:	}
     1810: 1579:	return check_all_fixed();
        -: 1580:}
        -: 1581:
        -: 1582:// --------------------------------------------------------------------
       24: 1583:bool CZMA_PARSE_DEFD::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1584:	int i, count;
       48: 1585:	CVALUE v;
        -: 1586:
       24: 1587:	update_flags( &info, p_last_line );
       24: 1588:	if( !this->get_fixed_code_size() ) {
        8: 1589:		count = 1;
       54: 1590:		for( i = 1; i < ( int) words.size(); i++ ) {
       46: 1591:			if( words[i] == "," ) {
       19: 1592:				count++;
        -: 1593:			}
        -: 1594:		}
        8: 1595:		this->set_code_size( &info, count * 4 );
        -: 1596:	}
       24: 1597:	if( !this->is_data_fixed ) {
       19: 1598:		i = 1;
       48: 1599:		for( count = 0; (count * 4) < this->get_code_size(); count++ ) {
       45: 1600:			i = this->expression( info, i, v );
       45: 1601:			if( i == 0 ) {
       10: 1602:				put_error( std::string( "Cannot evaluate the expression(" ) + std::to_string( count + 1 ) + ")" );
       10: 1603:				data.clear();
       10: 1604:				return false;
        -: 1605:			}
       35: 1606:			if( v.type != CVALUE::CV_INTEGER ) {
        3: 1607:				put_error( "Illegal expression." );
        3: 1608:				return false;
        -: 1609:			}
       32: 1610:			if( i < ( int) words.size() && words[i] != "," ) {
        3: 1611:				put_error( std::string( "Illegal expression." ) );
        3: 1612:				data.clear();
        3: 1613:				return false;
        -: 1614:			}
       29: 1615:			i++;
       29: 1616:			data.push_back( v.i & 255 );
       29: 1617:			data.push_back( (v.i >> 8) & 255 );
       29: 1618:			data.push_back( (v.i >> 16) & 255 );
       29: 1619:			data.push_back( (v.i >> 24) & 255 );
        -: 1620:		}
        3: 1621:		this->is_data_fixed = true;
        -: 1622:	}
        -: 1623:	//	log
        8: 1624:	if( !this->is_analyze_phase ) {
        3: 1625:		log.push_back( "[\t" + get_line() + "]" );
        3: 1626:		this->log_data_dump();
        3: 1627:		log.push_back( "" );
        -: 1628:	}
        8: 1629:	return check_all_fixed();
        -: 1630:}
        -: 1631:
        -: 1632:// --------------------------------------------------------------------
       64: 1633:bool CZMA_PARSE_DEFS::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
      128: 1634:	CVALUE v;
        -: 1635:	int index;
        -: 1636:
       64: 1637:	update_flags( &info, p_last_line );
       64: 1638:	index = this->expression( info, 1, v );
       64: 1639:	if( index == 0 ) {
       12: 1640:		put_error( "Illegal expression." );
       12: 1641:		return false;
        -: 1642:	}
       52: 1643:	if( index < ( int) words.size() ) {
        3: 1644:		put_error( "Illegal parameter." );
        3: 1645:		return false;
        -: 1646:	}
       49: 1647:	if( v.type == CVALUE::CV_INTEGER ) {
        3: 1648:		v.type = CVALUE::CV_STRING;
        3: 1649:		v.s = std::to_string( v.i );
        -: 1650:	}
       49: 1651:	this->set_code_size( &info, v.s.size() );
       49: 1652:	if( !this->is_data_fixed ) {
    16502: 1653:		for( auto c : v.s ) {
    16486: 1654:			data.push_back( c );
        -: 1655:		}
       16: 1656:		this->is_data_fixed = true;
        -: 1657:	}
        -: 1658:	//	log
       49: 1659:	if( !this->is_analyze_phase ) {
       16: 1660:		log.push_back( "[\t" + get_line() + "]" );
       16: 1661:		this->log_data_dump();
       16: 1662:		log.push_back( "" );
        -: 1663:	}
       49: 1664:	return check_all_fixed();
        -: 1665:}
        -: 1666:
        -: 1667:// --------------------------------------------------------------------
       58: 1668:bool CZMA_PARSE_INCLUDE::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
      116: 1669:	std::string s;
        -: 1670:	int i;
        -: 1671:	unsigned int success_count;
      116: 1672:	CVALUE path;
      116: 1673:	std::ifstream f;
        -: 1674:	bool is_open;
        -: 1675:
       58: 1676:	update_flags( &info, p_last_line );
       58: 1677:	if( words.size() < 2 ) {
        3: 1678:		put_error( "Must be set include file name." );
        3: 1679:		return false;
        -: 1680:	}
       55: 1681:	i = this->expression( info, 1, path );
       55: 1682:	if( i == 0 ) {
        3: 1683:		put_error( "Invalid expression." );
        3: 1684:		return false;
        -: 1685:	}
       52: 1686:	if( path.type != CVALUE::CV_STRING ) {
        3: 1687:		put_error( "Invalid parameter." );
        3: 1688:		return false;
        -: 1689:	}
       49: 1690:	if( i < (int)words.size() ) {
        3: 1691:		put_error( "INCLUDE command has only one parameter." );
        3: 1692:		return false;
        -: 1693:	}
       46: 1694:	if( !this->is_loaded ) {
       16: 1695:		is_open = false;
       27: 1696:		for( auto include_path : info.include_path ) {
       24: 1697:			s = include_path + "/" + path.s;
       24: 1698:			f.open( s.c_str() );
       24: 1699:			if( f ) {
       13: 1700:				f.close();
       13: 1701:				this->s_file_name = s;
       13: 1702:				if( this->text.load( info, this->s_file_name.c_str() ) ) {
       13: 1703:					this->is_loaded = true;
       13: 1704:					is_open = true;
       13: 1705:					break;
        -: 1706:				}
        -: 1707:			}
        -: 1708:		}
       16: 1709:		if( !is_open ) {
        3: 1710:			put_error( std::string( "Cannot open include file '" ) + path.s + "'." );
        3: 1711:			return false;
        -: 1712:		}
       13: 1713:		info.is_updated = true;
        -: 1714:	}
        -: 1715:	//	log
       43: 1716:	if( !this->is_analyze_phase ) {
       13: 1717:		log.push_back( "[\tINCLUDE \"" + this->s_file_name + "\"]" );
        -: 1718:	}
       43: 1719:	if( p_last_line->get_fixed_file_address() && p_last_line->get_fixed_code_size() ) {
       16: 1720:		this->file_address = p_last_line->get_file_address() + p_last_line->get_code_size();
        -: 1721:	}
       43: 1722:	p_last_line = this->text.process( info, success_count, p_last_line, !this->is_analyze_phase );
       43: 1723:	if( p_last_line->get_fixed_next_code_address() ) {
       36: 1724:		this->next_code_address = p_last_line->get_next_code_address();
        -: 1725:	}
       43: 1726:	if( !this->is_data_fixed ) {
      275: 1727:		for( auto p : text.m_text ) {
      232: 1728:			this->is_data_fixed = this->is_data_fixed && p->check_data_fixed();
        -: 1729:		}
       43: 1730:		if( this->is_data_fixed ) {
    #####: 1731:			info.is_updated = true;
        -: 1732:		}
        -: 1733:	}
       43: 1734:	if( this->code_size == -1 ) {
      275: 1735:		for( auto p : text.m_text ) {
      232: 1736:			if( this->code_size != -1 && p->get_fixed_code_size() ) {
    #####: 1737:				this->code_size = this->code_size + p->get_code_size();
        -: 1738:			}
        -: 1739:			else {
      232: 1740:				this->code_size = -1;
        -: 1741:			}
        -: 1742:		}
       43: 1743:		if( this->code_size != -1 ) {
    #####: 1744:			info.is_updated = true;
        -: 1745:		}
        -: 1746:	}
       43: 1747:	if( success_count < this->text.m_text.size() ) {
       32: 1748:		return false;
        -: 1749:	}
       11: 1750:	return check_all_fixed();
        -: 1751:}
        -: 1752:
        -: 1753:// --------------------------------------------------------------------
       63: 1754:bool CZMA_PARSE_SCOPE::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1755:
       63: 1756:	update_flags( &info, p_last_line );
       63: 1757:	if( words.size() < 2 ) {
        3: 1758:		put_error( "Must be set scope name." );
        3: 1759:		return false;
        -: 1760:	}
       60: 1761:	if( words.size() > 2 ) {
        3: 1762:		put_error( "SCOPE command has only one parameter." );
        3: 1763:		return false;
        -: 1764:	}
       57: 1765:	this->is_data_fixed = true;
       57: 1766:	this->set_code_size( &info, 0 );
       57: 1767:	info.scope.push_back( words[1] );
        -: 1768:
        -: 1769:	//	log
       57: 1770:	if( !is_analyze_phase ) {
       17: 1771:		log.push_back( "[\t" + get_line() + "]" );
       17: 1772:		log.push_back( "\tScope path: " + info.get_scope_path() );
       17: 1773:		log.push_back( "" );
        -: 1774:	}
       57: 1775:	return check_all_fixed();
        -: 1776:}
        -: 1777:
        -: 1778:// --------------------------------------------------------------------
       43: 1779:bool CZMA_PARSE_ENDSCOPE::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
       86: 1780:	std::string s;
        -: 1781:
       43: 1782:	update_flags( &info, p_last_line );
       43: 1783:	if( words.size() > 1 ) {
        3: 1784:		put_error( "ENDSCOPE command has not parameter." );
        3: 1785:		return false;
        -: 1786:	}
       40: 1787:	this->is_data_fixed = true;
       40: 1788:	this->set_code_size( &info, 0 );
       40: 1789:	if( info.scope.size() < 1 ) {
        6: 1790:		put_error( "ENDSCOPE in wrong position." );
        6: 1791:		return false;
        -: 1792:	}
       34: 1793:	if( info.scope[ info.scope.size() - 1 ][0] == '@' ) {
        3: 1794:		put_error( "ENDSCOPE in wrong position." );
        3: 1795:		return false;
        -: 1796:	}
       31: 1797:	info.scope.pop_back();
        -: 1798:
        -: 1799:	//	log
       31: 1800:	if( !is_analyze_phase ) {
        9: 1801:		log.push_back( "[\t" + get_line() + "]" );
        9: 1802:		log.push_back( "\tScope path: " + info.get_scope_path() );
        9: 1803:		log.push_back( "" );
        -: 1804:	}
       31: 1805:	return check_all_fixed();
        -: 1806:}
        -: 1807:
        -: 1808:// --------------------------------------------------------------------
     1119: 1809:bool CZMA_PARSE_LD::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1810:
     1119: 1811:	update_flags( &info, p_last_line );
     1119: 1812:	if( opecode_a_i_r( info ) ) {						//	ld {A|I|R}, {A|I|R} line
        -: 1813:		//	log
       12: 1814:		if( !is_analyze_phase ) {
        4: 1815:			log.push_back( "[\t" + get_line() + "] Z80:11cyc, R800:2cyc" );			//	ld	{A|I|R}, {A|I|R}
        -: 1816:		}
        -: 1817:	}
     1107: 1818:	else if( opecode_ddd_sss( info, 0x40 ) ) {				//	ld <reg8>, <reg8> line
        -: 1819:		//	log
      314: 1820:		if( !is_analyze_phase ) {
      104: 1821:			if( this->code_size == 1 ) {
       56: 1822:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:2cyc" );		//	ld <reg8>, reg8>
        -: 1823:			}
        -: 1824:			else {
       48: 1825:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );		//	ld <reg8>, ixh
        -: 1826:			}
        -: 1827:		}
        -: 1828:	}
      793: 1829:	else if( opecode_ddd_ref_hl( info, 0x46 ) ) {			//	ld <reg8>, [HL] line
        -: 1830:		//	log
       72: 1831:		if( !is_analyze_phase ) {
       24: 1832:			if( this->code_size == 1 ) {
        8: 1833:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );		//	ld	<reg8>, [hl]
        -: 1834:			}
        -: 1835:			else {
       16: 1836:				log.push_back( "[\t" + get_line() + "] Z80:21cyc, R800:7cyc" );		//	ld	<reg8>, [ix+d]
        -: 1837:			}
        -: 1838:		}
        -: 1839:	}
      721: 1840:	else if( opecode_a_ref_bc( info, 0x0A ) ) {				//	ld a, [bc/de/nn] line
        -: 1841:		//	log
        9: 1842:		if( !is_analyze_phase ) {
        3: 1843:			if( this->code_size == 1 ) {
        2: 1844:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );		//	ld	a, [bc/de]
        -: 1845:			}
        -: 1846:			else {
        1: 1847:				log.push_back( "[\t" + get_line() + "] Z80:14cyc, R800:6cyc" );		//	ld	a, [nn]
        -: 1848:			}
        -: 1849:		}
        -: 1850:	}
      712: 1851:	else if( opecode_ddd_n( info, 0x06 ) ) {					//	ld <reg8>, imm8 line
        -: 1852:		//	log
       58: 1853:		if( !is_analyze_phase ) {
       19: 1854:			if( this->code_size == 2 ) {
       15: 1855:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:2cyc" );		//	ld	<reg8>, imm8
        -: 1856:			}
        -: 1857:			else {
        4: 1858:				log.push_back( "[\t" + get_line() + "] Z80:13cyc, R800:3cyc" );		//	ld	ixh, imm8
        -: 1859:			}
        -: 1860:		}
        -: 1861:	}
      654: 1862:	else if( opecode_sp_hl( info, 0xF9 ) ) {					//	ld sp, hl/ix/iy line
        -: 1863:		//	log
        9: 1864:		if( !is_analyze_phase ) {
        3: 1865:			if( this->code_size == 1 ) {
        1: 1866:				log.push_back( "[\t" + get_line() + "] Z80:7cyc, R800:1cyc" );		//	ld	sp, hl
        -: 1867:			}
        -: 1868:			else {
        2: 1869:				log.push_back( "[\t" + get_line() + "] Z80:12cyc, R800:2cyc" );		//	ld	sp, ix
        -: 1870:			}
        -: 1871:		}
        -: 1872:	}
      645: 1873:	else if( opecode_rp_nn( info, 0x01 ) ) {					//	ld <reg16>, imm16 line
        -: 1874:		//	log
      266: 1875:		if( !is_analyze_phase ) {
       89: 1876:			if( this->code_size == 3 ) {
       87: 1877:				log.push_back( "[\t" + get_line() + "] Z80:11cyc, R800:3cyc" );		//	ld	<reg16>, imm16
        -: 1878:			}
        -: 1879:			else {
        2: 1880:				log.push_back( "[\t" + get_line() + "] Z80:16cyc, R800:4cyc" );		//	ld	ix, imm16
        -: 1881:			}
        -: 1882:		}
        -: 1883:	}
      379: 1884:	else if( opecode_rp_ref_nn( info, 0x2A, 0x4B ) ) {		//	ld <reg16>, [nn] line
        -: 1885:		//	log
       24: 1886:		if( !is_analyze_phase ) {
        8: 1887:			if( this->code_size == 3 ) {
        3: 1888:				log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:7cyc" );		//	ld	hl, [nn]
        -: 1889:			}
        -: 1890:			else {
        5: 1891:				log.push_back( "[\t" + get_line() + "] Z80:22cyc, R800:8cyc" );		//	ld	de/bc/sp/ix/iy, [nn]
        -: 1892:			}
        -: 1893:		}
        -: 1894:	}
      355: 1895:	else if( opecode_ref_hl_sss( info, 0x70 ) ) {			//	ld [HL], <reg8> line
        -: 1896:		//	log
       66: 1897:		if( !is_analyze_phase ) {
       22: 1898:			log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );			//	ld [HL], <reg8>
        -: 1899:		}
        -: 1900:	}
      289: 1901:	else if( opecode_ref_hl_n( info, 0x36 ) ) {				//	ld [HL], imm8 line
        -: 1902:		//	log
        9: 1903:		if( !is_analyze_phase ) {
        3: 1904:			if( this->code_size == 2 ) {
        1: 1905:				log.push_back( "[\t" + get_line() + "] Z80:11cyc, R800:5cyc" );		//	ld [HL], imm8
        -: 1906:			}
        -: 1907:			else {
        2: 1908:				log.push_back( "[\t" + get_line() + "] Z80:21cyc, R800:7cyc" );		//	ld [IX+d], imm8
        -: 1909:			}
        -: 1910:		}
        -: 1911:	}
      280: 1912:	else if( opecode_ref_bc_a( info, 0x02 ) ) {				//	ld [bc/de/nn], a line
        -: 1913:		//	log
        9: 1914:		if( !is_analyze_phase ) {
        3: 1915:			if( this->code_size == 1 ) {
        2: 1916:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );		//	ld [bc/de], a
        -: 1917:			}
        -: 1918:			else {
        1: 1919:				log.push_back( "[\t" + get_line() + "] Z80:14cyc, R800:6cyc" );		//	ld [nn], a
        -: 1920:			}
        -: 1921:		}
        -: 1922:	}
      271: 1923:	else if( opecode_ref_nn_rp( info, 0xED, 0x22, 0x43 ) ) {	//	ld [nn], <reg16> line
        -: 1924:		//	log
       18: 1925:		if( !is_analyze_phase ) {
        6: 1926:			if( this->code_size == 3 ) {
        1: 1927:				log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:7cyc" );		//	ld [nn],hl
        -: 1928:			}
        -: 1929:			else {
        5: 1930:				log.push_back( "[\t" + get_line() + "] Z80:22cyc, R800:8cyc" );		//	ld [nn],bc/de/sp/ix/iy
        -: 1931:			}
        -: 1932:		}
        -: 1933:	}
        -: 1934:	else {
      253: 1935:		put_error( "Illegal operand." );
      253: 1936:		return false;
        -: 1937:	}
        -: 1938:	//	log
      866: 1939:	if( !is_analyze_phase ) {
      288: 1940:		log_data_dump();
      288: 1941:		log.push_back( "" );
        -: 1942:	}
      866: 1943:	return check_all_fixed();
        -: 1944:}
        -: 1945:
        -: 1946:// --------------------------------------------------------------------
        6: 1947:bool CZMA_PARSE_LDI::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1948:
        6: 1949:	update_flags( &info, p_last_line );
        6: 1950:	if( this->opecode( info, 0xED, 0xA0 ) ) {
        -: 1951:		//	log
        3: 1952:		if( !this->is_analyze_phase ) {
        1: 1953:			log.push_back( "[\t" + get_line() + "] Z80:18cyc, R800:7cyc" );
        1: 1954:			this->log_data_dump();
        1: 1955:			log.push_back( "" );
        -: 1956:		}
        3: 1957:		return check_all_fixed();
        -: 1958:	}
        3: 1959:	put_error( "Illegal operand" );
        3: 1960:	return false;
        -: 1961:}
        -: 1962:
        -: 1963:// --------------------------------------------------------------------
        6: 1964:bool CZMA_PARSE_LDIR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1965:
        6: 1966:	update_flags( &info, p_last_line );
        6: 1967:	if( this->opecode( info, 0xED, 0xB0 ) ) {
        -: 1968:		//	log
        3: 1969:		if( !this->is_analyze_phase ) {
        1: 1970:			log.push_back( "[\t" + get_line() + "] Z80:23cyc(BC!=0), 18cyc(BC=0), R800:?cyc(BC!=0), 7cyc(BC=0)" );
        1: 1971:			this->log_data_dump();
        1: 1972:			log.push_back( "" );
        -: 1973:		}
        3: 1974:		return check_all_fixed();
        -: 1975:	}
        3: 1976:	put_error( "Illegal operand" );
        3: 1977:	return false;
        -: 1978:}
        -: 1979:
        -: 1980:// --------------------------------------------------------------------
        6: 1981:bool CZMA_PARSE_LDD::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1982:
        6: 1983:	update_flags( &info, p_last_line );
        6: 1984:	if( this->opecode( info, 0xED, 0xA8 ) ) {
        -: 1985:		//	log
        3: 1986:		if( !this->is_analyze_phase ) {
        1: 1987:			log.push_back( "[\t" + get_line() + "] Z80:18cyc, R800:7cyc" );
        1: 1988:			this->log_data_dump();
        1: 1989:			log.push_back( "" );
        -: 1990:		}
        3: 1991:		return check_all_fixed();
        -: 1992:	}
        3: 1993:	put_error( "Illegal operand" );
        3: 1994:	return false;
        -: 1995:}
        -: 1996:
        -: 1997:// --------------------------------------------------------------------
        6: 1998:bool CZMA_PARSE_LDDR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 1999:
        6: 2000:	update_flags( &info, p_last_line );
        6: 2001:	if( this->opecode( info, 0xED, 0xB8 ) ) {
        -: 2002:		//	log
        3: 2003:		if( !this->is_analyze_phase ) {
        1: 2004:			log.push_back( "[\t" + get_line() + "] Z80:23cyc(BC!=0), 18cyc(BC=0), R800:?cyc(BC!=0), 7cyc(BC=0)" );
        1: 2005:			this->log_data_dump();
        1: 2006:			log.push_back( "" );
        -: 2007:		}
        3: 2008:		return check_all_fixed();
        -: 2009:	}
        3: 2010:	put_error( "Illegal operand" );
        3: 2011:	return false;
        -: 2012:}
        -: 2013:
        -: 2014:// --------------------------------------------------------------------
        6: 2015:bool CZMA_PARSE_EXX::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2016:
        6: 2017:	update_flags( &info, p_last_line );
        6: 2018:	if( this->opecode( info, 0xD9 ) ) {
        -: 2019:		//	log
        3: 2020:		if( !this->is_analyze_phase ) {
        1: 2021:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );
        1: 2022:			this->log_data_dump();
        1: 2023:			log.push_back( "" );
        -: 2024:		}
        3: 2025:		return check_all_fixed();
        -: 2026:	}
        3: 2027:	put_error( "Illegal operand" );
        3: 2028:	return false;
        -: 2029:}
        -: 2030:
        -: 2031:// --------------------------------------------------------------------
       21: 2032:bool CZMA_PARSE_EX::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2033:
       21: 2034:	update_flags( &info, p_last_line );
       21: 2035:	if( !this->is_data_fixed ) {
       11: 2036:		this->is_data_fixed = true;
       11: 2037:		if( words.size() == 4 && words[1] == "DE" && words[2] == "," && words[3] == "HL" ) {
        1: 2038:			this->set_code_size( &info, 1 );
        1: 2039:			this->data.push_back( 0xEB );
        -: 2040:		}
       10: 2041:		else if( words.size() == 4 && words[1] == "AF" && words[2] == "," && words[3] == "AF'" ) {
        1: 2042:			this->set_code_size( &info, 1 );
        1: 2043:			this->data.push_back( 0x08 );
        -: 2044:		}
        9: 2045:		else if( words.size() == 6 && words[1] == "[" && words[2] == "SP" && words[3] == "]" && words[4] == "," ) {
        6: 2046:			if( words[5] == "HL" ) {
        1: 2047:				this->set_code_size( &info, 1 );
        1: 2048:				this->data.push_back( 0xE3 );
        -: 2049:			}
        5: 2050:			else if( words[5] == "IX" ) {
        1: 2051:				this->set_code_size( &info, 2 );
        1: 2052:				this->data.push_back( 0xDD );
        1: 2053:				this->data.push_back( 0xE3 );
        -: 2054:			}
        4: 2055:			else if( words[5] == "IY" ) {
        1: 2056:				this->set_code_size( &info, 2 );
        1: 2057:				this->data.push_back( 0xFD );
        1: 2058:				this->data.push_back( 0xE3 );
        -: 2059:			}
        -: 2060:			else {
        3: 2061:				this->is_data_fixed = false;
        3: 2062:				put_error( "Illegal operand" );
        3: 2063:				return false;
        -: 2064:			}
        -: 2065:		}
        -: 2066:		else {
        3: 2067:			this->is_data_fixed = false;
        3: 2068:			put_error( "Illegal operand" );
        3: 2069:			return false;
        -: 2070:		}
        -: 2071:	}
        -: 2072:	//	log
       15: 2073:	if( !this->is_analyze_phase ) {
        5: 2074:		if( words.size() == 6 ) {
        3: 2075:			if( words[5] == "HL" ) {
        1: 2076:				log.push_back( "[\t" + get_line() + "] Z80:20cyc, R800:7cyc" );
        -: 2077:			}
        -: 2078:			else {
        2: 2079:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:8cyc" );
        -: 2080:			}
        -: 2081:		}
        -: 2082:		else {
        2: 2083:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );
        -: 2084:		}
        5: 2085:		this->log_data_dump();
        5: 2086:		log.push_back( "" );
        -: 2087:	}
       15: 2088:	return check_all_fixed();
        -: 2089:}
        -: 2090:
        -: 2091:// --------------------------------------------------------------------
       21: 2092:bool CZMA_PARSE_PUSH::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2093:
       21: 2094:	update_flags( &info, p_last_line );
       21: 2095:	if( this->opecode_rp_with_af( info, 0xC5 ) ) {
        -: 2096:		//	log
       18: 2097:		if( !this->is_analyze_phase ) {
        6: 2098:			if( words[1] == "IX" || words[1] == "IY" ) {
        2: 2099:				log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:7cyc" );
        -: 2100:			}
        -: 2101:			else {
        4: 2102:				log.push_back( "[\t" + get_line() + "] Z80:12cyc, R800:6cyc" );
        -: 2103:			}
        6: 2104:			this->log_data_dump();
        6: 2105:			log.push_back( "" );
        -: 2106:		}
       18: 2107:		return check_all_fixed();
        -: 2108:	}
        3: 2109:	put_error( "Illegal operand" );
        3: 2110:	return false;
        -: 2111:}
        -: 2112:
        -: 2113:// --------------------------------------------------------------------
       21: 2114:bool CZMA_PARSE_POP::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2115:
       21: 2116:	update_flags( &info, p_last_line );
       21: 2117:	if( this->opecode_rp_with_af( info, 0xC1 ) ) {
        -: 2118:		//	log
       18: 2119:		if( !this->is_analyze_phase ) {
        6: 2120:			if( words[1] == "IX" || words[1] == "IY" ) {
        2: 2121:				log.push_back( "[\t" + get_line() + "] Z80:16cyc, R800:6cyc" );
        -: 2122:			}
        -: 2123:			else {
        4: 2124:				log.push_back( "[\t" + get_line() + "] Z80:11cyc, R800:5cyc" );
        -: 2125:			}
        6: 2126:			this->log_data_dump();
        6: 2127:			log.push_back( "" );
        -: 2128:		}
       18: 2129:		return check_all_fixed();
        -: 2130:	}
        3: 2131:	put_error( "Illegal operand" );
        3: 2132:	return false;
        -: 2133:}
        -: 2134:
        -: 2135:// --------------------------------------------------------------------
        6: 2136:bool CZMA_PARSE_RLCA::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2137:
        6: 2138:	update_flags( &info, p_last_line );
        6: 2139:	if( this->opecode( info, 0x07 ) ) {
        -: 2140:		//	log
        3: 2141:		if( !this->is_analyze_phase ) {
        1: 2142:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );
        1: 2143:			this->log_data_dump();
        1: 2144:			log.push_back( "" );
        -: 2145:		}
        3: 2146:		return check_all_fixed();
        -: 2147:	}
        3: 2148:	put_error( "Illegal operand" );
        3: 2149:	return false;
        -: 2150:}
        -: 2151:
        -: 2152:// --------------------------------------------------------------------
        6: 2153:bool CZMA_PARSE_RLA::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2154:
        6: 2155:	update_flags( &info, p_last_line );
        6: 2156:	if( this->opecode( info, 0x17 ) ) {
        -: 2157:		//	log
        3: 2158:		if( !this->is_analyze_phase ) {
        1: 2159:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );
        1: 2160:			this->log_data_dump();
        1: 2161:			log.push_back( "" );
        -: 2162:		}
        3: 2163:		return check_all_fixed();
        -: 2164:	}
        3: 2165:	put_error( "Illegal operand" );
        3: 2166:	return false;
        -: 2167:}
        -: 2168:
        -: 2169:// --------------------------------------------------------------------
       33: 2170:bool CZMA_PARSE_RLC::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2171:
       33: 2172:	update_flags( &info, p_last_line );
       33: 2173:	if( this->opecode_sss( info, 0xCB, 0x00 ) ) {
        -: 2174:		//	log
       30: 2175:		if( !this->is_analyze_phase ) {
       10: 2176:			if( data.size() == 2 ) {
        8: 2177:				if( this->data[1] == 0x06 ) {
        1: 2178:					log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:8cyc" );		//	RLC	[HL]
        -: 2179:				}
        -: 2180:				else {
        7: 2181:					log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );		//	RLC	r
        -: 2182:				}
        -: 2183:			}
        -: 2184:			else {
        2: 2185:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );		//	RLC	[IX+d]
        -: 2186:			}
       10: 2187:			this->log_data_dump();
       10: 2188:			log.push_back( "" );
        -: 2189:		}
       30: 2190:		return check_all_fixed();
        -: 2191:	}
        3: 2192:	put_error( "Illegal operand" );
        3: 2193:	return false;
        -: 2194:}
        -: 2195:
        -: 2196:// --------------------------------------------------------------------
       36: 2197:bool CZMA_PARSE_RL::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2198:
       36: 2199:	update_flags( &info, p_last_line );
       36: 2200:	if( this->opecode_sss( info, 0xCB, 0x10 ) ) {
        -: 2201:		//	log
       33: 2202:		if( !this->is_analyze_phase ) {
       11: 2203:			if( data.size() == 2 ) {
        8: 2204:				if( this->data[1] == 0x16 ) {
        1: 2205:					log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:8cyc" );
        -: 2206:				}
        -: 2207:				else {
        7: 2208:					log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );
        -: 2209:				}
        -: 2210:			}
        -: 2211:			else {
        3: 2212:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );
        -: 2213:			}
       11: 2214:			this->log_data_dump();
       11: 2215:			log.push_back( "" );
        -: 2216:		}
       33: 2217:		return check_all_fixed();
        -: 2218:	}
        3: 2219:	put_error( "Illegal operand" );
        3: 2220:	return false;
        -: 2221:}
        -: 2222:
        -: 2223:// --------------------------------------------------------------------
        6: 2224:bool CZMA_PARSE_RRCA::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2225:
        6: 2226:	update_flags( &info, p_last_line );
        6: 2227:	if( this->opecode( info, 0x0F ) ) {
        -: 2228:		//	log
        3: 2229:		if( !this->is_analyze_phase ) {
        1: 2230:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );
        1: 2231:			this->log_data_dump();
        1: 2232:			log.push_back( "" );
        -: 2233:		}
        3: 2234:		return check_all_fixed();
        -: 2235:	}
        3: 2236:	put_error( "Illegal operand" );
        3: 2237:	return false;
        -: 2238:}
        -: 2239:
        -: 2240:// --------------------------------------------------------------------
        6: 2241:bool CZMA_PARSE_RRA::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2242:
        6: 2243:	update_flags( &info, p_last_line );
        6: 2244:	if( this->opecode( info, 0x1F ) ) {
        -: 2245:		//	log
        3: 2246:		if( !this->is_analyze_phase ) {
        1: 2247:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );
        1: 2248:			this->log_data_dump();
        1: 2249:			log.push_back( "" );
        -: 2250:		}
        3: 2251:		return check_all_fixed();
        -: 2252:	}
        3: 2253:	put_error( "Illegal operand" );
        3: 2254:	return false;
        -: 2255:}
        -: 2256:
        -: 2257:// --------------------------------------------------------------------
       33: 2258:bool CZMA_PARSE_RRC::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2259:
       33: 2260:	update_flags( &info, p_last_line );
       33: 2261:	if( this->opecode_sss( info, 0xCB, 0x08 ) ) {
        -: 2262:		//	log
       30: 2263:		if( !this->is_analyze_phase ) {
       10: 2264:			if( data.size() == 2 ) {
        8: 2265:				if( this->data[1] == 0x0E ) {
        1: 2266:					log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:8cyc" );			//	RRC [HL]
        -: 2267:				}
        -: 2268:				else {
        7: 2269:					log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );			//	RRC r
        -: 2270:				}
        -: 2271:			}
        -: 2272:			else {
        2: 2273:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );			//	RRC [IX+d]
        -: 2274:			}
       10: 2275:			this->log_data_dump();
       10: 2276:			log.push_back( "" );
        -: 2277:		}
       30: 2278:		return check_all_fixed();
        -: 2279:	}
        3: 2280:	put_error( "Illegal operand" );
        3: 2281:	return false;
        -: 2282:}
        -: 2283:
        -: 2284:// --------------------------------------------------------------------
       36: 2285:bool CZMA_PARSE_RR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2286:
       36: 2287:	update_flags( &info, p_last_line );
       36: 2288:	if( this->opecode_sss( info, 0xCB, 0x18 ) ) {
        -: 2289:		//	log
       33: 2290:		if( !this->is_analyze_phase ) {
       11: 2291:			if( data.size() == 2 ) {
        8: 2292:				if( this->data[1] == 0x1E ) {
        1: 2293:					log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:8cyc" );			//	RR [HL]
        -: 2294:				}
        -: 2295:				else {
        7: 2296:					log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );			//	RR r
        -: 2297:				}
        -: 2298:			}
        -: 2299:			else {
        3: 2300:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );			//	RR [IX+d]
        -: 2301:			}
       11: 2302:			this->log_data_dump();
       11: 2303:			log.push_back( "" );
        -: 2304:		}
       33: 2305:		return check_all_fixed();
        -: 2306:	}
        3: 2307:	put_error( "Illegal operand" );
        3: 2308:	return false;
        -: 2309:}
        -: 2310:
        -: 2311:// --------------------------------------------------------------------
       33: 2312:bool CZMA_PARSE_SLA::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2313:
       33: 2314:	update_flags( &info, p_last_line );
       33: 2315:	if( this->opecode_sss( info, 0xCB, 0x20 ) ) {
        -: 2316:		//	log
       30: 2317:		if( !this->is_analyze_phase ) {
       10: 2318:			if( data.size() == 2 ) {
        8: 2319:				if( this->data[1] == 0x26 ) {
        1: 2320:					log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:8cyc" );		//	SLA [HL]
        -: 2321:				}
        -: 2322:				else {
        7: 2323:					log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );		//	SLA r
        -: 2324:				}
        -: 2325:			}
        -: 2326:			else {
        2: 2327:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );		//	SLA [IX+d]
        -: 2328:			}
       10: 2329:			this->log_data_dump();
       10: 2330:			log.push_back( "" );
        -: 2331:		}
       30: 2332:		return check_all_fixed();
        -: 2333:	}
        3: 2334:	put_error( "Illegal operand" );
        3: 2335:	return false;
        -: 2336:}
        -: 2337:
        -: 2338:// --------------------------------------------------------------------
       36: 2339:bool CZMA_PARSE_SRA::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2340:
       36: 2341:	update_flags( &info, p_last_line );
       36: 2342:	if( this->opecode_sss( info, 0xCB, 0x28 ) ) {
        -: 2343:		//	log
       33: 2344:		if( !this->is_analyze_phase ) {
       11: 2345:			if( data.size() == 2 ) {
        8: 2346:				if( this->data[1] == 0x2E ) {
        1: 2347:					log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:8cyc" );		//	SRA [HL]
        -: 2348:				}
        -: 2349:				else {
        7: 2350:					log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );		//	SRA r
        -: 2351:				}
        -: 2352:			}
        -: 2353:			else {
        3: 2354:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );		//	SRA [IX+d]
        -: 2355:			}
       11: 2356:			this->log_data_dump();
       11: 2357:			log.push_back( "" );
        -: 2358:		}
       33: 2359:		return check_all_fixed();
        -: 2360:	}
        3: 2361:	put_error( "Illegal operand" );
        3: 2362:	return false;
        -: 2363:}
        -: 2364:
        -: 2365:// --------------------------------------------------------------------
       36: 2366:bool CZMA_PARSE_SRL::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2367:
       36: 2368:	update_flags( &info, p_last_line );
       36: 2369:	if( this->opecode_sss( info, 0xCB, 0x38 ) ) {
        -: 2370:		//	log
       33: 2371:		if( !this->is_analyze_phase ) {
       11: 2372:			if( data.size() == 2 ) {
        8: 2373:				if( this->data[1] == 0x3E ) {
        1: 2374:					log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:8cyc" );		//	SRL [HL]
        -: 2375:				}
        -: 2376:				else {
        7: 2377:					log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );		//	SRL	r
        -: 2378:				}
        -: 2379:			}
        -: 2380:			else {
        3: 2381:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );		//	SRL	[IX+d]
        -: 2382:			}
       11: 2383:			this->log_data_dump();
       11: 2384:			log.push_back( "" );
        -: 2385:		}
       33: 2386:		return check_all_fixed();
        -: 2387:	}
        3: 2388:	put_error( "Illegal operand" );
        3: 2389:	return false;
        -: 2390:}
        -: 2391:
        -: 2392:// --------------------------------------------------------------------
        3: 2393:bool CZMA_PARSE_SLL::process( CZMA_INFORMATION &info, CZMA_PARSE *p_last_line ){
        -: 2394:
        3: 2395:	update_flags( &info, p_last_line );
        3: 2396:	if( this->opecode_sss( info, 0xCB, 0x30 ) ){
        -: 2397:		//	log
        3: 2398:		if( !this->is_analyze_phase ){
        1: 2399:			if( data.size() == 2 ){
    #####: 2400:				if( this->data[ 1 ] == 0x36 ){
    #####: 2401:					log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:8cyc" );		//	SLL [HL]
        -: 2402:				}
        -: 2403:				else{
    #####: 2404:					log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );		//	SLL	r
        -: 2405:				}
        -: 2406:			}
        -: 2407:			else{
        1: 2408:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );		//	SLL	[IX+d]
        -: 2409:			}
        1: 2410:			this->log_data_dump();
        1: 2411:			log.push_back( "" );
        -: 2412:		}
        3: 2413:		return check_all_fixed();
        -: 2414:	}
    #####: 2415:	put_error( "Illegal operand" );
    #####: 2416:	return false;
        -: 2417:}
        -: 2418:
        -: 2419:// --------------------------------------------------------------------
      114: 2420:bool CZMA_PARSE_ADD::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2421:
      114: 2422:	update_flags( &info, p_last_line );
      114: 2423:	if( this->opecode_a_sss( info, 0x80 ) ) {
        -: 2424:		//	log
       39: 2425:		if( !this->is_analyze_phase ) {
       13: 2426:			if( words[3].size() > 1 ) {
        4: 2427:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	ADD A, IXh
        -: 2428:			}
        -: 2429:			else {
        9: 2430:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	ADD A, r
        -: 2431:			}
       13: 2432:			this->log_data_dump();
       13: 2433:			log.push_back( "" );
        -: 2434:		}
       39: 2435:		return check_all_fixed();
        -: 2436:	}
       75: 2437:	if( this->opecode_a_ref_hl( info, 0x86 ) ) {
        -: 2438:		//	log
        9: 2439:		if( !this->is_analyze_phase ) {
        3: 2440:			if( words[4] == "HL" ) {
        1: 2441:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );	//	ADD A, [HL]
        -: 2442:			}
        -: 2443:			else {
        2: 2444:				log.push_back( "[\t" + get_line() + "] Z80:21cyc, R800:7cyc" );	//	ADD A, [IX+o]
        -: 2445:			}
        3: 2446:			this->log_data_dump();
        3: 2447:			log.push_back( "" );
        -: 2448:		}
        9: 2449:		return check_all_fixed();
        -: 2450:	}
       66: 2451:	if( this->opecode_a_n( info, 0xC6 ) ) {
        -: 2452:		//	log
        3: 2453:		if( !this->is_analyze_phase ) {
        1: 2454:			log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:2cyc" );		//	ADD A, n
        1: 2455:			this->log_data_dump();
        1: 2456:			log.push_back( "" );
        -: 2457:		}
        3: 2458:		return check_all_fixed();
        -: 2459:	}
       63: 2460:	if( this->opecode_hl_rp( info, 0x09 ) ) {
        -: 2461:		//	log
       54: 2462:		if( !this->is_analyze_phase ) {
       18: 2463:			if( words[1] == "HL" ) {
        4: 2464:				log.push_back( "[\t" + get_line() + "] Z80:12cyc, R800:1cyc" );	//	ADD HL, rr
        -: 2465:			}
        -: 2466:			else {
       14: 2467:				log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:2cyc" );	//	ADD IX, rr
        -: 2468:			}
       18: 2469:			this->log_data_dump();
       18: 2470:			log.push_back( "" );
        -: 2471:		}
       54: 2472:		return check_all_fixed();
        -: 2473:	}
        9: 2474:	put_error( "Illegal operand" );
        9: 2475:	return false;
        -: 2476:}
        -: 2477:
        -: 2478:// --------------------------------------------------------------------
       60: 2479:bool CZMA_PARSE_ADC::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2480:
       60: 2481:	update_flags( &info, p_last_line );
       60: 2482:	if( this->opecode_a_sss( info, 0x88 ) ) {
        -: 2483:		//	log
       33: 2484:		if( !this->is_analyze_phase ) {
       11: 2485:			if( words[3].size() > 1 ) {
        4: 2486:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	ADC A, IXh
        -: 2487:			}
        -: 2488:			else {
        7: 2489:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	ADC A, r
        -: 2490:			}
       11: 2491:			this->log_data_dump();
       11: 2492:			log.push_back( "" );
        -: 2493:		}
       33: 2494:		return check_all_fixed();
        -: 2495:	}
       27: 2496:	if( this->opecode_a_ref_hl( info, 0x8E ) ) {
        -: 2497:		//	log
        9: 2498:		if( !this->is_analyze_phase ) {
        3: 2499:			if( words[4] == "HL" ) {
        1: 2500:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );	//	ADC A, [HL]
        -: 2501:			}
        -: 2502:			else {
        2: 2503:				log.push_back( "[\t" + get_line() + "] Z80:21cyc, R800:7cyc" );	//	ADC A, [IX+o]
        -: 2504:			}
        3: 2505:			this->log_data_dump();
        3: 2506:			log.push_back( "" );
        -: 2507:		}
        9: 2508:		return check_all_fixed();
        -: 2509:	}
       18: 2510:	if( this->opecode_a_n( info, 0xCE ) ) {
        -: 2511:		//	log
        3: 2512:		if( !this->is_analyze_phase ) {
        1: 2513:			log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:2cyc" );	//	ADC A, n
        1: 2514:			this->log_data_dump();
        1: 2515:			log.push_back( "" );
        -: 2516:		}
        3: 2517:		return check_all_fixed();
        -: 2518:	}
       15: 2519:	if( this->opecode_hl_rp_witnout_ix( info, 0xED, 0x4A ) ) {
        -: 2520:		//	log
       12: 2521:		if( !this->is_analyze_phase ) {
        4: 2522:			log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:2cyc" );	//	ADC HL, rr
        4: 2523:			this->log_data_dump();
        4: 2524:			log.push_back( "" );
        -: 2525:		}
       12: 2526:		return check_all_fixed();
        -: 2527:	}
        3: 2528:	put_error( "Illegal operand" );
        3: 2529:	return false;
        -: 2530:}
        -: 2531:
        -: 2532:// --------------------------------------------------------------------
      117: 2533:bool CZMA_PARSE_INC::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2534:
      117: 2535:	update_flags( &info, p_last_line );
      117: 2536:	if( this->opecode_ddd( info, 0x04 ) ) {
        -: 2537:		//	log
       33: 2538:		if( !this->is_analyze_phase ) {
       11: 2539:			if( data.size() == 2 ) {
        4: 2540:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );		//	INC IXh
        -: 2541:			}
        -: 2542:			else {
        7: 2543:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );		//	INC r
        -: 2544:			}
       11: 2545:			this->log_data_dump();
       11: 2546:			log.push_back( "" );
        -: 2547:		}
       33: 2548:		return check_all_fixed();
        -: 2549:	}
       84: 2550:	if( this->opecode_rp( info, 0x03 ) ) {
        -: 2551:		//	log
       18: 2552:		if( !this->is_analyze_phase ) {
        6: 2553:			if( words[1] == "IX" || words[1] == "IY" ) {
        2: 2554:				log.push_back( "[\t" + get_line() + "] Z80:12cyc, R800:1cyc" );		//	INC IX
        -: 2555:			}
        -: 2556:			else {
        4: 2557:				log.push_back( "[\t" + get_line() + "] Z80:7cyc, R800:1cyc" );		//	INC rr
        -: 2558:			}
        6: 2559:			this->log_data_dump();
        6: 2560:			log.push_back( "" );
        -: 2561:		}
       18: 2562:		return check_all_fixed();
        -: 2563:	}
       66: 2564:	if( this->opecode_ref_hl( info, 0x34 ) ) {
        -: 2565:		//	log
       15: 2566:		if( !this->is_analyze_phase ) {
        5: 2567:			if( words[2] == "HL" ) {
        1: 2568:				log.push_back( "[\t" + get_line() + "] Z80:12cyc, R800:7cyc" );		//	INC [HL]
        -: 2569:			}
        -: 2570:			else {
        4: 2571:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );	//	INC [IX+o]
        -: 2572:			}
        5: 2573:			this->log_data_dump();
        5: 2574:			log.push_back( "" );
        -: 2575:		}
       15: 2576:		return check_all_fixed();
        -: 2577:	}
       51: 2578:	put_error( "Illegal operand" );
       51: 2579:	return false;
        -: 2580:}
        -: 2581:
        -: 2582:// --------------------------------------------------------------------
       48: 2583:bool CZMA_PARSE_SUB::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2584:
       48: 2585:	update_flags( &info, p_last_line );
       48: 2586:	if( this->opecode_a_sss( info, 0x90 ) ) {
        -: 2587:		//	log
       33: 2588:		if( !this->is_analyze_phase ) {
       11: 2589:			if( data.size() == 2 ) {
        4: 2590:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	SUB A, IXh
        -: 2591:			}
        -: 2592:			else {
        7: 2593:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	SUB A, r
        -: 2594:			}
       11: 2595:			this->log_data_dump();
       11: 2596:			log.push_back( "" );
        -: 2597:		}
       33: 2598:		return check_all_fixed();
        -: 2599:	}
       15: 2600:	if( this->opecode_a_ref_hl( info, 0x96 ) ) {
        -: 2601:		//	log
        9: 2602:		if( !this->is_analyze_phase ) {
        3: 2603:			if( words[4] == "HL" ) {
        1: 2604:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );	//	SUB A, [HL]
        -: 2605:			}
        -: 2606:			else {
        2: 2607:				log.push_back( "[\t" + get_line() + "] Z80:21cyc, R800:7cyc" );	//	SUB A, [IX+o]
        -: 2608:			}
        3: 2609:			this->log_data_dump();
        3: 2610:			log.push_back( "" );
        -: 2611:		}
        9: 2612:		return check_all_fixed();
        -: 2613:	}
        6: 2614:	if( this->opecode_a_n( info, 0xD6 ) ) {
        -: 2615:		//	log
        3: 2616:		if( !this->is_analyze_phase ) {
        1: 2617:			log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:2cyc" );	//	SUB A, n
        1: 2618:			this->log_data_dump();
        1: 2619:			log.push_back( "" );
        -: 2620:		}
        3: 2621:		return check_all_fixed();
        -: 2622:	}
        3: 2623:	put_error( "Illegal operand" );
        3: 2624:	return false;
        -: 2625:}
        -: 2626:
        -: 2627:// --------------------------------------------------------------------
       60: 2628:bool CZMA_PARSE_SBC::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2629:
       60: 2630:	update_flags( &info, p_last_line );
       60: 2631:	if( this->opecode_a_sss( info, 0x98 ) ) {
        -: 2632:		//	log
       33: 2633:		if( !this->is_analyze_phase ) {
       11: 2634:			if( data.size() == 2 ) {
        4: 2635:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	SBC A, IXh
        -: 2636:			}
        -: 2637:			else {
        7: 2638:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	SBC A, r
        -: 2639:			}
       11: 2640:			this->log_data_dump();
       11: 2641:			log.push_back( "" );
        -: 2642:		}
       33: 2643:		return check_all_fixed();
        -: 2644:	}
       27: 2645:	if( this->opecode_a_ref_hl( info, 0x9E ) ) {
        -: 2646:		//	log
        9: 2647:		if( !this->is_analyze_phase ) {
        3: 2648:			if( words[4] == "HL" ) {
        1: 2649:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );	//	SBC A, [HL]
        -: 2650:			}
        -: 2651:			else {
        2: 2652:				log.push_back( "[\t" + get_line() + "] Z80:21cyc, R800:7cyc" );	//	SBC A, [IX+o]
        -: 2653:			}
        3: 2654:			this->log_data_dump();
        3: 2655:			log.push_back( "" );
        -: 2656:		}
        9: 2657:		return check_all_fixed();
        -: 2658:	}
       18: 2659:	if( this->opecode_a_n( info, 0xDE ) ) {
        -: 2660:		//	log
        3: 2661:		if( !this->is_analyze_phase ) {
        1: 2662:			log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:2cyc" );	//	SBC A, n
        1: 2663:			this->log_data_dump();
        1: 2664:			log.push_back( "" );
        -: 2665:		}
        3: 2666:		return check_all_fixed();
        -: 2667:	}
       15: 2668:	if( this->opecode_hl_rp_witnout_ix( info, 0xED, 0x42 ) ) {
        -: 2669:		//	log
       12: 2670:		if( !this->is_analyze_phase ) {
        4: 2671:			log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:2cyc" );	//	SBC HL, rr
        4: 2672:			this->log_data_dump();
        4: 2673:			log.push_back( "" );
        -: 2674:		}
       12: 2675:		return check_all_fixed();
        -: 2676:	}
        3: 2677:	put_error( "Illegal operand" );
        3: 2678:	return false;
        -: 2679:}
        -: 2680:
        -: 2681:// --------------------------------------------------------------------
       63: 2682:bool CZMA_PARSE_DEC::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2683:
       63: 2684:	update_flags( &info, p_last_line );
       63: 2685:	if( this->opecode_ddd( info, 0x05 ) ) {
        -: 2686:		//	log
       33: 2687:		if( !this->is_analyze_phase ) {
       11: 2688:			if( data.size() == 2 ) {
        4: 2689:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	DEC IXh
        -: 2690:			}
        -: 2691:			else {
        7: 2692:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	DEC r
        -: 2693:			}
       11: 2694:			this->log_data_dump();
       11: 2695:			log.push_back( "" );
        -: 2696:		}
       33: 2697:		return check_all_fixed();
        -: 2698:	}
       30: 2699:	if( this->opecode_rp( info, 0x0B ) ) {
        -: 2700:		//	log
       18: 2701:		if( !this->is_analyze_phase ) {
        6: 2702:			if( words[1] == "IX" || words[1] == "IY" ) {
        2: 2703:				log.push_back( "[\t" + get_line() + "] Z80:12cyc, R800:2cyc" );	//	DEC IX
        -: 2704:			}
        -: 2705:			else {
        4: 2706:				log.push_back( "[\t" + get_line() + "] Z80:7cyc, R800:1cyc" );	//	DEC rr
        -: 2707:			}
        6: 2708:			this->log_data_dump();
        6: 2709:			log.push_back( "" );
        -: 2710:		}
       18: 2711:		return check_all_fixed();
        -: 2712:	}
       12: 2713:	if( this->opecode_ref_hl( info, 0x35 ) ) {
        -: 2714:		//	log
        9: 2715:		if( !this->is_analyze_phase ) {
        3: 2716:			if( words[2] == "HL" ) {
        1: 2717:				log.push_back( "[\t" + get_line() + "] Z80:12cyc, R800:7cyc" );		//	DEC [HL]
        -: 2718:			}
        -: 2719:			else {
        2: 2720:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );	//	DEC [IX+o]
        -: 2721:			}
        3: 2722:			this->log_data_dump();
        3: 2723:			log.push_back( "" );
        -: 2724:		}
        9: 2725:		return check_all_fixed();
        -: 2726:	}
        3: 2727:	put_error( "Illegal operand" );
        3: 2728:	return false;
        -: 2729:}
        -: 2730:
        -: 2731:// --------------------------------------------------------------------
       48: 2732:bool CZMA_PARSE_AND::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2733:
       48: 2734:	update_flags( &info, p_last_line );
       48: 2735:	if( this->opecode_a_sss( info, 0xA0 ) ) {
        -: 2736:		//	log
       33: 2737:		if( !this->is_analyze_phase ) {
       11: 2738:			if( data.size() == 2 ) {
        4: 2739:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	AND A, IXh
        -: 2740:			}
        -: 2741:			else {
        7: 2742:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	AND A, r
        -: 2743:			}
       11: 2744:			this->log_data_dump();
       11: 2745:			log.push_back( "" );
        -: 2746:		}
       33: 2747:		return check_all_fixed();
        -: 2748:	}
       15: 2749:	if( this->opecode_a_n( info, 0xE6 ) ) {
        -: 2750:		//	log
        3: 2751:		if( !this->is_analyze_phase ) {
        1: 2752:			log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:2cyc" );	//	AND A, n
        1: 2753:			this->log_data_dump();
        1: 2754:			log.push_back( "" );
        -: 2755:		}
        3: 2756:		return check_all_fixed();
        -: 2757:	}
       12: 2758:	if( this->opecode_a_ref_hl( info, 0xA6 ) ) {
        -: 2759:		//	log
        9: 2760:		if( !this->is_analyze_phase ) {
        3: 2761:			if( words[4] == "HL" ) {
        1: 2762:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );	//	AND A, [HL]
        -: 2763:			}
        -: 2764:			else {
        2: 2765:				log.push_back( "[\t" + get_line() + "] Z80:21cyc, R800:7cyc" );	//	AND A, [IX+o]
        -: 2766:			}
        3: 2767:			this->log_data_dump();
        3: 2768:			log.push_back( "" );
        -: 2769:		}
        9: 2770:		return check_all_fixed();
        -: 2771:	}
        3: 2772:	put_error( "Illegal operand" );
        3: 2773:	return false;
        -: 2774:}
        -: 2775:
        -: 2776:// --------------------------------------------------------------------
       48: 2777:bool CZMA_PARSE_OR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2778:
       48: 2779:	update_flags( &info, p_last_line );
       48: 2780:	if( this->opecode_a_sss( info, 0xB0 ) ) {
        -: 2781:		//	log
       33: 2782:		if( !this->is_analyze_phase ) {
       11: 2783:			if( data.size() == 2 ) {
        4: 2784:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	OR A, IXh
        -: 2785:			}
        -: 2786:			else {
        7: 2787:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	OR A, r
        -: 2788:			}
       11: 2789:			this->log_data_dump();
       11: 2790:			log.push_back( "" );
        -: 2791:		}
       33: 2792:		return check_all_fixed();
        -: 2793:	}
       15: 2794:	if( this->opecode_a_n( info, 0xF6 ) ) {
        -: 2795:		//	log
        3: 2796:		if( !this->is_analyze_phase ) {
        1: 2797:			log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:2cyc" );	//	OR A, n
        1: 2798:			this->log_data_dump();
        1: 2799:			log.push_back( "" );
        -: 2800:		}
        3: 2801:		return check_all_fixed();
        -: 2802:	}
       12: 2803:	if( this->opecode_a_ref_hl( info, 0xB6 ) ) {
        -: 2804:		//	log
        9: 2805:		if( !this->is_analyze_phase ) {
        3: 2806:			if( words[4] == "HL" ) {
        1: 2807:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );	//	OR A, [HL]
        -: 2808:			}
        -: 2809:			else {
        2: 2810:				log.push_back( "[\t" + get_line() + "] Z80:21cyc, R800:7cyc" );	//	OR A, [IX+o]
        -: 2811:			}
        3: 2812:			this->log_data_dump();
        3: 2813:			log.push_back( "" );
        -: 2814:		}
        9: 2815:		return check_all_fixed();
        -: 2816:	}
        3: 2817:	put_error( "Illegal operand" );
        3: 2818:	return false;
        -: 2819:}
        -: 2820:
        -: 2821:// --------------------------------------------------------------------
       48: 2822:bool CZMA_PARSE_XOR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2823:
       48: 2824:	update_flags( &info, p_last_line );
       48: 2825:	if( this->opecode_a_sss( info, 0xA8 ) ) {
        -: 2826:		//	log
       33: 2827:		if( !this->is_analyze_phase ) {
       11: 2828:			if( data.size() == 2 ) {
        4: 2829:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	XOR A, IXh
        -: 2830:			}
        -: 2831:			else {
        7: 2832:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	XOR A, r
        -: 2833:			}
       11: 2834:			this->log_data_dump();
       11: 2835:			log.push_back( "" );
        -: 2836:		}
       33: 2837:		return check_all_fixed();
        -: 2838:	}
       15: 2839:	if( this->opecode_a_n( info, 0xEE ) ) {
        -: 2840:		//	log
        3: 2841:		if( !this->is_analyze_phase ) {
        1: 2842:			log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:2cyc" );	//	XOR A, n
        1: 2843:			this->log_data_dump();
        1: 2844:			log.push_back( "" );
        -: 2845:		}
        3: 2846:		return check_all_fixed();
        -: 2847:	}
       12: 2848:	if( this->opecode_a_ref_hl( info, 0xAE ) ) {
        -: 2849:		//	log
        9: 2850:		if( !this->is_analyze_phase ) {
        3: 2851:			if( words[4] == "HL" ) {
        1: 2852:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );	//	XOR A, [HL]
        -: 2853:			}
        -: 2854:			else {
        2: 2855:				log.push_back( "[\t" + get_line() + "] Z80:21cyc, R800:7cyc" );	//	XOR A, [IX+o]
        -: 2856:			}
        3: 2857:			this->log_data_dump();
        3: 2858:			log.push_back( "" );
        -: 2859:		}
        9: 2860:		return check_all_fixed();
        -: 2861:	}
        3: 2862:	put_error( "Illegal operand" );
        3: 2863:	return false;
        -: 2864:}
        -: 2865:
        -: 2866:// --------------------------------------------------------------------
        6: 2867:bool CZMA_PARSE_CPL::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2868:
        6: 2869:	update_flags( &info, p_last_line );
        6: 2870:	if( this->opecode( info, 0x2F ) ) {
        -: 2871:		//	log
        3: 2872:		if( !this->is_analyze_phase ) {
        1: 2873:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	CPL
        1: 2874:			this->log_data_dump();
        1: 2875:			log.push_back( "" );
        -: 2876:		}
        3: 2877:		return check_all_fixed();
        -: 2878:	}
        3: 2879:	put_error( "Illegal operand" );
        3: 2880:	return false;
        -: 2881:}
        -: 2882:
        -: 2883:// --------------------------------------------------------------------
        6: 2884:bool CZMA_PARSE_NEG::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2885:
        6: 2886:	update_flags( &info, p_last_line );
        6: 2887:	if( this->opecode( info, 0xED, 0x44 ) ) {
        -: 2888:		//	log
        3: 2889:		if( !this->is_analyze_phase ) {
        1: 2890:			log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	NEG
        1: 2891:			this->log_data_dump();
        1: 2892:			log.push_back( "" );
        -: 2893:		}
        3: 2894:		return check_all_fixed();
        -: 2895:	}
        3: 2896:	put_error( "Illegal operand" );
        3: 2897:	return false;
        -: 2898:}
        -: 2899:
        -: 2900:// --------------------------------------------------------------------
        6: 2901:bool CZMA_PARSE_CCF::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2902:
        6: 2903:	update_flags( &info, p_last_line );
        6: 2904:	if( this->opecode( info, 0x3F ) ) {
        -: 2905:		//	log
        3: 2906:		if( !this->is_analyze_phase ) {
        1: 2907:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	NEG
        1: 2908:			this->log_data_dump();
        1: 2909:			log.push_back( "" );
        -: 2910:		}
        3: 2911:		return check_all_fixed();
        -: 2912:	}
        3: 2913:	put_error( "Illegal operand" );
        3: 2914:	return false;
        -: 2915:}
        -: 2916:
        -: 2917:// --------------------------------------------------------------------
        6: 2918:bool CZMA_PARSE_SCF::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2919:
        6: 2920:	update_flags( &info, p_last_line );
        6: 2921:	if( this->opecode( info, 0x37 ) ) {
        -: 2922:		//	log
        3: 2923:		if( !this->is_analyze_phase ) {
        1: 2924:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	NEG
        1: 2925:			this->log_data_dump();
        1: 2926:			log.push_back( "" );
        -: 2927:		}
        3: 2928:		return check_all_fixed();
        -: 2929:	}
        3: 2930:	put_error( "Illegal operand" );
        3: 2931:	return false;
        -: 2932:}
        -: 2933:
        -: 2934:// --------------------------------------------------------------------
      246: 2935:bool CZMA_PARSE_BIT::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2936:
      246: 2937:	update_flags( &info, p_last_line );
      246: 2938:	if( this->opecode_n_sss( info, 0x40, true ) ) {
        -: 2939:		//	log
      243: 2940:		if( !this->is_analyze_phase ) {
       81: 2941:			if( data.size() == 2 && (data[1] & 0x07) != 0x06 ) {
       56: 2942:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	BIT b,r
        -: 2943:			}
       25: 2944:			else if( data.size() == 2 ) {
        8: 2945:				log.push_back( "[\t" + get_line() + "] Z80:14cyc, R800:5cyc" );	//	BIT b,[HL]
        -: 2946:			}
        -: 2947:			else {
       17: 2948:				log.push_back( "[\t" + get_line() + "] Z80:22cyc, R800:7cyc" );	//	BIT b,[IX+o]
        -: 2949:			}
       81: 2950:			this->log_data_dump();
       81: 2951:			log.push_back( "" );
        -: 2952:		}
      243: 2953:		return check_all_fixed();
        -: 2954:	}
        3: 2955:	put_error( "Illegal operand" );
        3: 2956:	return false;
        -: 2957:}
        -: 2958:
        -: 2959:// --------------------------------------------------------------------
      246: 2960:bool CZMA_PARSE_RES::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2961:
      246: 2962:	update_flags( &info, p_last_line );
      246: 2963:	if( this->opecode_n_sss( info, 0x80 ) ) {
        -: 2964:		//	log
      243: 2965:		if( !this->is_analyze_phase ) {
       81: 2966:			if( data.size() == 2 && (data[1] & 0x07) != 0x06 ) {
       56: 2967:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );		//	RES b,r
        -: 2968:			}
       25: 2969:			else if( data.size() == 2 ) {
        8: 2970:				log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:8cyc" );		//	RES b,[HL]
        -: 2971:			}
        -: 2972:			else {
       17: 2973:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );	//	RES b,[IX+o]
        -: 2974:			}
       81: 2975:			this->log_data_dump();
       81: 2976:			log.push_back( "" );
        -: 2977:		}
      243: 2978:		return check_all_fixed();
        -: 2979:	}
        3: 2980:	put_error( "Illegal operand" );
        3: 2981:	return false;
        -: 2982:}
        -: 2983:
        -: 2984:// --------------------------------------------------------------------
      246: 2985:bool CZMA_PARSE_SET::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 2986:
      246: 2987:	update_flags( &info, p_last_line );
      246: 2988:	if( this->opecode_n_sss( info, 0xC0 ) ) {
        -: 2989:		//	log
      243: 2990:		if( !this->is_analyze_phase ) {
       81: 2991:			if( data.size() == 2 && (data[1] & 0x07) != 0x06 ) {
       56: 2992:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );		//	SET b,r
        -: 2993:			}
       25: 2994:			else if( data.size() == 2 ) {
        8: 2995:				log.push_back( "[\t" + get_line() + "] Z80:17cyc, R800:8cyc" );		//	SET b,[HL]
        -: 2996:			}
        -: 2997:			else {
       17: 2998:				log.push_back( "[\t" + get_line() + "] Z80:25cyc, R800:10cyc" );	//	SET b,[IX+o]
        -: 2999:			}
       81: 3000:			this->log_data_dump();
       81: 3001:			log.push_back( "" );
        -: 3002:		}
      243: 3003:		return check_all_fixed();
        -: 3004:	}
        3: 3005:	put_error( "Illegal operand" );
        3: 3006:	return false;
        -: 3007:}
        -: 3008:
        -: 3009:// --------------------------------------------------------------------
        6: 3010:bool CZMA_PARSE_CPI::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3011:
        6: 3012:	update_flags( &info, p_last_line );
        6: 3013:	if( this->opecode( info, 0xED, 0xA1 ) ) {
        -: 3014:		//	log
        3: 3015:		if( !this->is_analyze_phase ) {
        1: 3016:			log.push_back( "[\t" + get_line() + "] Z80:18cyc, R800:6cyc" );
        1: 3017:			this->log_data_dump();
        1: 3018:			log.push_back( "" );
        -: 3019:		}
        3: 3020:		return check_all_fixed();
        -: 3021:	}
        3: 3022:	put_error( "Illegal operand" );
        3: 3023:	return false;
        -: 3024:}
        -: 3025:
        -: 3026:// --------------------------------------------------------------------
        6: 3027:bool CZMA_PARSE_CPIR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3028:
        6: 3029:	update_flags( &info, p_last_line );
        6: 3030:	if( this->opecode( info, 0xED, 0xB1 ) ) {
        -: 3031:		//	log
        3: 3032:		if( !this->is_analyze_phase ) {
        1: 3033:			log.push_back( "[\t" + get_line() + "] Z80:23cyc(BC!=0 && A!=[HL]), 18cyc(others), R800:?cyc(BC!=0 && A!=[HL]), 8cyc(others)" );
        1: 3034:			this->log_data_dump();
        1: 3035:			log.push_back( "" );
        -: 3036:		}
        3: 3037:		return check_all_fixed();
        -: 3038:	}
        3: 3039:	put_error( "Illegal operand" );
        3: 3040:	return false;
        -: 3041:}
        -: 3042:
        -: 3043:// --------------------------------------------------------------------
        6: 3044:bool CZMA_PARSE_CPD::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3045:
        6: 3046:	update_flags( &info, p_last_line );
        6: 3047:	if( this->opecode( info, 0xED, 0xA9 ) ) {
        -: 3048:		//	log
        3: 3049:		if( !this->is_analyze_phase ) {
        1: 3050:			log.push_back( "[\t" + get_line() + "] Z80:18cyc, R800:6cyc" );
        1: 3051:			this->log_data_dump();
        1: 3052:			log.push_back( "" );
        -: 3053:		}
        3: 3054:		return check_all_fixed();
        -: 3055:	}
        3: 3056:	put_error( "Illegal operand" );
        3: 3057:	return false;
        -: 3058:}
        -: 3059:
        -: 3060:// --------------------------------------------------------------------
        6: 3061:bool CZMA_PARSE_CPDR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3062:
        6: 3063:	update_flags( &info, p_last_line );
        6: 3064:	if( this->opecode( info, 0xED, 0xB9 ) ) {
        -: 3065:		//	log
        3: 3066:		if( !this->is_analyze_phase ) {
        1: 3067:			log.push_back( "[\t" + get_line() + "] Z80:23cyc(BC!=0 && A!=[HL]), 18cyc(others), R800:?cyc(BC!=0 && A!=[HL]), 8cyc(others)" );
        1: 3068:			this->log_data_dump();
        1: 3069:			log.push_back( "" );
        -: 3070:		}
        3: 3071:		return check_all_fixed();
        -: 3072:	}
        3: 3073:	put_error( "Illegal operand" );
        3: 3074:	return false;
        -: 3075:}
        -: 3076:
        -: 3077:// --------------------------------------------------------------------
       60: 3078:bool CZMA_PARSE_CP::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3079:
       60: 3080:	update_flags( &info, p_last_line );
       60: 3081:	if( this->opecode_a_sss( info, 0xB8 ) ) {
        -: 3082:		//	log
       33: 3083:		if( !this->is_analyze_phase ) {
       11: 3084:			if( data.size() == 2 ) {
        4: 3085:				log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:2cyc" );	//	CP A, IXh
        -: 3086:			}
        -: 3087:			else {
        7: 3088:				log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );	//	CP A, r
        -: 3089:			}
       11: 3090:			this->log_data_dump();
       11: 3091:			log.push_back( "" );
        -: 3092:		}
       33: 3093:		return check_all_fixed();
        -: 3094:	}
       27: 3095:	if( this->opecode_a_n( info, 0xFE ) ) {
        -: 3096:		//	log
        6: 3097:		if( !this->is_analyze_phase ) {
        2: 3098:			log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:2cyc" );	//	CP A, n
        2: 3099:			this->log_data_dump();
        2: 3100:			log.push_back( "" );
        -: 3101:		}
        6: 3102:		return check_all_fixed();
        -: 3103:	}
       21: 3104:	if( this->opecode_a_ref_hl( info, 0xBE ) ) {
        -: 3105:		//	log
       15: 3106:		if( !this->is_analyze_phase ) {
        5: 3107:			if( words[4] == "HL" ) {
        1: 3108:				log.push_back( "[\t" + get_line() + "] Z80:8cyc, R800:4cyc" );	//	CP A, [HL]
        -: 3109:			}
        -: 3110:			else {
        4: 3111:				log.push_back( "[\t" + get_line() + "] Z80:21cyc, R800:7cyc" );	//	CP A, [IX+o]
        -: 3112:			}
        5: 3113:			this->log_data_dump();
        5: 3114:			log.push_back( "" );
        -: 3115:		}
       15: 3116:		return check_all_fixed();
        -: 3117:	}
        6: 3118:	put_error( "Illegal operand" );
        6: 3119:	return false;
        -: 3120:}
        -: 3121:
        -: 3122:// --------------------------------------------------------------------
       45: 3123:bool CZMA_PARSE_JP::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3124:
       45: 3125:	update_flags( &info, p_last_line );
       45: 3126:	if( opecode_ccc_nnn( info, 0xC3, 0xC2 ) ) {
        -: 3127:		//	log
       27: 3128:		if( !this->is_analyze_phase ) {
        9: 3129:			if( data[0] == 0xC3 ) {
        1: 3130:				log.push_back( "[\t" + get_line() + "] Z80:11cyc, R800:5cyc" );	//	JP nn
        -: 3131:			}
        -: 3132:			else {
        8: 3133:				log.push_back( "[\t" + get_line() + "] Z80:11cyc, R800:5cyc(cond=true), 3cyc(cond=false)" );	//	JP cond, nn
        -: 3134:			}
        9: 3135:			this->log_data_dump();
        9: 3136:			log.push_back( "" );
        -: 3137:		}
       27: 3138:		return check_all_fixed();
        -: 3139:	}
       18: 3140:	if( words.size() == 2 && words[1] == "HL" ) {
        3: 3141:		if( !this->is_data_fixed ) {
        1: 3142:			this->set_code_size( &info, 1 );
        1: 3143:			this->is_data_fixed = true;
        1: 3144:			this->data.push_back( 0xE9 );
        -: 3145:		}
        -: 3146:		//	log
        3: 3147:		if( !this->is_analyze_phase ) {
        1: 3148:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:3cyc" );	//	JP HL
        1: 3149:			this->log_data_dump();
        1: 3150:			log.push_back( "" );
        -: 3151:		}
        3: 3152:		return check_all_fixed();
        -: 3153:	}
       15: 3154:	if( words.size() == 2 && words[1] == "IX" ) {
        3: 3155:		if( !this->is_data_fixed ) {
        1: 3156:			this->set_code_size( &info, 2 );
        1: 3157:			this->is_data_fixed = true;
        1: 3158:			this->data.push_back( 0xDD );
        1: 3159:			this->data.push_back( 0xE9 );
        -: 3160:		}
        -: 3161:		//	log
        3: 3162:		if( !this->is_analyze_phase ) {
        1: 3163:			log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:4cyc" );	//	JP IX
        1: 3164:			this->log_data_dump();
        1: 3165:			log.push_back( "" );
        -: 3166:		}
        3: 3167:		return check_all_fixed();
        -: 3168:	}
       12: 3169:	if( words.size() == 2 && words[1] == "IY" ) {
        3: 3170:		if( !this->is_data_fixed ) {
        1: 3171:			this->set_code_size( &info, 2 );
        1: 3172:			this->is_data_fixed = true;
        1: 3173:			this->data.push_back( 0xFD );
        1: 3174:			this->data.push_back( 0xE9 );
        -: 3175:		}
        -: 3176:		//	log
        3: 3177:		if( !this->is_analyze_phase ) {
        1: 3178:			log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:4cyc" );	//	JP IY
        1: 3179:			this->log_data_dump();
        1: 3180:			log.push_back( "" );
        -: 3181:		}
        3: 3182:		return check_all_fixed();
        -: 3183:	}
        9: 3184:	put_error( "Illegal operand" );
        9: 3185:	return false;
        -: 3186:}
        -: 3187:
        -: 3188:// --------------------------------------------------------------------
       30: 3189:bool CZMA_PARSE_JR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3190:
       30: 3191:	update_flags( &info, p_last_line );
        -: 3192:
       30: 3193:	if( opecode_ccc_e( info, 0x18, 0x20 ) ) {
        -: 3194:		//	log
       10: 3195:		if( !this->is_analyze_phase ) {
        5: 3196:			if( data[0] == 0x18 ) {
        1: 3197:				log.push_back( "[\t" + get_line() + "] Z80:13cyc, R800:3cyc" );	//	JR nn
        -: 3198:			}
        -: 3199:			else {
        4: 3200:				log.push_back( "[\t" + get_line() + "] Z80:13cyc(cond=true), 8cyc(cond=false), R800:3cyc(cond=true), 2cyc(cond=false)" );	//	JR cond, nn
        -: 3201:			}
        5: 3202:			this->log_data_dump();
        5: 3203:			log.push_back( "" );
        -: 3204:		}
       10: 3205:		return check_all_fixed();
        -: 3206:	}
       20: 3207:	put_error( "Illegal operand" );
       20: 3208:	return false;
        -: 3209:}
        -: 3210:
        -: 3211:// --------------------------------------------------------------------
       12: 3212:bool CZMA_PARSE_DJNZ::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3213:	int relative;
        -: 3214:
       12: 3215:	update_flags( &info, p_last_line );
       12: 3216:	if( words.size() != 2 ) {
        3: 3217:		put_error( "Illegal operand" );
        3: 3218:		return false;
        -: 3219:	}
        9: 3220:	if( !this->is_data_fixed ) {
        4: 3221:		this->set_code_size( &info, 2 );
        4: 3222:		relative = this->relative_address( info, 1 );
        4: 3223:		if( relative == -9999 ) {
        1: 3224:			put_error( "Illegal operand" );
        1: 3225:			return false;
        -: 3226:		}
        3: 3227:		this->is_data_fixed = true;
        3: 3228:		this->data.push_back( 0x10 );
        3: 3229:		this->data.push_back( relative );
        -: 3230:	}
        -: 3231:	//	log
        8: 3232:	if( !this->is_analyze_phase ) {
        3: 3233:		log.push_back( "[\t" + get_line() + "] Z80:14cyc(cond=true), 9cyc(cond=false), R800:3cyc(cond=true), 2cyc(cond=false)" );	//	DJNZ nn
        3: 3234:		this->log_data_dump();
        3: 3235:		log.push_back( "" );
        -: 3236:	}
        8: 3237:	return check_all_fixed();
        -: 3238:}
        -: 3239:
        -: 3240:// --------------------------------------------------------------------
       36: 3241:bool CZMA_PARSE_CALL::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3242:
       36: 3243:	update_flags( &info, p_last_line );
       36: 3244:	if( opecode_ccc_nnn( info, 0xCD, 0xC4 ) ) {
        -: 3245:		//	log
       27: 3246:		if( !this->is_analyze_phase ) {
        9: 3247:			if( data[0] == 0xCD ) {
        1: 3248:				log.push_back( "[\t" + get_line() + "] Z80:18cyc, R800:5cyc" );				//	CALL nn
        -: 3249:			}
        -: 3250:			else {
        8: 3251:				log.push_back( "[\t" + get_line() + "] Z80:18cyc(branch), 11cyc(through), R800:5cyc(branch), 3cyc(through)" );	//	CALL cond,nn
        -: 3252:			}
        9: 3253:			this->log_data_dump();
        9: 3254:			log.push_back( "" );
        -: 3255:		}
       27: 3256:		return check_all_fixed();
        -: 3257:	}
        9: 3258:	put_error( "Illegal operand" );
        9: 3259:	return false;
        -: 3260:}
        -: 3261:
        -: 3262:// --------------------------------------------------------------------
       39: 3263:bool CZMA_PARSE_RET::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3264:
       39: 3265:	update_flags( &info, p_last_line );
       39: 3266:	if( opecode_ccc( info, 0xC9, 0xC0 ) ) {
        -: 3267:		//	log
       36: 3268:		if( !this->is_analyze_phase ) {
       12: 3269:			if( data[0] == 0xC9 ) {
        4: 3270:				log.push_back( "[\t" + get_line() + "] Z80:11cyc, R800:5cyc" );				//	RET
        -: 3271:			}
        -: 3272:			else {
        8: 3273:				log.push_back( "[\t" + get_line() + "] Z80:12cyc(branch), 6cyc(through), R800:5cyc(branch), 1cyc(through)" );	//	RET cond
        -: 3274:			}
       12: 3275:			this->log_data_dump();
       12: 3276:			log.push_back( "" );
        -: 3277:		}
       36: 3278:		return check_all_fixed();
        -: 3279:	}
        3: 3280:	put_error( "Illegal operand" );
        3: 3281:	return false;
        -: 3282:}
        -: 3283:
        -: 3284:// --------------------------------------------------------------------
        6: 3285:bool CZMA_PARSE_RETI::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3286:
        6: 3287:	update_flags( &info, p_last_line );
        6: 3288:	if( opecode( info, 0xED, 0x4D ) ) {
        -: 3289:		//	log
        3: 3290:		if( !this->is_analyze_phase ) {
        1: 3291:			log.push_back( "[\t" + get_line() + "] Z80:16cyc, R800:7cyc" );
        1: 3292:			this->log_data_dump();
        1: 3293:			log.push_back( "" );
        -: 3294:		}
        3: 3295:		return check_all_fixed();
        -: 3296:	}
        3: 3297:	put_error( "Illegal operand" );
        3: 3298:	return false;
        -: 3299:}
        -: 3300:
        -: 3301:// --------------------------------------------------------------------
        6: 3302:bool CZMA_PARSE_RETN::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3303:
        6: 3304:	update_flags( &info, p_last_line );
        6: 3305:	if( opecode( info, 0xED, 0x45 ) ) {
        -: 3306:		//	log
        3: 3307:		if( !this->is_analyze_phase ) {
        1: 3308:			log.push_back( "[\t" + get_line() + "] Z80:16cyc, R800:7cyc" );
        1: 3309:			this->log_data_dump();
        1: 3310:			log.push_back( "" );
        -: 3311:		}
        3: 3312:		return check_all_fixed();
        -: 3313:	}
        3: 3314:	put_error( "Illegal operand" );
        3: 3315:	return false;
        -: 3316:}
        -: 3317:
        -: 3318:// --------------------------------------------------------------------
       39: 3319:bool CZMA_PARSE_RST::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
       78: 3320:	CVALUE p;
        -: 3321:	int index;
       39: 3322:	update_flags( &info, p_last_line );
       39: 3323:	if( words.size() >= 2 ) {
       36: 3324:		index = this->expression( info, 1, p );
       36: 3325:		if( index == 0 ) {
        3: 3326:			put_error( "Illegal expression." );
        3: 3327:			return false;
        -: 3328:		}
       33: 3329:		if( p.type != CVALUE::CV_INTEGER ) {
        3: 3330:			put_error( "Illegal expression." );
        3: 3331:			return false;
        -: 3332:		}
       30: 3333:		if( index < (int)words.size() ) {
        3: 3334:			put_error( "Illegal operand." );
        3: 3335:			return false;
        -: 3336:		}
       27: 3337:		if( (p.i & ~0x38) != 0 ) {
        3: 3338:			put_error( std::string("Illegal restart address (") + std::to_string(p.i) + ")" );
        3: 3339:			return false;
        -: 3340:		}
       24: 3341:		if( !this->is_data_fixed ) {
        8: 3342:			this->is_data_fixed = true;
        8: 3343:			this->set_code_size( &info, 1 );
        8: 3344:			this->data.push_back( 0xC7 | p.i );
        -: 3345:		}
        -: 3346:		//	log
       24: 3347:		if( !this->is_analyze_phase ) {
        8: 3348:			log.push_back( "[\t" + get_line() + "] Z80:12cyc, R800:6 or 7cyc" );
        8: 3349:			this->log_data_dump();
        8: 3350:			log.push_back( "" );
        -: 3351:		}
       24: 3352:		return check_all_fixed();
        -: 3353:	}
        3: 3354:	put_error( "Illegal operand" );
        3: 3355:	return false;
        -: 3356:}
        -: 3357:
        -: 3358:// --------------------------------------------------------------------
     4722: 3359:bool CZMA_PARSE_NOP::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3360:
     4722: 3361:	update_flags( &info, p_last_line );
     4722: 3362:	if( opecode( info, 0x00 ) ) {
        -: 3363:		//	log
     4719: 3364:		if( !this->is_analyze_phase ) {
     1573: 3365:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );
     1573: 3366:			this->log_data_dump();
     1573: 3367:			log.push_back( "" );
        -: 3368:		}
     4719: 3369:		return check_all_fixed();
        -: 3370:	}
        3: 3371:	put_error( "Illegal operand" );
        3: 3372:	return false;
        -: 3373:}
        -: 3374:
        -: 3375:// --------------------------------------------------------------------
        6: 3376:bool CZMA_PARSE_HALT::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3377:
        6: 3378:	update_flags( &info, p_last_line );
        6: 3379:	if( opecode( info, 0x76 ) ) {
        -: 3380:		//	log
        3: 3381:		if( !this->is_analyze_phase ) {
        1: 3382:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:2cyc and wait interrupt" );
        1: 3383:			this->log_data_dump();
        1: 3384:			log.push_back( "" );
        -: 3385:		}
        3: 3386:		return check_all_fixed();
        -: 3387:	}
        3: 3388:	put_error( "Illegal operand" );
        3: 3389:	return false;
        -: 3390:}
        -: 3391:
        -: 3392:// --------------------------------------------------------------------
        6: 3393:bool CZMA_PARSE_DI::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3394:
        6: 3395:	update_flags( &info, p_last_line );
        6: 3396:	if( opecode( info, 0xF3 ) ) {
        -: 3397:		//	log
        3: 3398:		if( !this->is_analyze_phase ) {
        1: 3399:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:2cyc" );
        1: 3400:			this->log_data_dump();
        1: 3401:			log.push_back( "" );
        -: 3402:		}
        3: 3403:		return check_all_fixed();
        -: 3404:	}
        3: 3405:	put_error( "Illegal operand" );
        3: 3406:	return false;
        -: 3407:}
        -: 3408:
        -: 3409:// --------------------------------------------------------------------
        6: 3410:bool CZMA_PARSE_EI::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3411:
        6: 3412:	update_flags( &info, p_last_line );
        6: 3413:	if( opecode( info, 0xFB ) ) {
        -: 3414:		//	log
        3: 3415:		if( !this->is_analyze_phase ) {
        1: 3416:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );
        1: 3417:			this->log_data_dump();
        1: 3418:			log.push_back( "" );
        -: 3419:		}
        3: 3420:		return check_all_fixed();
        -: 3421:	}
        3: 3422:	put_error( "Illegal operand" );
        3: 3423:	return false;
        -: 3424:}
        -: 3425:
        -: 3426:// --------------------------------------------------------------------
        6: 3427:bool CZMA_PARSE_IM0::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3428:
        6: 3429:	update_flags( &info, p_last_line );
        6: 3430:	if( opecode( info, 0xED, 0x46 ) ) {
        -: 3431:		//	log
        3: 3432:		if( !this->is_analyze_phase ) {
        1: 3433:			log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:3cyc" );
        1: 3434:			this->log_data_dump();
        1: 3435:			log.push_back( "" );
        -: 3436:		}
        3: 3437:		return check_all_fixed();
        -: 3438:	}
        3: 3439:	put_error( "Illegal operand" );
        3: 3440:	return false;
        -: 3441:}
        -: 3442:
        -: 3443:// --------------------------------------------------------------------
        6: 3444:bool CZMA_PARSE_IM1::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3445:
        6: 3446:	update_flags( &info, p_last_line );
        6: 3447:	if( opecode( info, 0xED, 0x56 ) ) {
        -: 3448:		//	log
        3: 3449:		if( !this->is_analyze_phase ) {
        1: 3450:			log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:3cyc" );
        1: 3451:			this->log_data_dump();
        1: 3452:			log.push_back( "" );
        -: 3453:		}
        3: 3454:		return check_all_fixed();
        -: 3455:	}
        3: 3456:	put_error( "Illegal operand" );
        3: 3457:	return false;
        -: 3458:}
        -: 3459:
        -: 3460:// --------------------------------------------------------------------
        6: 3461:bool CZMA_PARSE_IM2::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3462:
        6: 3463:	update_flags( &info, p_last_line );
        6: 3464:	if( opecode( info, 0xED, 0x5E ) ) {
        -: 3465:		//	log
        3: 3466:		if( !this->is_analyze_phase ) {
        1: 3467:			log.push_back( "[\t" + get_line() + "] Z80:10cyc, R800:3cyc" );
        1: 3468:			this->log_data_dump();
        1: 3469:			log.push_back( "" );
        -: 3470:		}
        3: 3471:		return check_all_fixed();
        -: 3472:	}
        3: 3473:	put_error( "Illegal operand" );
        3: 3474:	return false;
        -: 3475:}
        -: 3476:
        -: 3477:// --------------------------------------------------------------------
       30: 3478:bool CZMA_PARSE_IN::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3479:
       30: 3480:	update_flags( &info, p_last_line );
       30: 3481:	if( opecode_ddd_c( info, 0xDB, 0xED, 0x40 ) ) {
        -: 3482:		//	log
       27: 3483:		if( !this->is_analyze_phase ) {
        9: 3484:			if( data[0] == 0xDB ) {
        1: 3485:				log.push_back( "[\t" + get_line() + "] Z80:12cyc, R800:10 or 9cyc" );		//	IN A,[n]
        -: 3486:			}
        -: 3487:			else {
        8: 3488:				log.push_back( "[\t" + get_line() + "] Z80:14cyc, R800:10 or 9cyc" );		//	IN A,[C]
        -: 3489:			}
        9: 3490:			this->log_data_dump();
        9: 3491:			log.push_back( "" );
        -: 3492:		}
       27: 3493:		return check_all_fixed();
        -: 3494:	}
        3: 3495:	put_error( "Illegal operand" );
        3: 3496:	return false;
        -: 3497:}
        -: 3498:
        -: 3499:// --------------------------------------------------------------------
        6: 3500:bool CZMA_PARSE_INI::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3501:
        6: 3502:	update_flags( &info, p_last_line );
        6: 3503:	if( opecode( info, 0xED, 0xA2 ) ) {
        -: 3504:		//	log
        3: 3505:		if( !this->is_analyze_phase ) {
        1: 3506:			log.push_back( "[\t" + get_line() + "] Z80:18cyc, R800:12 or 11cyc" );
        1: 3507:			this->log_data_dump();
        1: 3508:			log.push_back( "" );
        -: 3509:		}
        3: 3510:		return check_all_fixed();
        -: 3511:	}
        3: 3512:	put_error( "Illegal operand" );
        3: 3513:	return false;
        -: 3514:}
        -: 3515:
        -: 3516:// --------------------------------------------------------------------
        6: 3517:bool CZMA_PARSE_INIR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3518:
        6: 3519:	update_flags( &info, p_last_line );
        6: 3520:	if( opecode( info, 0xED, 0xB2 ) ) {
        -: 3521:		//	log
        3: 3522:		if( !this->is_analyze_phase ) {
        1: 3523:			log.push_back( "[\t" + get_line() + "] Z80:23 or 18cyc, R800:? or 12 or 11cyc" );
        1: 3524:			this->log_data_dump();
        1: 3525:			log.push_back( "" );
        -: 3526:		}
        3: 3527:		return check_all_fixed();
        -: 3528:	}
        3: 3529:	put_error( "Illegal operand" );
        3: 3530:	return false;
        -: 3531:}
        -: 3532:
        -: 3533:// --------------------------------------------------------------------
        6: 3534:bool CZMA_PARSE_IND::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3535:
        6: 3536:	update_flags( &info, p_last_line );
        6: 3537:	if( opecode( info, 0xED, 0xAA ) ) {
        -: 3538:		//	log
        3: 3539:		if( !this->is_analyze_phase ) {
        1: 3540:			log.push_back( "[\t" + get_line() + "] Z80:18cyc, R800:12 or 11cyc" );
        1: 3541:			this->log_data_dump();
        1: 3542:			log.push_back( "" );
        -: 3543:		}
        3: 3544:		return check_all_fixed();
        -: 3545:	}
        3: 3546:	put_error( "Illegal operand" );
        3: 3547:	return false;
        -: 3548:}
        -: 3549:
        -: 3550:// --------------------------------------------------------------------
        6: 3551:bool CZMA_PARSE_INDR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3552:
        6: 3553:	update_flags( &info, p_last_line );
        6: 3554:	if( opecode( info, 0xED, 0xBA ) ) {
        -: 3555:		//	log
        3: 3556:		if( !this->is_analyze_phase ) {
        1: 3557:			log.push_back( "[\t" + get_line() + "] Z80:23 or 18cyc, R800:? or 12 or 11cyc" );
        1: 3558:			this->log_data_dump();
        1: 3559:			log.push_back( "" );
        -: 3560:		}
        3: 3561:		return check_all_fixed();
        -: 3562:	}
        3: 3563:	put_error( "Illegal operand" );
        3: 3564:	return false;
        -: 3565:}
        -: 3566:
        -: 3567:// --------------------------------------------------------------------
       30: 3568:bool CZMA_PARSE_OUT::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3569:
       30: 3570:	update_flags( &info, p_last_line );
       30: 3571:	if( opecode_c_sss( info, 0xD3, 0xED, 0x41 ) ) {
        -: 3572:		//	log
       27: 3573:		if( !this->is_analyze_phase ) {
        9: 3574:			if( data[0] == 0xD3 ) {
        1: 3575:				log.push_back( "[\t" + get_line() + "] Z80:12cyc, R800:10 or 9cyc" );	//	OUT [n], A
        -: 3576:			}
        -: 3577:			else {
        8: 3578:				log.push_back( "[\t" + get_line() + "] Z80:14cyc, R800:10 or 9cyc" );	//	OUT	[C], A
        -: 3579:			}
        9: 3580:			this->log_data_dump();
        9: 3581:			log.push_back( "" );
        -: 3582:		}
       27: 3583:		return check_all_fixed();
        -: 3584:	}
        3: 3585:	put_error( "Illegal operand" );
        3: 3586:	return false;
        -: 3587:}
        -: 3588:
        -: 3589:// --------------------------------------------------------------------
        6: 3590:bool CZMA_PARSE_OUTI::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3591:
        6: 3592:	update_flags( &info, p_last_line );
        6: 3593:	if( opecode( info, 0xED, 0xA3 ) ) {
        -: 3594:		//	log
        3: 3595:		if( !this->is_analyze_phase ) {
        1: 3596:			log.push_back( "[\t" + get_line() + "] Z80:18cyc, R800:12 or 11cyc" );
        1: 3597:			this->log_data_dump();
        1: 3598:			log.push_back( "" );
        -: 3599:		}
        3: 3600:		return check_all_fixed();
        -: 3601:	}
        3: 3602:	put_error( "Illegal operand" );
        3: 3603:	return false;
        -: 3604:}
        -: 3605:
        -: 3606:// --------------------------------------------------------------------
        6: 3607:bool CZMA_PARSE_OTIR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3608:
        6: 3609:	update_flags( &info, p_last_line );
        6: 3610:	if( opecode( info, 0xED, 0xB3 ) ) {
        -: 3611:		//	log
        3: 3612:		if( !this->is_analyze_phase ) {
        1: 3613:			log.push_back( "[\t" + get_line() + "] Z80:23 or 18cyc, R800:? or 12 or 11cyc" );
        1: 3614:			this->log_data_dump();
        1: 3615:			log.push_back( "" );
        -: 3616:		}
        3: 3617:		return check_all_fixed();
        -: 3618:	}
        3: 3619:	put_error( "Illegal operand" );
        3: 3620:	return false;
        -: 3621:}
        -: 3622:
        -: 3623:// --------------------------------------------------------------------
        6: 3624:bool CZMA_PARSE_OUTD::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3625:
        6: 3626:	update_flags( &info, p_last_line );
        6: 3627:	if( opecode( info, 0xED, 0xAB ) ) {
        -: 3628:		//	log
        3: 3629:		if( !this->is_analyze_phase ) {
        1: 3630:			log.push_back( "[\t" + get_line() + "] Z80:18cyc, R800:12 or 11cyc" );
        1: 3631:			this->log_data_dump();
        1: 3632:			log.push_back( "" );
        -: 3633:		}
        3: 3634:		return check_all_fixed();
        -: 3635:	}
        3: 3636:	put_error( "Illegal operand" );
        3: 3637:	return false;
        -: 3638:}
        -: 3639:
        -: 3640:// --------------------------------------------------------------------
        6: 3641:bool CZMA_PARSE_OTDR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3642:
        6: 3643:	update_flags( &info, p_last_line );
        6: 3644:	if( opecode( info, 0xED, 0xBB ) ) {
        -: 3645:		//	log
        3: 3646:		if( !this->is_analyze_phase ) {
        1: 3647:			log.push_back( "[\t" + get_line() + "] Z80:23 or 18cyc, R800:? or 12 or 11cyc" );
        1: 3648:			this->log_data_dump();
        1: 3649:			log.push_back( "" );
        -: 3650:		}
        3: 3651:		return check_all_fixed();
        -: 3652:	}
        3: 3653:	put_error( "Illegal operand" );
        3: 3654:	return false;
        -: 3655:}
        -: 3656:
        -: 3657:// --------------------------------------------------------------------
        6: 3658:bool CZMA_PARSE_DAA::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3659:
        6: 3660:	update_flags( &info, p_last_line );
        6: 3661:	if( opecode( info, 0x27 ) ) {
        -: 3662:		//	log
        3: 3663:		if( !this->is_analyze_phase ) {
        1: 3664:			log.push_back( "[\t" + get_line() + "] Z80:5cyc, R800:1cyc" );
        1: 3665:			this->log_data_dump();
        1: 3666:			log.push_back( "" );
        -: 3667:		}
        3: 3668:		return check_all_fixed();
        -: 3669:	}
        3: 3670:	put_error( "Illegal operand" );
        3: 3671:	return false;
        -: 3672:}
        -: 3673:
        -: 3674:// --------------------------------------------------------------------
        6: 3675:bool CZMA_PARSE_RLD::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3676:
        6: 3677:	update_flags( &info, p_last_line );
        6: 3678:	if( opecode( info, 0xED, 0x6F ) ) {
        -: 3679:		//	log
        3: 3680:		if( !this->is_analyze_phase ) {
        1: 3681:			log.push_back( "[\t" + get_line() + "] Z80:20cyc, R800:8cyc" );
        1: 3682:			this->log_data_dump();
        1: 3683:			log.push_back( "" );
        -: 3684:		}
        3: 3685:		return check_all_fixed();
        -: 3686:	}
        3: 3687:	put_error( "Illegal operand" );
        3: 3688:	return false;
        -: 3689:}
        -: 3690:
        -: 3691:// --------------------------------------------------------------------
        6: 3692:bool CZMA_PARSE_RRD::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3693:
        6: 3694:	update_flags( &info, p_last_line );
        6: 3695:	if( opecode( info, 0xED, 0x67 ) ) {
        -: 3696:		//	log
        3: 3697:		if( !this->is_analyze_phase ) {
        1: 3698:			log.push_back( "[\t" + get_line() + "] Z80:20cyc, R800:8cyc" );
        1: 3699:			this->log_data_dump();
        1: 3700:			log.push_back( "" );
        -: 3701:		}
        3: 3702:		return check_all_fixed();
        -: 3703:	}
        3: 3704:	put_error( "Illegal operand" );
        3: 3705:	return false;
        -: 3706:}
        -: 3707:
        -: 3708:// --------------------------------------------------------------------
       15: 3709:bool CZMA_PARSE_MULUB::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3710:
       15: 3711:	update_flags( &info, p_last_line );
       15: 3712:	if( opecode_mulub( info, 0xED, 0xC1 ) ) {
        -: 3713:		//	log
       12: 3714:		if( !this->is_analyze_phase ) {
        4: 3715:			log.push_back( "[\t" + get_line() + "] Z80:--, R800:14cyc" );
        4: 3716:			this->log_data_dump();
        4: 3717:			log.push_back( "" );
        -: 3718:		}
       12: 3719:		return check_all_fixed();
        -: 3720:	}
        3: 3721:	put_error( "Illegal operand" );
        3: 3722:	return false;
        -: 3723:}
        -: 3724:
        -: 3725:// --------------------------------------------------------------------
        9: 3726:bool CZMA_PARSE_MULUW::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3727:
        9: 3728:	update_flags( &info, p_last_line );
        9: 3729:	if( opecode_muluw( info ) ) {
        -: 3730:		//	log
        6: 3731:		if( !this->is_analyze_phase ) {
        2: 3732:			log.push_back( "[\t" + get_line() + "] Z80:--, R800:36cyc" );
        2: 3733:			this->log_data_dump();
        2: 3734:			log.push_back( "" );
        -: 3735:		}
        6: 3736:		return check_all_fixed();
        -: 3737:	}
        3: 3738:	put_error( "Illegal operand" );
        3: 3739:	return false;
        -: 3740:}
        -: 3741:
        -: 3742:// --------------------------------------------------------------------
       12: 3743:bool CZMA_PARSE_ERROR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
        -: 3744:
       12: 3745:	put_error( "Illegal command" );
       12: 3746:	return false;
        -: 3747:}
        -: 3748:
        -: 3749:// --------------------------------------------------------------------
       21: 3750:bool CZMA_PARSE_USER_ERROR::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
       42: 3751:	CVALUE v;
        -: 3752:
       21: 3753:	set_code_size( &info, 0 );
       21: 3754:	update_flags( &info, p_last_line );
       21: 3755:	if( words.size() == 1 ) {
        3: 3756:		put_error( "User error" );
        3: 3757:		return false;
        -: 3758:	}
       18: 3759:	if( this->expression( info, 1, v ) == 0 ) {
        6: 3760:		put_error( "Illegal parameter in ERROR." );
        -: 3761:	}
       18: 3762:	if( v.type == CVALUE::CV_STRING ) {
        9: 3763:		put_error( v.s );
        -: 3764:	}
        9: 3765:	else if( v.type == CVALUE::CV_INTEGER ) {
        3: 3766:		put_error( std::to_string( v.i ) );
        -: 3767:	}
        -: 3768:	else {
        6: 3769:		put_error( "Illegal parameter in ERROR." );
        -: 3770:	}
       18: 3771:	return false;
        -: 3772:}
        -: 3773:
        -: 3774:// --------------------------------------------------------------------
      201: 3775:bool CZMA_PARSE_USER_MESSAGE::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
      402: 3776:	CVALUE v;
        -: 3777:
      201: 3778:	set_code_size( &info, 0 );
      201: 3779:	update_flags( &info, p_last_line );
      201: 3780:	if( words.size() == 1 ) {
        3: 3781:		put_error( "Message not found in MESSAGE." );
        3: 3782:		return false;
        -: 3783:	}
      198: 3784:	if( this->expression( info, 1, v ) == 0 ) {
       60: 3785:		put_error( "Illegal parameter in MESSAGE." );
       60: 3786:		return false;
        -: 3787:	}
      138: 3788:	if( v.type == CVALUE::CV_INTEGER ) {
        3: 3789:		v.s = std::to_string( v.i );
        -: 3790:	}
        -: 3791:	//	log
      138: 3792:	if( !this->is_analyze_phase ) {
       39: 3793:		put_message( v.s );
        -: 3794:	}
      138: 3795:	return true;
        -: 3796:}
        -: 3797:
        -: 3798:// --------------------------------------------------------------------
       15: 3799:bool CZMA_PARSE_ADD_INCLUDE_PATH::process( CZMA_INFORMATION& info, CZMA_PARSE* p_last_line ) {
       30: 3800:	CVALUE v;
       15: 3801:	bool is_loaded = false;
        -: 3802:
       15: 3803:	set_code_size( &info, 0 );
       15: 3804:	update_flags( &info, p_last_line );
       15: 3805:	if( words.size() == 1 ) {
        3: 3806:		put_error( "Path not found in ADD_INCLUDE_PATH." );
        3: 3807:		return false;
        -: 3808:	}
       12: 3809:	if( this->expression( info, 1, v ) == 0 ) {
        3: 3810:		put_error( "Illegal parameter in ADD_INCLUDE_PATH." );
        3: 3811:		return false;
        -: 3812:	}
        9: 3813:	if( v.type == CVALUE::CV_INTEGER ) {
        3: 3814:		v.s = std::to_string( v.i );
        -: 3815:	}
       38: 3816:	for( auto s : info.include_path ) {
       29: 3817:		if( s == v.s ) {
        6: 3818:			is_loaded = true;
        -: 3819:		}
        -: 3820:	}
        9: 3821:	if( !is_loaded ) {
        3: 3822:		info.include_path.push_back( v.s );
        -: 3823:	}
        -: 3824:	//	log
        9: 3825:	if( !this->is_analyze_phase ) {
        3: 3826:		log.push_back( "[\t" + get_line() + "]" );
        3: 3827:		log.push_back( "\tAdd include path: " + v.s );
        -: 3828:	}
        9: 3829:	return true;
      168: 3830:}
