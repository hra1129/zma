        -:    0:Source:../zma_parse_process.cpp
        -:    0:Programs:106
        -:    1:// --------------------------------------------------------------------
        -:    2://	Z80 Macro Assembler parse
        -:    3:// ====================================================================
        -:    4://	2019/05/04	t.hara
        -:    5:// --------------------------------------------------------------------
        -:    6:
        -:    7:#include "zma_parse.hpp"
        -:    8:#include "zma_text.hpp"
        -:    9:#include "zma_parse_process.hpp"
        -:   10:#include <string>
        -:   11:#include <cctype>
        -:   12:#include <iostream>
        -:   13:#include <fstream>
        -:   14:#include <sstream>
        -:   15:#include <algorithm>
        -:   16:
        -:   17:// --------------------------------------------------------------------
        -:   18:int CZMA_PARSE::number_of_error = 0;
        -:   19:
        -:   20:// --------------------------------------------------------------------
      156:   21:static std::map< std::string, CZMA_COMMAND_TYPE > command_list = {
        -:   22:	{ "ALIGN", CZMA_COMMAND_TYPE::CZMA_ALIGN },
        -:   23:	{ "SPACE", CZMA_COMMAND_TYPE::CZMA_SPACE },
        -:   24:	{ "REPEAT", CZMA_COMMAND_TYPE::CZMA_REPEAT },
        -:   25:	{ "ENDR", CZMA_COMMAND_TYPE::CZMA_ENDR },
        -:   26:	{ "ENDM", CZMA_COMMAND_TYPE::CZMA_ENDM },
        -:   27:	{ "IF", CZMA_COMMAND_TYPE::CZMA_IF },
        -:   28:	{ "ELSEIF", CZMA_COMMAND_TYPE::CZMA_ELSEIF },
        -:   29:	{ "ELSE", CZMA_COMMAND_TYPE::CZMA_ELSE },
        -:   30:	{ "ENDIF", CZMA_COMMAND_TYPE::CZMA_ENDIF },
        -:   31:	{ "ORG", CZMA_COMMAND_TYPE::CZMA_ORG },
        -:   32:	{ "INCLUDE", CZMA_COMMAND_TYPE::CZMA_INCLUDE },
        -:   33:	{ "ADD_INCLUDE_PATH", CZMA_COMMAND_TYPE::CZMA_ADD_INCLUDE_PATH },
        -:   34:	{ "ERROR", CZMA_COMMAND_TYPE::CZMA_USER_ERROR },
        -:   35:	{ "MESSAGE", CZMA_COMMAND_TYPE::CZMA_USER_MESSAGE },
        -:   36:	{ "SCOPE", CZMA_COMMAND_TYPE::CZMA_SCOPE },
        -:   37:	{ "ENDSCOPE", CZMA_COMMAND_TYPE::CZMA_ENDSCOPE },
        -:   38:	{ "BINARY_LINK", CZMA_COMMAND_TYPE::CZMA_BINARY_LINK },
        -:   39:	{ "DEFB", CZMA_COMMAND_TYPE::CZMA_DEFB },
        -:   40:	{ "DEFW", CZMA_COMMAND_TYPE::CZMA_DEFW },
        -:   41:	{ "DEFD", CZMA_COMMAND_TYPE::CZMA_DEFD },
        -:   42:	{ "DEFS", CZMA_COMMAND_TYPE::CZMA_DEFS },
        -:   43:	{ "DB", CZMA_COMMAND_TYPE::CZMA_DEFB },
        -:   44:	{ "DW", CZMA_COMMAND_TYPE::CZMA_DEFW },
        -:   45:	{ "DD", CZMA_COMMAND_TYPE::CZMA_DEFD },
        -:   46:	{ "DS", CZMA_COMMAND_TYPE::CZMA_DEFS },
        -:   47:	{ "LD", CZMA_COMMAND_TYPE::CZMA_LD },
        -:   48:	{ "LDI", CZMA_COMMAND_TYPE::CZMA_LDI },
        -:   49:	{ "LDIR", CZMA_COMMAND_TYPE::CZMA_LDIR },
        -:   50:	{ "LDD", CZMA_COMMAND_TYPE::CZMA_LDD },
        -:   51:	{ "LDDR", CZMA_COMMAND_TYPE::CZMA_LDDR },
        -:   52:	{ "EX", CZMA_COMMAND_TYPE::CZMA_EX },
        -:   53:	{ "EXX", CZMA_COMMAND_TYPE::CZMA_EXX },
        -:   54:	{ "PUSH", CZMA_COMMAND_TYPE::CZMA_PUSH },
        -:   55:	{ "POP", CZMA_COMMAND_TYPE::CZMA_POP },
        -:   56:	{ "RLCA", CZMA_COMMAND_TYPE::CZMA_RLCA },
        -:   57:	{ "RLA", CZMA_COMMAND_TYPE::CZMA_RLA },
        -:   58:	{ "RLC", CZMA_COMMAND_TYPE::CZMA_RLC },
        -:   59:	{ "RL", CZMA_COMMAND_TYPE::CZMA_RL },
        -:   60:	{ "RRCA", CZMA_COMMAND_TYPE::CZMA_RRCA },
        -:   61:	{ "RRA", CZMA_COMMAND_TYPE::CZMA_RRA },
        -:   62:	{ "RRC", CZMA_COMMAND_TYPE::CZMA_RRC },
        -:   63:	{ "RR", CZMA_COMMAND_TYPE::CZMA_RR },
        -:   64:	{ "SLA", CZMA_COMMAND_TYPE::CZMA_SLA },
        -:   65:	{ "SRA", CZMA_COMMAND_TYPE::CZMA_SRA },
        -:   66:	{ "SRL", CZMA_COMMAND_TYPE::CZMA_SRL },
        -:   67:	{ "SLL", CZMA_COMMAND_TYPE::CZMA_SLL },
        -:   68:	{ "ADD", CZMA_COMMAND_TYPE::CZMA_ADD },
        -:   69:	{ "ADC", CZMA_COMMAND_TYPE::CZMA_ADC },
        -:   70:	{ "INC", CZMA_COMMAND_TYPE::CZMA_INC },
        -:   71:	{ "SUB", CZMA_COMMAND_TYPE::CZMA_SUB },
        -:   72:	{ "SBC", CZMA_COMMAND_TYPE::CZMA_SBC },
        -:   73:	{ "DEC", CZMA_COMMAND_TYPE::CZMA_DEC },
        -:   74:	{ "AND", CZMA_COMMAND_TYPE::CZMA_AND },
        -:   75:	{ "OR", CZMA_COMMAND_TYPE::CZMA_OR },
        -:   76:	{ "XOR", CZMA_COMMAND_TYPE::CZMA_XOR },
        -:   77:	{ "CPL", CZMA_COMMAND_TYPE::CZMA_CPL },
        -:   78:	{ "NEG", CZMA_COMMAND_TYPE::CZMA_NEG },
        -:   79:	{ "CCF", CZMA_COMMAND_TYPE::CZMA_CCF },
        -:   80:	{ "SCF", CZMA_COMMAND_TYPE::CZMA_SCF },
        -:   81:	{ "BIT", CZMA_COMMAND_TYPE::CZMA_BIT },
        -:   82:	{ "RES", CZMA_COMMAND_TYPE::CZMA_RES },
        -:   83:	{ "SET", CZMA_COMMAND_TYPE::CZMA_SET },
        -:   84:	{ "CPI", CZMA_COMMAND_TYPE::CZMA_CPI },
        -:   85:	{ "CPIR", CZMA_COMMAND_TYPE::CZMA_CPIR },
        -:   86:	{ "CPD", CZMA_COMMAND_TYPE::CZMA_CPD },
        -:   87:	{ "CPDR", CZMA_COMMAND_TYPE::CZMA_CPDR },
        -:   88:	{ "CP", CZMA_COMMAND_TYPE::CZMA_CP },
        -:   89:	{ "JP", CZMA_COMMAND_TYPE::CZMA_JP },
        -:   90:	{ "JR", CZMA_COMMAND_TYPE::CZMA_JR },
        -:   91:	{ "DJNZ", CZMA_COMMAND_TYPE::CZMA_DJNZ },
        -:   92:	{ "CALL", CZMA_COMMAND_TYPE::CZMA_CALL },
        -:   93:	{ "RET", CZMA_COMMAND_TYPE::CZMA_RET },
        -:   94:	{ "RETI", CZMA_COMMAND_TYPE::CZMA_RETI },
        -:   95:	{ "RETN", CZMA_COMMAND_TYPE::CZMA_RETN },
        -:   96:	{ "RST", CZMA_COMMAND_TYPE::CZMA_RST },
        -:   97:	{ "NOP", CZMA_COMMAND_TYPE::CZMA_NOP },
        -:   98:	{ "HALT", CZMA_COMMAND_TYPE::CZMA_HALT },
        -:   99:	{ "DI", CZMA_COMMAND_TYPE::CZMA_DI },
        -:  100:	{ "EI", CZMA_COMMAND_TYPE::CZMA_EI },
        -:  101:	{ "IM0", CZMA_COMMAND_TYPE::CZMA_IM0 },
        -:  102:	{ "IM1", CZMA_COMMAND_TYPE::CZMA_IM1 },
        -:  103:	{ "IM2", CZMA_COMMAND_TYPE::CZMA_IM2 },
        -:  104:	{ "IN", CZMA_COMMAND_TYPE::CZMA_IN },
        -:  105:	{ "INI", CZMA_COMMAND_TYPE::CZMA_INI },
        -:  106:	{ "INIR", CZMA_COMMAND_TYPE::CZMA_INIR },
        -:  107:	{ "IND", CZMA_COMMAND_TYPE::CZMA_IND },
        -:  108:	{ "INDR", CZMA_COMMAND_TYPE::CZMA_INDR },
        -:  109:	{ "OUT", CZMA_COMMAND_TYPE::CZMA_OUT },
        -:  110:	{ "OUTI", CZMA_COMMAND_TYPE::CZMA_OUTI },
        -:  111:	{ "OTIR", CZMA_COMMAND_TYPE::CZMA_OTIR },
        -:  112:	{ "OUTD", CZMA_COMMAND_TYPE::CZMA_OUTD },
        -:  113:	{ "OTDR", CZMA_COMMAND_TYPE::CZMA_OTDR },
        -:  114:	{ "DAA", CZMA_COMMAND_TYPE::CZMA_DAA },
        -:  115:	{ "RLD", CZMA_COMMAND_TYPE::CZMA_RLD },
        -:  116:	{ "RRD", CZMA_COMMAND_TYPE::CZMA_RRD },
        -:  117:	{ "MULUB", CZMA_COMMAND_TYPE::CZMA_MULUB },
        -:  118:	{ "MULUW", CZMA_COMMAND_TYPE::CZMA_MULUW },
        -:  119:	{ "CHG_CHAR_SET", CZMA_COMMAND_TYPE::CZMA_CHG_CHAR_SET },
        -:  120:	{ "MAPPING_CHAR", CZMA_COMMAND_TYPE::CZMA_MAPPING_CHAR },
        -:  121:};
        -:  122:
        -:  123:// --------------------------------------------------------------------
        -:  124:#define OPE_CASE( operation )																			\
        -:  125:	case CZMA_COMMAND_TYPE::CZMA_##operation:																			\
        -:  126:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_##operation( words, p_file_name, line_no ))
        -:  127:
        -:  128:// --------------------------------------------------------------------
    15293:  129:CZMA_PARSE* CZMA_PARSE::create( CZMA_INFORMATION& info, std::vector<std::string> &words, const char* p_file_name, int line_no ) {
        -:  130:
    30586:  131:	if( words.size() == 0 ) {
    12866:  132:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_BLANK( words, p_file_name, line_no ));
        -:  133:	}
    10207:  134:	if( words.size() == 2 && words[1] == ":" ) {
      112:  135:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_LABEL( words, p_file_name, line_no ));
        -:  136:	}
    10095:  137:	if( words.size() == 2 && words[1] == "::" ) {
       18:  138:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_GLOBAL_LABEL( words, p_file_name, line_no ));
        -:  139:	}
    12812:  140:	if( words.size() >= 3 && words[1] == "=" ) {
       36:  141:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_SYMBOL( words, p_file_name, line_no ));
        -:  142:	}
    16765:  143:	if( words.size() >= 3 && (words[1] == ":=" || words[ 1 ] == "EQU") ) {
       24:  144:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_GLOBAL_SYMBOL( words, p_file_name, line_no ));
        -:  145:	}
    14034:  146:	if( words.size() >= 2 && words[1] == "MACRO" ) {
       31:  147:		info.macro_list[words[0]] = nullptr;
       62:  148:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_MACRO( words, p_file_name, line_no ));
        -:  149:	}
        -:  150:	if( words.size() >= 1 && info.macro_list.count( words[0] ) ) {
      152:  151:		return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_MACRO_INS( words, p_file_name, line_no ));
        -:  152:	}
     8658:  153:	switch( command_list[words[0]] ) {
       60:  154:		OPE_CASE( ORG );
       20:  155:		OPE_CASE( INCLUDE );
       10:  156:		OPE_CASE( ADD_INCLUDE_PATH );
        4:  157:		OPE_CASE( ALIGN );
       14:  158:		OPE_CASE( SPACE );
       25:  159:		OPE_CASE( REPEAT );
       70:  160:		OPE_CASE( ENDR );
       60:  161:		OPE_CASE( ENDM );
       63:  162:		OPE_CASE( IF );
       58:  163:		OPE_CASE( ELSEIF );
       86:  164:		OPE_CASE( ELSE );
      140:  165:		OPE_CASE( ENDIF );
       58:  166:		OPE_CASE( USER_ERROR );
      186:  167:		OPE_CASE( USER_MESSAGE );
       42:  168:		OPE_CASE( SCOPE );
       30:  169:		OPE_CASE( ENDSCOPE );
        2:  170:		OPE_CASE( BINARY_LINK );
     4880:  171:		OPE_CASE( DEFB );
      490:  172:		OPE_CASE( DEFW );
       20:  173:		OPE_CASE( DEFD );
       32:  174:		case CZMA_COMMAND_TYPE::CZMA_DEFS:
       32:  175:			if( info.defs_is_space ){
        6:  176:				return reinterpret_cast<CZMA_PARSE *> ( new CZMA_PARSE_SPACE( words, p_file_name, line_no ) );
        -:  177:			}
       58:  178:			return reinterpret_cast<CZMA_PARSE *> ( new CZMA_PARSE_DEFS( words, p_file_name, line_no ) );
     1340:  179:		OPE_CASE( LD );
       26:  180:		OPE_CASE( PUSH );
       26:  181:		OPE_CASE( POP );
       24:  182:		OPE_CASE( EX );
        6:  183:		OPE_CASE( EXX );
        6:  184:		OPE_CASE( LDI );
        6:  185:		OPE_CASE( LDIR );
        6:  186:		OPE_CASE( LDD );
        6:  187:		OPE_CASE( LDDR );
        6:  188:		OPE_CASE( RLCA );
        6:  189:		OPE_CASE( RLA );
       42:  190:		OPE_CASE( RLC );
       44:  191:		OPE_CASE( RL );
        6:  192:		OPE_CASE( RRCA );
        6:  193:		OPE_CASE( RRA );
       42:  194:		OPE_CASE( RRC );
       44:  195:		OPE_CASE( RR );
       42:  196:		OPE_CASE( SLA );
       44:  197:		OPE_CASE( SRA );
       44:  198:		OPE_CASE( SRL );
        2:  199:		OPE_CASE( SLL );
      142:  200:		OPE_CASE( ADD );
       78:  201:		OPE_CASE( ADC );
      128:  202:		OPE_CASE( INC );
      122:  203:		OPE_CASE( SUB );
       78:  204:		OPE_CASE( SBC );
       82:  205:		OPE_CASE( DEC );
      126:  206:		OPE_CASE( AND );
      128:  207:		OPE_CASE( OR );
      128:  208:		OPE_CASE( XOR );
        6:  209:		OPE_CASE( CPL );
        6:  210:		OPE_CASE( NEG );
        6:  211:		OPE_CASE( CCF );
        6:  212:		OPE_CASE( SCF );
      324:  213:		OPE_CASE( BIT );
      324:  214:		OPE_CASE( RES );
      324:  215:		OPE_CASE( SET );
        6:  216:		OPE_CASE( CPI );
        6:  217:		OPE_CASE( CPIR );
        6:  218:		OPE_CASE( CPD );
        6:  219:		OPE_CASE( CPDR );
      134:  220:		OPE_CASE( CP );
       80:  221:		OPE_CASE( JP );
       58:  222:		OPE_CASE( JR );
       12:  223:		OPE_CASE( DJNZ );
       54:  224:		OPE_CASE( CALL );
       48:  225:		OPE_CASE( RET );
        6:  226:		OPE_CASE( RETI );
        6:  227:		OPE_CASE( RETN );
       42:  228:		OPE_CASE( RST );
     6296:  229:		OPE_CASE( NOP );
        6:  230:		OPE_CASE( HALT );
        6:  231:		OPE_CASE( EI );
        6:  232:		OPE_CASE( DI );
        6:  233:		OPE_CASE( IM0 );
        6:  234:		OPE_CASE( IM1 );
        6:  235:		OPE_CASE( IM2 );
       36:  236:		OPE_CASE( IN );
        6:  237:		OPE_CASE( INI );
        6:  238:		OPE_CASE( INIR );
        6:  239:		OPE_CASE( IND );
        6:  240:		OPE_CASE( INDR );
       52:  241:		OPE_CASE( OUT );
        6:  242:		OPE_CASE( OUTI );
        6:  243:		OPE_CASE( OTIR );
        6:  244:		OPE_CASE( OUTD );
        6:  245:		OPE_CASE( OTDR );
        6:  246:		OPE_CASE( DAA );
        6:  247:		OPE_CASE( RLD );
        6:  248:		OPE_CASE( RRD );
       18:  249:		OPE_CASE( MULUB );
       10:  250:		OPE_CASE( MULUW );
        6:  251:		OPE_CASE( CHG_CHAR_SET );
        8:  252:		OPE_CASE( MAPPING_CHAR );
        -:  253:	default:
        -:  254:		break;
        -:  255:	}
       52:  256:	return reinterpret_cast<CZMA_PARSE*> (new CZMA_PARSE_ERROR( words, p_file_name, line_no ));
        -:  257:}
        -:  258:
        -:  259:// --------------------------------------------------------------------
    #####:  260:void CZMA_PARSE::log_data_dump( void ) {
        -:  261:	int address, count;
    #####:  262:	std::stringstream line;
    #####:  263:	address = this->get_code_address();
        -:  264:	count = 0;
    #####:  265:	line.str("");
    #####:  266:	for( auto d : data ) {
    #####:  267:		if( count == 0 ) {
    #####:  268:			line << std::hex << std::setw( 6 ) << std::setfill( '0' ) << address << ":";
        -:  269:		}
    #####:  270:		line << " " << std::hex << std::setw( 2 ) << std::setfill( '0' ) << (int)d;
    #####:  271:		address++;
    #####:  272:		count++;
    #####:  273:		if( count == 8 ) {
    #####:  274:			log.push_back( line.str() );
    #####:  275:			line.str( "" );
        -:  276:			count = 0;
        -:  277:		}
        -:  278:	}
    #####:  279:	if( count != 0 ) {
    #####:  280:		log.push_back( line.str() );
        -:  281:	}
    #####:  282:}
        -:  283:
        -:  284:// --------------------------------------------------------------------
     8370:  285:std::string CZMA_PARSE::get_line( void ) {
        -:  286:	std::string r, ss;
        -:  287:
        -:  288:	r = "";
    38979:  289:	for( auto &s : words ) {
    61218:  290:		if( s.size() > 0 && (s[0] == '\"' || s[0] == '\'') ){
      114:  291:			ss = s[ 0 ];
     1210:  292:			for( int i = 1; i < (int)s.size(); i++ ) {
     1096:  293:				switch( s[i] ) {
    #####:  294:				case '\a':	ss = ss + "\\a";	break;
    #####:  295:				case '\b':	ss = ss + "\\b";	break;
    #####:  296:				case '\f':	ss = ss + "\\f";	break;
    #####:  297:				case '\n':	ss = ss + "\\n";	break;
    #####:  298:				case '\r':	ss = ss + "\\r";	break;
    #####:  299:				case '\t':	ss = ss + "\\t";	break;
        2:  300:				case '\\':	ss = ss + "\\\\";	break;
    #####:  301:				case '\'':	ss = ss + "\\'";	break;
    #####:  302:				case '\"':	ss = ss + "\\\"";	break;
     1094:  303:				default:	ss = ss + s[i];		break;
        -:  304:				}
        -:  305:			}
      228:  306:			ss = ss + s[0];
        -:  307:		}
        -:  308:		else {
        -:  309:			ss = s;
        -:  310:		}
    30609:  311:		if( r == "" ) {
        -:  312:			r = ss;
        -:  313:		}
    22239:  314:		else if( ss == "," ){
    15234:  315:			r = r + ss;
        -:  316:		}
    14622:  317:		else if( ss[ 0 ] == '0' && ss[ 1 ] == 'X' ){
     6030:  318:			ss[ 1 ] = 'x';
    18090:  319:			r = r + " " + ss;
        -:  320:		}
    11495:  321:		else if( ss[ 0 ] == '0' && ss[ 1 ] == 'B' ){
        3:  322:			ss[ 1 ] = 'b';
        9:  323:			r = r + " " + ss;
        -:  324:		}
        -:  325:		else {
    34356:  326:			r = r + " " + ss;
        -:  327:		}
        -:  328:	}
     8370:  329:	return r;
      234:  330:}
