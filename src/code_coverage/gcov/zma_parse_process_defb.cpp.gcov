        -:    0:Source:../sub/zma_parse_process_defb.cpp
        -:    0:Programs:103
        -:    1:// --------------------------------------------------------------------
        -:    2://	Z80 Macro Assembler parse
        -:    3:// ====================================================================
        -:    4://	2019/05/04	t.hara
        -:    5:// --------------------------------------------------------------------
        -:    6:
        -:    7:#include "zma_parse.hpp"
        -:    8:#include "zma_text.hpp"
        -:    9:#include "zma_parse_process.hpp"
        -:   10:#include <string>
        -:   11:#include <cctype>
        -:   12:#include <iostream>
        -:   13:#include <fstream>
        -:   14:#include <sstream>
        -:   15:#include <algorithm>
        -:   16:
        -:   17:// --------------------------------------------------------------------
     2966:   18:bool CZMA_PARSE_DEFB::process( CZMA_INFORMATION &info, CZMA_PARSE *p_last_line ){
        -:   19:	int i, count;
        -:   20:	CVALUE v;
        -:   21:
     2966:   22:	update_flags( &info, p_last_line );
     2966:   23:	if( !this->is_fixed_code_size() ){
        -:   24:		count = 1;
        -:   25:		i = 1;
        -:   26:		for( ;; ){
     6885:   27:			i = this->expression( info, i, v );
     7874:   28:			if( v.is_integer() ){
        -:   29:				//	数値の場合は、値の確定の有無にかかわらず 1byte
     3934:   30:				count++;
        -:   31:			}
        3:   32:			else if( v.is_string() ){
        2:   33:				if( v.is_unknown() ){
        -:   34:					//	文字列の場合は、値が確定していないとサイズが不明
        -:   35:					count = -1;
        -:   36:					break;
        -:   37:				}
        -:   38:				//	文字列の場合は、値が確定していると文字長がそのままサイズ
        2:   39:				count += v.s.size();
        -:   40:			}
        -:   41:			else{
        -:   42:				//	型もわからない場合は、サイズが不明
        -:   43:				count = -1;
        -:   44:				break;
        -:   45:			}
     7872:   46:			if( i >= (int)words.size() ){
        -:   47:				break;
        -:   48:			}
     5896:   49:			if( words[ i ] != "," ){
    #####:   50:				put_error( "Illegal parameter." );
        -:   51:				count = -1;
        -:   52:				break;
        -:   53:			}
     2948:   54:			i++;
        -:   55:		}
      989:   56:		if( count >= 0 ){
      988:   57:			this->set_code_size( &info, count );
        -:   58:		}
        -:   59:	}
     2966:   60:	if( !this->is_data_fixed ){
        -:   61:		i = 1;
        -:   62:		for( ;; ){
     3947:   63:			i = this->expression( info, i, v );
     3947:   64:			if( i == 0 ){
        2:   65:				put_error( "Cannot evaluate the expression." );
        -:   66:				data.clear();
        1:   67:				return false;
        -:   68:			}
    10850:   69:			if( i < (int)words.size() && words[ i ] != "," ){
    #####:   70:				put_error( "Illegal expression." );
        -:   71:				data.clear();
    #####:   72:				return false;
        -:   73:			}
     3946:   74:			i++;
     7892:   75:			if( v.is_unknown() ){
        4:   76:				put_error( "Illegal expression." );
        -:   77:				data.clear();
        2:   78:				return false;
        -:   79:			}
     3944:   80:			else if( v.is_integer() ) {
     7884:   81:				data.push_back( v.i & 255 );
        -:   82:			}
        -:   83:			else {
        -:   84:				//	v.is_string()
       20:   85:				for( char &c : v.s ){
       36:   86:					data.push_back( (unsigned char) c );
        -:   87:				}
        -:   88:			}
     7888:   89:			if( i >= (int)words.size() ){
        -:   90:				break;
        -:   91:			}
        -:   92:		}
      988:   93:		this->is_data_fixed = true;
        -:   94:	}
        -:   95:	//	log
     2963:   96:	if( !this->is_analyze_phase ){
     1976:   97:		log.write_line_infomation( this->line_no, this->code_address, this->file_address, get_line() );
      988:   98:		log.write_dump( this->code_address, this->file_address, this->data );
      988:   99:		log.write_separator();
        -:  100:	}
        -:  101:	return check_all_fixed();
       12:  102:}
        -:  103:
