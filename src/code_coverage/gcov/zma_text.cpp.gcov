        -:    0:Source:../zma_text.cpp
        -:    0:Programs:106
        -:    1:// --------------------------------------------------------------------
        -:    2://	ZMA: CZMA_TEXT
        -:    3:// ====================================================================
        -:    4://	2019/05/02	t.hara
        -:    5:// --------------------------------------------------------------------
        -:    6:
        -:    7:#include "zma_text.hpp"
        -:    8:#include <fstream>
        -:    9:#include <iostream>
        -:   10:
        -:   11:// ----------------------------------------------------------------
        -:   12://	Constructor
        -:   13:// ----------------------------------------------------------------
      675:   14:CZMA_TEXT::CZMA_TEXT() {
      675:   15:	code_size = -1;
      675:   16:	next_code_address = -1;
      675:   17:}
        -:   18:
        -:   19:// ----------------------------------------------------------------
        -:   20://	Destructor
        -:   21:// ----------------------------------------------------------------
      150:   22:CZMA_TEXT::~CZMA_TEXT() {
     7928:   23:	for( auto p: m_text ) { 
     7853:   24:		delete p; 
        -:   25:	}
       75:   26:}
        -:   27:
        -:   28:// ----------------------------------------------------------------
        -:   29://	code size
        -:   30:// ----------------------------------------------------------------
      124:   31:void CZMA_TEXT::calc_code_size( void ) {
        -:   32:
      124:   33:	code_size = 0;
      248:   34:	for( auto &p : this->m_text ){
      142:   35:		if( p->is_fixed_code_size() ){
      124:   36:			code_size += p->get_code_size();
        -:   37:		}
        -:   38:		else{
       18:   39:			code_size = -1;
       18:   40:			break;
        -:   41:		}
      124:   42:		if( p->is_fixed_next_code_address() ){
      121:   43:			next_code_address = p->get_next_code_address();
        -:   44:		}
        -:   45:		else{
        3:   46:			next_code_address = -1;
        -:   47:		}
        -:   48:	}
      124:   49:}
        -:   50:
        -:   51:// ----------------------------------------------------------------
        -:   52://	check data fixed
        -:   53:// ----------------------------------------------------------------
      124:   54:bool CZMA_TEXT::check_data_fixed( void ){
        -:   55:
      250:   56:	for( auto &p : this->m_text ){
      142:   57:		if( !p->check_data_fixed() ){
        -:   58:			return false;
        -:   59:		}
        -:   60:	}
        -:   61:	return true;
        -:   62:}
        -:   63:
        -:   64:// ----------------------------------------------------------------
        -:   65://	File Load
        -:   66:// ----------------------------------------------------------------
       88:   67:bool CZMA_TEXT::load( CZMA_INFORMATION &info, const char* p_file_name ) {
       88:   68:	m_text.clear();
        -:   69:	std::string s;
        -:   70:	CZMA_PARSE *p_parse;
        -:   71:	int line_no;
       88:   72:	std::vector< std::string > words, labels;
        -:   73:
      176:   74:	std::ifstream file;
       88:   75:	file.open( p_file_name );
       88:   76:	if( !file ) {
        -:   77:		return false;
        -:   78:	}
        -:   79:	line_no = 1;
     8172:   80:	for( ;; line_no++) {
    16432:   81:		if(file.bad()) {
        -:   82:			break;
        -:   83:		}
    16520:   84:		if(!std::getline( file, s )) {
        -:   85:			break;
        -:   86:		}
    24516:   87:		words = CZMA_PARSE::get_word_split( s );
    20855:   88:		if( words.size() > 2 && ( (words[ 1 ] == ":") || (words[ 1 ] == "::") ) ){
        6:   89:			labels.resize( 2 );
        6:   90:			labels[ 0 ] = words[ 0 ];
       12:   91:			labels[ 1 ] = words[ 1 ];
        6:   92:			p_parse = CZMA_PARSE::create( info, labels, p_file_name, line_no );
        6:   93:			m_text.push_back( p_parse );
        -:   94:			words.erase( words.begin() );
        -:   95:			words.erase( words.begin() );
        6:   96:			p_parse = CZMA_PARSE::create( info, words, p_file_name, line_no );
        6:   97:			m_text.push_back( p_parse );
        -:   98:		}
        -:   99:		else{
    16332:  100:			p_parse = CZMA_PARSE::create( info, words, p_file_name, line_no );
     8166:  101:			m_text.push_back( p_parse );
        -:  102:		}
        -:  103:	}
       88:  104:	file.close();
        -:  105:	return true;
        -:  106:}
        -:  107:
        -:  108:// --------------------------------------------------------------------
     1647:  109:CZMA_PARSE *CZMA_TEXT::process( CZMA_INFORMATION &info, unsigned int &success_count, CZMA_PARSE *p_prev_line, bool output_mode ) {
        -:  110:	CZMA_PARSE* p_prev;
        -:  111:	bool result;
        -:  112:	int nest_count = 0;
        -:  113:	p_prev = p_prev_line;
        -:  114:	result = true;
     1647:  115:	success_count = 0;
     1647:  116:	std::vector<std::string> words;
        -:  117:
    27846:  118:	for( auto p = m_text.begin(); p != m_text.end(); ) {
    26199:  119:		if( output_mode ) {
     8672:  120:			(*p)->set_output_mode();
        -:  121:		}
    26199:  122:		if( !info.is_block_processing ){
        -:  123:			//	パースエラーを起こした行の場合、再パースを試みる
    26124:  124:			if( ( *p )->is_parse_error() ){
       60:  125:				words = CZMA_PARSE::get_word_split( ( *p )->get_line() );
       20:  126:				CZMA_PARSE *p_parse = CZMA_PARSE::create( info, words, ( *p )->get_file_name(), ( *p )->get_line_no() );
       20:  127:				if( !( p_parse->is_parse_error() ) ){
        2:  128:					p = m_text.erase( p );
        2:  129:					p = m_text.insert( p, p_parse );
        -:  130:				}
        -:  131:				else{
       18:  132:					delete p_parse;
        -:  133:				}
        -:  134:			}
        -:  135:			//	ブロックの外側の処理
    26124:  136:			if( ( *p )->process( info, p_prev ) ){
    24446:  137:				success_count++;
        -:  138:			}
    26124:  139:			p_prev = ( *p );
        -:  140:			p++;
        -:  141:		}
        -:  142:		else {
        -:  143:			//	ブロックの中の処理
      150:  144:			if( (*p)->words.size() >= 1 && info.block_end_table.count( (*p)->words[0] ) ) {
        -:  145:				//	ブロックを閉じる記号を発見
       26:  146:				if( (*p)->words[0] == "ENDM" ) {
        -:  147:					//	特に ENDR, ENDM の処理
        -:  148:					if( nest_count ) {
        -:  149:						//	ブロック内のブロックだったのでネスト数を減らすだけ
        -:  150:						nest_count--;
        -:  151:						info.p_text->push_back( *p );
        -:  152:						p = m_text.erase( p );
        -:  153:						continue;
        -:  154:					}
        -:  155:				}
        -:  156:				if( nest_count == 0 ) {
       52:  157:					if( info.block_type != info.block_end_table[(*p)->words[0]] ) {
        -:  158:						//	着目ブロックの種類と異なる「閉じる記号」を発見
    #####:  159:						(*p)->put_structure_error( "Invalid block pair." );
    #####:  160:						p_prev = (*p);
        -:  161:						p++;
    #####:  162:						continue;
        -:  163:					}
        -:  164:					//	「閉じる記号」の処理
       26:  165:					if( (*p)->process( info, p_prev ) ) {
       24:  166:						success_count++;
        -:  167:					}
       26:  168:					p_prev = (*p);
        -:  169:					p++;
        -:  170:				}
        -:  171:				else {
        -:  172:					info.p_text->push_back( *p );
        -:  173:					p = m_text.erase( p );
        -:  174:					continue;
        -:  175:				}
        -:  176:			}
        -:  177:			else {
      146:  178:				if( (*p)->words.size() >= 2 && (*p)->words[1] == "MACRO" ) {
        -:  179:					//	ブロックの内側にマクロ宣言を発見
        2:  180:					(*p)->put_structure_error( "MACRO cannot define in MACRO/REPEAT/IF block." );
        1:  181:					p_prev = (*p);
        -:  182:					p++;
        1:  183:					continue;
        -:  184:				}
       48:  185:				info.p_text->push_back( *p );
       48:  186:				p = m_text.erase( p );
        -:  187:			}
        -:  188:		}
        -:  189:	}
     1647:  190:	return p_prev;
        -:  191:}
        -:  192:
        -:  193:// --------------------------------------------------------------------
      502:  194:void CZMA_TEXT::analyze_structure( void ){
      502:  195:	std::vector<CZMA_PARSE *>::iterator pp_current = this->m_text.begin();
        -:  196:
     9209:  197:	while( pp_current != this->m_text.end() ){
     8707:  198:		(*pp_current)->block_structure( this->m_text, pp_current );
        -:  199:		pp_current++;
        -:  200:	}
      502:  201:}
        -:  202:
        -:  203:// --------------------------------------------------------------------
       74:  204:bool CZMA_TEXT::all_process( CZMA_INFORMATION& info ) {
        -:  205:	unsigned int success_count;
        -:  206:	CZMA_PARSE* p_last_line;
        -:  207:
       74:  208:	this->analyze_structure();
       74:  209:	if( CZMA_PARSE::get_number_of_errors() ){
        -:  210:		return false;
        -:  211:	}
        -:  212:	for( ; ; ) {
      151:  213:		info.clear();
      151:  214:		p_last_line = this->process( info, success_count, nullptr, false );
      151:  215:		if( info.is_block_processing ) {
        1:  216:			p_last_line->set_output_mode();
        5:  217:			p_last_line->put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::BLOCK_PROCESSING_IS_NOT_CLOSED ) );
        1:  218:			break;
        -:  219:		}
      150:  220:		if( !info.is_updated ) {
        -:  221:			break;
        -:  222:		}
        -:  223:	}
       73:  224:	info.clear();
       73:  225:	p_last_line = this->process( info, success_count, nullptr, true );
       73:  226:	if( p_last_line == nullptr || ((p_last_line->get_file_address() == 0) && (p_last_line->get_code_size() == 0)) ) {
        9:  227:		std::cerr << "Code is not found.\n";
        -:  228:		return false;
        -:  229:	}
      128:  230:	if( info.scope.size() > 0 ) {
       15:  231:		p_last_line->put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::SCOPE_IS_NOT_CLOSED ) );
        3:  232:		return false;
        -:  233:	}
       61:  234:	if( CZMA_PARSE::get_number_of_errors() ) {
       23:  235:		std::cerr << "Found " << CZMA_PARSE::get_number_of_errors() << " error(s).\n";
        -:  236:		return false;
        -:  237:	}
        -:  238:	return true;
        -:  239:}
        -:  240:
        -:  241:// --------------------------------------------------------------------
      509:  242:bool CZMA_TEXT::write( CZMA_INFORMATION& info, std::ofstream* f ) {
        -:  243:	bool result;
        -:  244:
        -:  245:	result = true;
     9168:  246:	for( auto &p: m_text ) {
     8659:  247:		result = result && p->write_output_and_log( info, f );
        -:  248:	}
      509:  249:	if( info.output_type == CZMA_INFORMATION::OUTPUT_TYPE::CZMA_INTELHEX ){
        1:  250:		info.hexfile.flush( *f );
        -:  251:	}
      509:  252:	return result;
        -:  253:}
        -:  254:
        -:  255:// --------------------------------------------------------------------
       74:  256:bool CZMA_TEXT::save( CZMA_INFORMATION& info, const char* p_file_name ) {
      148:  257:	std::ofstream f;
        -:  258:
       74:  259:	f.open( p_file_name, std::ios::out | std::ios::binary );
       74:  260:	bool result = this->write( info, &f );
       74:  261:	info.write();
       74:  262:	return result;
      154:  263:}
