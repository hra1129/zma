        -:    0:Source:../zma_text.cpp
        -:    0:Programs:105
        -:    1:// --------------------------------------------------------------------
        -:    2://	ZMA: CZMA_TEXT
        -:    3:// ====================================================================
        -:    4://	2019/05/02	t.hara
        -:    5:// --------------------------------------------------------------------
        -:    6:
        -:    7:#include "zma_text.hpp"
        -:    8:#include <fstream>
        -:    9:#include <iostream>
        -:   10:
        -:   11:// ----------------------------------------------------------------
        -:   12://	Constructor
        -:   13:// ----------------------------------------------------------------
      603:   14:CZMA_TEXT::CZMA_TEXT() {
      603:   15:	code_size = 0;
      603:   16:	next_code_address = 0;
      603:   17:}
        -:   18:
        -:   19:// ----------------------------------------------------------------
        -:   20://	Destructor
        -:   21:// ----------------------------------------------------------------
      146:   22:CZMA_TEXT::~CZMA_TEXT() {
     7972:   23:	for( auto p: m_text ) { 
     7899:   24:		delete p; 
        -:   25:	}
       73:   26:}
        -:   27:
        -:   28:// ----------------------------------------------------------------
        -:   29://	File Load
        -:   30:// ----------------------------------------------------------------
       86:   31:bool CZMA_TEXT::load( CZMA_INFORMATION &info, const char* p_file_name ) {
       86:   32:	m_text.clear();
        -:   33:	std::string s;
        -:   34:	CZMA_PARSE *p_parse;
        -:   35:	int line_no;
       86:   36:	std::vector< std::string > words, labels;
        -:   37:
      172:   38:	std::ifstream file;
       86:   39:	file.open( p_file_name );
       86:   40:	if( !file ) {
        -:   41:		return false;
        -:   42:	}
        -:   43:	line_no = 1;
     8141:   44:	for( ;; line_no++) {
    16368:   45:		if(file.bad()) {
        -:   46:			break;
        -:   47:		}
    16454:   48:		if(!std::getline( file, s )) {
        -:   49:			break;
        -:   50:		}
    24423:   51:		words = CZMA_PARSE::get_word_split( s );
    20781:   52:		if( words.size() > 2 && ( (words[ 1 ] == ":") || (words[ 1 ] == "::") ) ){
        6:   53:			labels.resize( 2 );
        6:   54:			labels[ 0 ] = words[ 0 ];
       12:   55:			labels[ 1 ] = words[ 1 ];
        6:   56:			p_parse = CZMA_PARSE::create( info, labels, p_file_name, line_no );
        6:   57:			m_text.push_back( p_parse );
        -:   58:			words.erase( words.begin() );
        -:   59:			words.erase( words.begin() );
        6:   60:			p_parse = CZMA_PARSE::create( info, words, p_file_name, line_no );
        6:   61:			m_text.push_back( p_parse );
        -:   62:		}
        -:   63:		else{
    16270:   64:			p_parse = CZMA_PARSE::create( info, words, p_file_name, line_no );
     8135:   65:			m_text.push_back( p_parse );
        -:   66:		}
        -:   67:	}
       86:   68:	file.close();
        -:   69:	return true;
        -:   70:}
        -:   71:
        -:   72:// --------------------------------------------------------------------
     2540:   73:CZMA_PARSE *CZMA_TEXT::process( CZMA_INFORMATION &info, unsigned int &success_count, CZMA_PARSE *p_prev_line, bool output_mode ) {
        -:   74:	CZMA_PARSE* p_prev;
        -:   75:	bool result;
        -:   76:	int nest_count = 0;
        -:   77:	p_prev = p_prev_line;
        -:   78:	result = true;
     2540:   79:	success_count = 0;
     2540:   80:	std::vector<std::string> words;
        -:   81:
    30555:   82:	for( auto p = m_text.begin(); p != m_text.end(); ) {
    28015:   83:		if( output_mode ) {
     8752:   84:			(*p)->set_output_mode();
        -:   85:		}
    28015:   86:		if( info.is_block_processing ) {
        -:   87:			//	ブロックの中の処理
      930:   88:			if( (*p)->words.size() >= 1 && info.block_end_table.count( (*p)->words[0] ) ) {
        -:   89:				//	ブロックを閉じる記号を発見
      722:   90:				if( (*p)->words[0] == "ENDR" || (*p)->words[0] == "ENDM" || (*p)->words[0] == "ENDIF" ) {
        -:   91:					//	特に ENDR, ENDM, ENDIF の処理
      140:   92:					if( nest_count ) {
        -:   93:						//	ブロック内のブロックだったのでネスト数を減らすだけ
       23:   94:						nest_count--;
       23:   95:						info.p_text->push_back( *p );
       23:   96:						p = m_text.erase( p );
       23:   97:						continue;
        -:   98:					}
        -:   99:				}
      206:  100:				if( nest_count == 0 ) {
      150:  101:					if( info.block_type != info.block_end_table[(*p)->words[0]] ) {
        -:  102:						//	着目ブロックの種類と異なる「閉じる記号」を発見
        4:  103:						(*p)->put_structure_error( "Invalid block pair." );
        2:  104:						p_prev = (*p);
        -:  105:						p++;
        2:  106:						continue;
        -:  107:					}
        -:  108:					//	「閉じる記号」の処理
      146:  109:					if( (*p)->process( info, p_prev ) ) {
       95:  110:						success_count++;
        -:  111:					}
      146:  112:					p_prev = (*p);
        -:  113:					p++;
        -:  114:				}
        -:  115:				else {
       29:  116:					info.p_text->push_back( *p );
       29:  117:					p = m_text.erase( p );
       29:  118:					continue;
        -:  119:				}
        -:  120:			}
        -:  121:			else {
      530:  122:				if( (*p)->words.size() >= 1 && info.block_begin_table.count( (*p)->words[0] ) ) {
        -:  123:					//	ブロックの内側にブロックの開始を発見
       64:  124:					if( (*p)->words[0] == "REPEAT" || (*p)->words[0] == "IF" ) {
       23:  125:						nest_count++;
        -:  126:					}
        -:  127:				}
      722:  128:				else if( (*p)->words.size() >= 2 && (*p)->words[1] == "MACRO" ) {
        -:  129:					//	ブロックの内側にマクロ宣言を発見
        2:  130:					(*p)->put_structure_error( "MACRO cannot define in MACRO/REPEAT/IF block." );
        1:  131:					p_prev = (*p);
        -:  132:					p++;
        1:  133:					continue;
        -:  134:				}
      264:  135:				info.p_text->push_back( *p );
      264:  136:				p = m_text.erase( p );
        -:  137:			}
        -:  138:		}
        -:  139:		else {
        -:  140:			//	パースエラーを起こした行の場合、再パースを試みる
    27550:  141:			if( (*p)->is_parse_error() ) {
       60:  142:				words = CZMA_PARSE::get_word_split( ( *p )->get_line() );
       20:  143:				CZMA_PARSE *p_parse = CZMA_PARSE::create( info, words, (*p)->get_file_name(), (*p)->get_line_no() );
       20:  144:				if( !(p_parse->is_parse_error()) ) {
        2:  145:					p = m_text.erase( p );
        2:  146:					p = m_text.insert( p, p_parse );
        -:  147:				}
        -:  148:				else {
       18:  149:					delete p_parse;
        -:  150:				}
        -:  151:			}
        -:  152:			//	ブロックの外側の処理
    27550:  153:			if( (*p)->process( info, p_prev ) ) {
    25675:  154:				success_count++;
        -:  155:			}
    27550:  156:			p_prev = (*p);
        -:  157:			p++;
        -:  158:		}
        -:  159:	}
     2540:  160:	return p_prev;
        -:  161:}
        -:  162:
        -:  163:// --------------------------------------------------------------------
       72:  164:bool CZMA_TEXT::all_process( CZMA_INFORMATION& info ) {
        -:  165:	unsigned int success_count;
        -:  166:	CZMA_PARSE* p_last_line;
        -:  167:
        -:  168:	for( ; ; ) {
      148:  169:		success_count = 0;
      148:  170:		info.scope.clear();
      148:  171:		info.p_char_set = nullptr;
      148:  172:		info.s_char_set = "DEFAULT";
      148:  173:		info.is_updated = false;
      148:  174:		info.is_block_processing = false;
      148:  175:		info.auto_label_index = 0;
      148:  176:		p_last_line = this->process( info, success_count, nullptr, false );
      148:  177:		if( info.is_block_processing ) {
        -:  178:			p_last_line->set_output_mode();
       35:  179:			p_last_line->put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::BLOCK_PROCESSING_IS_NOT_CLOSED ) );
        7:  180:			break;
        -:  181:		}
      141:  182:		if( !info.is_updated ) {
        -:  183:			break;
        -:  184:		}
        -:  185:	}
       72:  186:	info.scope.clear();
       72:  187:	info.p_char_set = nullptr;
        -:  188:	info.s_char_set = "DEFAULT";
       72:  189:	info.is_block_processing = false;
       72:  190:	info.auto_label_index = 0;
       72:  191:	p_last_line = this->process( info, success_count, nullptr, true );
       72:  192:	if( p_last_line == nullptr ) {
    #####:  193:		std::cerr << "Code is not found.\n";
        -:  194:		return false;
        -:  195:	}
      144:  196:	if( info.scope.size() > 0 ) {
       25:  197:		p_last_line->put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::SCOPE_IS_NOT_CLOSED ) );
        5:  198:		return false;
        -:  199:	}
       67:  200:	if( CZMA_PARSE::get_number_of_errors() ) {
       26:  201:		std::cerr << "Found " << CZMA_PARSE::get_number_of_errors() << " error(s).\n";
        -:  202:		return false;
        -:  203:	}
        -:  204:	return true;
        -:  205:}
        -:  206:
        -:  207:// --------------------------------------------------------------------
      457:  208:bool CZMA_TEXT::write( CZMA_INFORMATION& info, std::ofstream* f ) {
        -:  209:	bool result;
        -:  210:
        -:  211:	result = true;
     9279:  212:	for( auto &p: m_text ) {
     8750:  213:		result = result && p->write_output_and_log( info, f );
        -:  214:	}
      457:  215:	return result;
        -:  216:}
        -:  217:
        -:  218:// --------------------------------------------------------------------
       72:  219:bool CZMA_TEXT::save( CZMA_INFORMATION& info, const char* p_file_name ) {
      144:  220:	std::ofstream f;
        -:  221:
       72:  222:	f.open( p_file_name, std::ios::out | std::ios::binary );
        -:  223:	bool result = this->write( info, &f );
       72:  224:	info.write();
       72:  225:	return result;
      150:  226:}
