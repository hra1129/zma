        -:    0:Source:../zma_text.cpp
        -:    0:Programs:106
        -:    1:// --------------------------------------------------------------------
        -:    2://	ZMA: CZMA_TEXT
        -:    3:// ====================================================================
        -:    4://	2019/05/02	t.hara
        -:    5:// --------------------------------------------------------------------
        -:    6:
        -:    7:#include "zma_text.hpp"
        -:    8:#include <fstream>
        -:    9:#include <iostream>
        -:   10:
        -:   11:// ----------------------------------------------------------------
        -:   12://	Constructor
        -:   13:// ----------------------------------------------------------------
      712:   14:CZMA_TEXT::CZMA_TEXT() {
      712:   15:	code_size = -1;
      712:   16:	next_code_address = -1;
      712:   17:}
        -:   18:
        -:   19:// ----------------------------------------------------------------
        -:   20://	Destructor
        -:   21:// ----------------------------------------------------------------
      154:   22:CZMA_TEXT::~CZMA_TEXT() {
    14147:   23:	for( auto p: m_text ) { 
    14070:   24:		delete p; 
        -:   25:	}
       77:   26:}
        -:   27:
        -:   28:// ----------------------------------------------------------------
        -:   29://	code size
        -:   30:// ----------------------------------------------------------------
      127:   31:void CZMA_TEXT::calc_code_size( void ) {
        -:   32:
      127:   33:	code_size = 0;
      261:   34:	for( auto &p : this->m_text ){
      152:   35:		if( p->is_fixed_code_size() ){
      134:   36:			code_size += p->get_code_size();
        -:   37:		}
        -:   38:		else{
       18:   39:			code_size = -1;
       18:   40:			break;
        -:   41:		}
      134:   42:		if( p->is_fixed_next_code_address() ){
      131:   43:			next_code_address = p->get_next_code_address();
        -:   44:		}
        -:   45:		else{
        3:   46:			next_code_address = -1;
        -:   47:		}
        -:   48:	}
      127:   49:}
        -:   50:
        -:   51:// ----------------------------------------------------------------
        -:   52://	check data fixed
        -:   53:// ----------------------------------------------------------------
      127:   54:bool CZMA_TEXT::check_data_fixed( void ){
        -:   55:
      263:   56:	for( auto &p : this->m_text ){
      152:   57:		if( !p->check_data_fixed() ){
        -:   58:			return false;
        -:   59:		}
        -:   60:	}
        -:   61:	return true;
        -:   62:}
        -:   63:
        -:   64:// ----------------------------------------------------------------
        -:   65://	File Load
        -:   66:// ----------------------------------------------------------------
       90:   67:bool CZMA_TEXT::load( CZMA_INFORMATION &info, const char* p_file_name ) {
       90:   68:	m_text.clear();
        -:   69:	std::string s;
        -:   70:	CZMA_PARSE *p_parse;
        -:   71:	int line_no;
       90:   72:	std::vector< std::string > words, labels;
        -:   73:
      180:   74:	std::ifstream file;
       90:   75:	file.open( p_file_name );
       90:   76:	if( !file ) {
        -:   77:		return false;
        -:   78:	}
        -:   79:	line_no = 1;
    14437:   80:	for( ;; line_no++) {
    28964:   81:		if(file.bad()) {
        -:   82:			break;
        -:   83:		}
    29054:   84:		if(!std::getline( file, s )) {
        -:   85:			break;
        -:   86:		}
    43311:   87:		words = CZMA_PARSE::get_word_split( s );
    36641:   88:		if( words.size() > 2 && ( (words[ 1 ] == ":") || (words[ 1 ] == "::") ) ){
        6:   89:			labels.resize( 2 );
        6:   90:			labels[ 0 ] = words[ 0 ];
       12:   91:			labels[ 1 ] = words[ 1 ];
        6:   92:			p_parse = CZMA_PARSE::create( info, labels, p_file_name, line_no );
        6:   93:			m_text.push_back( p_parse );
        -:   94:			words.erase( words.begin() );
        -:   95:			words.erase( words.begin() );
        6:   96:			p_parse = CZMA_PARSE::create( info, words, p_file_name, line_no );
        6:   97:			m_text.push_back( p_parse );
        -:   98:		}
        -:   99:		else{
    28862:  100:			p_parse = CZMA_PARSE::create( info, words, p_file_name, line_no );
    14431:  101:			m_text.push_back( p_parse );
        -:  102:		}
        -:  103:	}
       90:  104:	file.close();
        -:  105:	return true;
        -:  106:}
        -:  107:
        -:  108:// --------------------------------------------------------------------
     1663:  109:CZMA_PARSE *CZMA_TEXT::process( CZMA_INFORMATION &info, unsigned int &success_count, CZMA_PARSE *p_prev_line, bool output_mode ) {
        -:  110:	CZMA_PARSE* p_prev;
        -:  111:	bool result;
        -:  112:	int nest_count = 0;
        -:  113:	p_prev = p_prev_line;
        -:  114:	result = true;
     1663:  115:	success_count = 0;
     1663:  116:	std::vector<std::string> words;
        -:  117:
    46511:  118:	for( auto p = m_text.begin(); p != m_text.end(); ) {
    44848:  119:		if( output_mode ) {
    14896:  120:			(*p)->set_output_mode();
        -:  121:		}
        -:  122:		//	パースエラーを起こした行の場合、再パースを試みる
    44848:  123:		if( ( *p )->is_parse_error() ){
       60:  124:			words = CZMA_PARSE::get_word_split( ( *p )->get_line() );
       20:  125:			CZMA_PARSE *p_parse = CZMA_PARSE::create( info, words, ( *p )->get_file_name(), ( *p )->get_line_no() );
       20:  126:			if( !( p_parse->is_parse_error() ) ){
        2:  127:				p = m_text.erase( p );
        2:  128:				p = m_text.insert( p, p_parse );
        -:  129:			}
        -:  130:			else{
       18:  131:				delete p_parse;
        -:  132:			}
        -:  133:		}
        -:  134:		//	ブロックの外側の処理
    44848:  135:		if( ( *p )->process( info, p_prev ) ){
    24533:  136:			success_count++;
        -:  137:		}
    44848:  138:		p_prev = ( *p );
        -:  139:		p++;
        -:  140:	}
     1663:  141:	return p_prev;
        -:  142:}
        -:  143:
        -:  144:// --------------------------------------------------------------------
      504:  145:void CZMA_TEXT::analyze_structure( void ){
      504:  146:	std::vector<CZMA_PARSE *>::iterator pp_current = this->m_text.begin();
        -:  147:
    15377:  148:	while( pp_current != this->m_text.end() ){
    14873:  149:		(*pp_current)->block_structure( this->m_text, pp_current );
        -:  150:		pp_current++;
        -:  151:	}
      504:  152:}
        -:  153:
        -:  154:// --------------------------------------------------------------------
       76:  155:bool CZMA_TEXT::all_process( CZMA_INFORMATION& info ) {
        -:  156:	unsigned int success_count;
        -:  157:	CZMA_PARSE* p_last_line;
        -:  158:
       76:  159:	this->analyze_structure();
       76:  160:	if( CZMA_PARSE::get_number_of_errors() ){
        -:  161:		return false;
        -:  162:	}
        -:  163:	for( ; ; ) {
      156:  164:		info.clear();
      156:  165:		p_last_line = this->process( info, success_count, nullptr, false );
      156:  166:		info.set_evaluated_for_all_links();
      156:  167:		if( !info.is_updated ) {
        -:  168:			break;
        -:  169:		}
        -:  170:	}
       75:  171:	info.clear();
       75:  172:	p_last_line = this->process( info, success_count, nullptr, true );
       75:  173:	if( p_last_line == nullptr || ((p_last_line->get_file_address() == 0) && (p_last_line->get_code_size() == 0)) ) {
       13:  174:		std::cerr << "Code is not found.\n";
        -:  175:		return false;
        -:  176:	}
      124:  177:	if( info.scope.size() > 0 ) {
       15:  178:		p_last_line->put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::SCOPE_IS_NOT_CLOSED ) );
        3:  179:		return false;
        -:  180:	}
       59:  181:	if( CZMA_PARSE::get_number_of_errors() ) {
       20:  182:		std::cerr << "Found " << CZMA_PARSE::get_number_of_errors() << " error(s).\n";
        -:  183:		return false;
        -:  184:	}
        -:  185:	return true;
        -:  186:}
        -:  187:
        -:  188:// --------------------------------------------------------------------
      547:  189:bool CZMA_TEXT::write( CZMA_INFORMATION& info, std::ofstream* f ) {
        -:  190:	bool result;
        -:  191:
        -:  192:	result = true;
    15486:  193:	for( auto &p: m_text ) {
    14939:  194:		result = result && p->write_output_and_log( info, f );
        -:  195:	}
      547:  196:	if( info.output_type == CZMA_INFORMATION::OUTPUT_TYPE::CZMA_INTELHEX ){
        1:  197:		info.hexfile.flush( *f );
        -:  198:	}
      547:  199:	return result;
        -:  200:}
        -:  201:
        -:  202:// --------------------------------------------------------------------
       76:  203:bool CZMA_TEXT::save( CZMA_INFORMATION& info, const char* p_file_name ) {
      152:  204:	std::ofstream f;
        -:  205:
       76:  206:	f.open( p_file_name, std::ios::out | std::ios::binary );
       76:  207:	bool result = this->write( info, &f );
       76:  208:	info.write();
       76:  209:	return result;
      158:  210:}
