        -:    0:Source:../zma_parse.cpp
        -:    0:Programs:4
        -:    1:// --------------------------------------------------------------------
        -:    2://	Z80 Macro Assembler parse
        -:    3:// ====================================================================
        -:    4://	2019/05/04	t.hara
        -:    5:// --------------------------------------------------------------------
        -:    6:
        -:    7:#include "zma_parse.hpp"
        -:    8:#include "zma_text.hpp"
        -:    9:#include <string>
        -:   10:#include <cctype>
        -:   11:#include <iostream>
        -:   12:#include <fstream>
        -:   13:#include <sstream>
        -:   14:#include <algorithm>
        -:   15:
        -:   16:// --------------------------------------------------------------------
   152941:   17:std::string CZMA_PARSE::get_word( int index ) {
   152941:   18:	if( index >= (int)words.size() ) {
    24398:   19:		return "";
        -:   20:	}
   128543:   21:	return words[index];
        -:   22:}
        -:   23:
        -:   24:// --------------------------------------------------------------------
    23336:   25:std::string CZMA_PARSE::delete_head_space( std::string s ) {
        -:   26:	int i;
        -:   27:
    23336:   28:	for( i = 0; isspace( s[i] ); i++ );
    23336:   29:	return s.substr( i );
        -:   30:}
        -:   31:
        -:   32:// --------------------------------------------------------------------
      929:   33:static bool is_shift_jis_1st( char c ) {
      929:   34:	unsigned char cc = (unsigned char) c;
      929:   35:	if( ((cc >= 0x81) && (cc <= 0x9f)) || ((cc >= 0xe0) && (cc <= 0xfc)) ) {
       28:   36:		return true;
        -:   37:	}
      901:   38:	return false;
        -:   39:}
        -:   40:
        -:   41:// --------------------------------------------------------------------
     7616:   42:std::vector<std::string> CZMA_PARSE::get_word_split( std::string s ) {
        -:   43:	int i;
    15232:   44:	std::string word;
     7616:   45:	std::vector< std::string > words;
        -:   46:	static std::vector< std::string > operator_list = { 
        -:   47:		"<<", ">>", "!=", "==", "<=", ">=", "::", "&&", "||", ":="
     7616:   48:	};
        -:   49:
        -:   50:	for(;;) {
    23336:   51:		s = delete_head_space( s );
    23336:   52:		if( s[0] == ';' || s[0] == '\0' ) {
     7616:   53:			break;
        -:   54:		}
    15720:   55:		else if( s[0] == '\'' ) {
        2:   56:			if( (int)s.size() < 2 ) {
    #####:   57:				break;
        -:   58:			}
        4:   59:			if( s[1] == '\\' ) {
        1:   60:				if( ( int) s.size() < 4 ) {
    #####:   61:					break;
        -:   62:				}
        1:   63:				switch( s[2] ) {
    #####:   64:				case 'a':	word = std::to_string( (int)'\a' );		break;
    #####:   65:				case 'b':	word = std::to_string( (int)'\b' );		break;
    #####:   66:				case 'f':	word = std::to_string( (int)'\f' );		break;
        1:   67:				case 'n':	word = std::to_string( (int)'\n' );		break;
    #####:   68:				case 'r':	word = std::to_string( (int)'\r' );		break;
    #####:   69:				case 't':	word = std::to_string( (int)'\t' );		break;
    #####:   70:				case '\\':	word = std::to_string( (int)'\\' );		break;
    #####:   71:				case '\'':	word = std::to_string( (int)'\'' );		break;
    #####:   72:				case '\"':	word = std::to_string( (int)'\"' );		break;
    #####:   73:				default:	word = std::to_string( ( int) s[2] );	break;
        -:   74:				}
        1:   75:				words.push_back( word );
        1:   76:				if( s[3] != '\'' ) {
    #####:   77:					s = s.substr( 3 );
    #####:   78:					continue;
        -:   79:				}
        1:   80:				s = s.substr( 4 );
        1:   81:				continue;
        -:   82:			}
        -:   83:			else {
        1:   84:				word = std::to_string( ( int) s[1] );
        1:   85:				words.push_back( word );
        1:   86:				if( s[2] != '\'' ) {
    #####:   87:					s = s.substr( 2 );
    #####:   88:					continue;
        -:   89:				}
        1:   90:				s = s.substr( 3 );
        1:   91:				continue;
        -:   92:			}
        -:   93:		}
    15860:   94:		else if( s[0] == '\"' ) {
      142:   95:			word = "\"";
     1083:   96:			for( i = 1; i < (int)s.size(); i++ ) {
     1095:   97:				if( s[i] == '\\' ) {
       12:   98:					i++;
       12:   99:					if( i >= (int)s.size() ) {
    #####:  100:						break;
        -:  101:					}
       12:  102:					switch( s[i] ) {
        1:  103:					case 'a':	word = word + "\a";	break;
        1:  104:					case 'b':	word = word + "\b";	break;
        1:  105:					case 'f':	word = word + "\f";	break;
        2:  106:					case 'n':	word = word + "\n";	break;
        2:  107:					case 'r':	word = word + "\r";	break;
        1:  108:					case 't':	word = word + "\t";	break;
        1:  109:					case '\\':	word = word + "\\";	break;
        1:  110:					case '\'':	word = word + "\'";	break;
        1:  111:					case '\"':	word = word + "\"";	break;
        1:  112:					default:	word = word + s[i];	break;
        -:  113:					}
       12:  114:					continue;
        -:  115:				}
     1071:  116:				else if( s[i] == '\"' ) {
      142:  117:					i++;
      142:  118:					break;
        -:  119:				}
      929:  120:				else if( is_shift_jis_1st( s[i] ) ) {
       28:  121:					word = word + s[i];
       28:  122:					i++;
       28:  123:					if( i >= (int)s.size() ) {
    #####:  124:						break;
        -:  125:					}
        -:  126:				}
      929:  127:				word = word + s[i];
        -:  128:			}
      142:  129:			words.push_back( word );
      142:  130:			s = s.substr( i );
      142:  131:			continue;
        -:  132:		}
    15576:  133:		else if( isalpha( s[0] ) || isdigit( s[0] ) || s[0] == '_' ) {
        -:  134:			//	symbols or numbers
    10747:  135:			for( i = 0; isalpha( s[i] ) || isdigit( s[i] ) || s[i] == '_' || s[i] == '\''; i++ );
        -:  136:		}
        -:  137:		else {
        -:  138:			//	operators
     4829:  139:			i = 1;
    52735:  140:			for( std::string &op : operator_list ) {
    47979:  141:				if( op == s.substr( 0, op.length() ) ) {
       73:  142:					i = op.length();
       73:  143:					break;
        -:  144:				}
        -:  145:			}
        -:  146:		}
    15576:  147:		word = s.substr( 0, i );
    15576:  148:		std::transform( word.begin(), word.end(), word.begin(), ::toupper );
    15576:  149:		words.push_back( word );
    15576:  150:		s = s.substr( i );
    15720:  151:	}
    15232:  152:	return words;
        -:  153:}
        -:  154:
        -:  155:// --------------------------------------------------------------------
     8376:  156:CZMA_PARSE::CZMA_PARSE( std::vector<std::string> words, const char* p_file_name, int line_no ) {
     8376:  157:	this->code_address = -1;
     8376:  158:	this->next_code_address = -1;
     8376:  159:	this->file_address = -1;
     8376:  160:	this->code_size = -1;
     8376:  161:	this->is_data_fixed = false;
     8376:  162:	this->words = words;
     8376:  163:	this->p_file_name = p_file_name;
     8376:  164:	this->line_no = line_no;
     8376:  165:	this->is_analyze_phase = true;
     8376:  166:	this->is_label_search_state = true;
     8376:  167:	this->is_structure_error = false;
     8376:  168:}
        -:  169:
        -:  170:// --------------------------------------------------------------------
    25569:  171:bool CZMA_PARSE::update_flags( CZMA_INFORMATION* p_info, const CZMA_PARSE* p_last_line ) {
    25569:  172:	bool result = true;
    25569:  173:	if( p_last_line == nullptr ) {
      169:  174:		this->set_code_address( p_info, 0 );
      169:  175:		this->set_file_address( p_info, 0 );
        -:  176:	}
        -:  177:	else {
    25400:  178:		if( p_last_line->get_fixed_next_code_address() ) {
    10630:  179:			this->set_code_address( p_info, p_last_line->get_next_code_address() );
        -:  180:		}
        -:  181:		else {
    14770:  182:			result = false;
        -:  183:		}
        -:  184:
    25400:  185:		if( p_last_line->get_fixed_file_address() && p_last_line->get_fixed_code_size() ) {
    10317:  186:			this->set_file_address( p_info, p_last_line->get_file_address() + p_last_line->get_code_size() );
        -:  187:		}
        -:  188:		else {
    15083:  189:			result = false;
        -:  190:		}
        -:  191:	}
    25569:  192:	if( !this->is_data_fixed ) {
     5978:  193:		result = false;
        -:  194:	}
    25569:  195:	if( this->get_fixed_code_address() && this->get_fixed_code_size() ) {
     7502:  196:		if( this->next_code_address == -1 ) {
      155:  197:			p_info->is_updated = true;
        -:  198:		}
     7502:  199:		this->next_code_address = this->get_code_address() + this->get_code_size();
        -:  200:	}
        -:  201:	else {
    18067:  202:		result = false;
        -:  203:	}
    25569:  204:	return result;
        -:  205:}
        -:  206:
        -:  207:// --------------------------------------------------------------------
      486:  208:bool CZMA_PARSE::check_location_hl( int index ) {
      486:  209:	if( (int)words.size() >= (index + 3) && words[index] == "[" && words[index+1] == "HL" && words[index+2] == "]" ) {
      174:  210:		return true;
        -:  211:	}
      312:  212:	return false;
        -:  213:}
        -:  214:
        -:  215:// --------------------------------------------------------------------
      726:  216:int CZMA_PARSE::check_location_ix( int index ) {
      726:  217:	if( (int)words.size() < (index + 3) ) {
    #####:  218:		return 0;
        -:  219:	}
      726:  220:	if( words[index] == "[" && words[index + 1] == "IX" && words[index + 2] == "]" ) {
       21:  221:		return index + 3;
        -:  222:	}
      705:  223:	if( words[index] != "[" || words[index + 1] != "IX" || (words[index + 2] != "+" && words[index + 2] != "-") ) {
      387:  224:		return 0;
        -:  225:	}
      318:  226:	for( index += 2; (size_t)index < words.size() && words[index] != "]"; index++ );
      318:  227:	if( (size_t)index >= words.size() ) {
       24:  228:		return 0;
        -:  229:	}
      294:  230:	return index + 1;
        -:  231:}
        -:  232:
        -:  233:// --------------------------------------------------------------------
      411:  234:int CZMA_PARSE::check_location_iy( int index ) {
      411:  235:	if( (int)words.size() < (index + 3) ) {
    #####:  236:		return 0;
        -:  237:	}
      411:  238:	if( words[index] == "[" && words[index + 1] == "IY" && words[index + 2] == "]" ) {
       15:  239:		return index + 3;
        -:  240:	}
      396:  241:	if( words[index] != "[" || words[index + 1] != "IY" || (words[index + 2] != "+" && words[index + 2] != "-") ) {
      123:  242:		return false;
        -:  243:	}
      273:  244:	for( index += 2; (size_t)index < words.size() && words[index] != "]"; index++ );
      273:  245:	if( (size_t)index >= words.size() ) {
       24:  246:		return 0;
        -:  247:	}
      249:  248:	return index + 1;
        -:  249:}
        -:  250:
        -:  251:// --------------------------------------------------------------------
       34:  252:int CZMA_PARSE::relative_address( CZMA_INFORMATION &info, int index ) {
        -:  253:	int relative;
       68:  254:	CVALUE imm;
       34:  255:	index = this->expression( info, index, imm );
       34:  256:	if( index == 0 ) {
        6:  257:		put_error( "Illegal expression." );
        6:  258:		return -9999;
        -:  259:	}
       28:  260:	if( imm.type != CVALUE::CV_INTEGER ) {
        3:  261:		put_error( "Illegal operand." );
        3:  262:		return -9999;
        -:  263:	}
       25:  264:	if( index < ( int) words.size() ) {
        6:  265:		put_error( "Illegal operand." );
        6:  266:		return -9999;
        -:  267:	}
       19:  268:	relative = imm.i - (this->code_address + this->get_code_size() );
       19:  269:	if( relative < -128 || relative > 127 ) {
        6:  270:		put_error( "Out of range relative address" );
        6:  271:		return -9999;
        -:  272:	}
       13:  273:	return relative;
        -:  274:}
        -:  275:
        -:  276:// --------------------------------------------------------------------
     1359:  277:void CZMA_PARSE::put_error( std::string message ) {
     1803:  278:	std::stringstream ss;
     1803:  279:	std::string s;
        -:  280:
     1359:  281:	if( this->is_analyze_phase ) {
      915:  282:		return;
        -:  283:	}
      444:  284:	ss << "ERROR: " << message << ": " << p_file_name << "(" << line_no << ")";
      444:  285:	s = ss.str();
      444:  286:	std::cerr << s << "\n";
      444:  287:	log.push_back( s );
      444:  288:	number_of_error++;
        -:  289:}
        -:  290:
        -:  291:// --------------------------------------------------------------------
       39:  292:void CZMA_PARSE::put_message( std::string message ) {
       78:  293:	std::stringstream ss;
       78:  294:	std::string s;
        -:  295:
       39:  296:	if(this->is_analyze_phase) {
    #####:  297:		return;
        -:  298:	}
       39:  299:	ss << "MESSAGE: " << message << ": " << p_file_name << "(" << line_no << ")";
       39:  300:	s = ss.str();
       39:  301:	std::cout << s << "\n";
       39:  302:	log.push_back( s );
        -:  303:}
        -:  304:
        -:  305:// --------------------------------------------------------------------
        3:  306:void CZMA_PARSE::put_structure_error( std::string message ) {
        6:  307:	std::stringstream ss;
        6:  308:	std::string s;
        -:  309:
        3:  310:	if( this->is_structure_error ) {
    #####:  311:		return;
        -:  312:	}
        3:  313:	this->is_structure_error = true;
        3:  314:	ss << "ERROR: " << message << ": " << p_file_name << "(" << line_no << ")";
        3:  315:	s = ss.str();
        3:  316:	std::cerr << s << "\n";
        3:  317:	this->structure_error = s;
        3:  318:	log.push_back( s );
        3:  319:	number_of_error++;
        -:  320:}
        -:  321:
        -:  322:// --------------------------------------------------------------------
     4938:  323:bool CZMA_PARSE::opecode( CZMA_INFORMATION& info, unsigned char op1, int op2 ) {
        -:  324:
     4938:  325:	if( words.size() != 1 ) {
      111:  326:		return false;
        -:  327:	}
     4827:  328:	if( this->is_data_fixed ) {
     3218:  329:		return true;
        -:  330:	}
     1609:  331:	this->is_data_fixed = true;
     1609:  332:	if( op2 == -1 ) {
     1585:  333:		this->set_code_size( &info, 1 );
     1585:  334:		this->data.push_back( op1 );
        -:  335:	}
        -:  336:	else {
       24:  337:		this->set_code_size( &info, 2 );
       24:  338:		this->data.push_back( op1 );
       24:  339:		this->data.push_back( op2 );
        -:  340:	}
     1609:  341:	return true;
        -:  342:}
        -:  343:
        -:  344:// --------------------------------------------------------------------
     1119:  345:bool CZMA_PARSE::opecode_a_i_r( CZMA_INFORMATION& info ) {
        -:  346:
     1119:  347:	if( words.size() != 4 || words[2] != "," ) {
      510:  348:		return false;
        -:  349:	}
      609:  350:	if( words[1] == "A" && words[3] == "I" ) {
        3:  351:		if( this->is_data_fixed ) {
        2:  352:			return true;
        -:  353:		}
        1:  354:		this->is_data_fixed = true;
        1:  355:		this->set_code_size( &info, 2 );
        1:  356:		this->data.push_back( 0xED );
        1:  357:		this->data.push_back( 0x57 );
        1:  358:		return true;
        -:  359:	}
      606:  360:	if( words[1] == "I" && words[3] == "A" ) {
        3:  361:		if( this->is_data_fixed ) {
        2:  362:			return true;
        -:  363:		}
        1:  364:		this->is_data_fixed = true;
        1:  365:		this->set_code_size( &info, 2 );
        1:  366:		this->data.push_back( 0xED );
        1:  367:		this->data.push_back( 0x47 );
        1:  368:		return true;
        -:  369:	}
      603:  370:	if( words[1] == "A" && words[3] == "R" ) {
        3:  371:		if( this->is_data_fixed ) {
        2:  372:			return true;
        -:  373:		}
        1:  374:		this->is_data_fixed = true;
        1:  375:		this->set_code_size( &info, 2 );
        1:  376:		this->data.push_back( 0xED );
        1:  377:		this->data.push_back( 0x5F );
        1:  378:		return true;
        -:  379:	}
      600:  380:	if( words[1] == "R" && words[3] == "A" ) {
        3:  381:		if( this->is_data_fixed ) {
        2:  382:			return true;
        -:  383:		}
        1:  384:		this->is_data_fixed = true;
        1:  385:		this->set_code_size( &info, 2 );
        1:  386:		this->data.push_back( 0xED );
        1:  387:		this->data.push_back( 0x4F );
        1:  388:		return true;
        -:  389:	}
      597:  390:	return false;
        -:  391:}
        -:  392:
        -:  393:
        -:  394:// --------------------------------------------------------------------
     1107:  395:bool CZMA_PARSE::opecode_ddd_sss( CZMA_INFORMATION& info, unsigned char op1 ) {
        -:  396:	int ddd, sss;
     1107:  397:	int ixhl = 0;
        -:  398:
     3258:  399:	if( words.size() != 4 || (!info.is_sss_or_ddd( words[1] ) && !info.is_ix_hl( words[1] ) && !info.is_iy_hl( words[1] )) || 
     3108:  400:		words[2] != ","   || (!info.is_sss_or_ddd( words[3] ) && !info.is_ix_hl( words[3] ) && !info.is_iy_hl( words[3] )) ) {
      721:  401:		return false;
        -:  402:	}
      386:  403:	if( info.is_sss_or_ddd( words[1] ) ) {
      254:  404:		ddd = info.sss_or_ddd_id[words[1]];
        -:  405:	}
      132:  406:	else if( info.is_ix_hl( words[1] ) ) {
       66:  407:		ddd = info.ix_hl[words[1]];
       66:  408:		ixhl = 1;
        -:  409:	}
        -:  410:	else {
       66:  411:		ddd = info.iy_hl[words[1]];
       66:  412:		ixhl = 2;
        -:  413:	}
      386:  414:	if( info.is_sss_or_ddd( words[3] ) ) {
      254:  415:		sss = info.sss_or_ddd_id[words[3]];
        -:  416:	}
      132:  417:	else if( info.is_ix_hl( words[3] ) ) {
       66:  418:		sss = info.ix_hl[words[3]];
       66:  419:		if( ixhl || words[1] == "H" || words[1] == "L" ) {
       36:  420:			put_error( "Illegal operand." );
       36:  421:			return false;
        -:  422:		}
       30:  423:		ixhl = 1;
        -:  424:	}
        -:  425:	else {
       66:  426:		sss = info.iy_hl[words[3]];
       66:  427:		if( ixhl || words[1] == "H" || words[1] == "L" ) {
       36:  428:			put_error( "Illegal operand." );
       36:  429:			return false;
        -:  430:		}
       30:  431:		ixhl = 2;
        -:  432:	}
      314:  433:	if( this->is_data_fixed ) {
      209:  434:		return true;
        -:  435:	}
      105:  436:	this->is_data_fixed = true;
      105:  437:	if( ixhl == 1 ) {
       24:  438:		this->set_code_size( &info, 2 );
       24:  439:		this->data.push_back( 0xDD );
        -:  440:	}
       81:  441:	else if( ixhl == 2 ) {
       24:  442:		this->set_code_size( &info, 2 );
       24:  443:		this->data.push_back( 0xFD );
        -:  444:	}
        -:  445:	else {
       57:  446:		this->set_code_size( &info, 1 );
        -:  447:	}
      105:  448:	this->data.push_back( op1 | (ddd << 3) | sss );
      105:  449:	return true;
        -:  450:}
        -:  451:
        -:  452:// --------------------------------------------------------------------
      486:  453:bool CZMA_PARSE::opecode_a_sss( CZMA_INFORMATION& info, unsigned char op1 ) {
        -:  454:	int sss;
      972:  455:	CVALUE d;
        -:  456:
      486:  457:	if( words.size() == 4 && words[1] == "A" && words[2] == "," && info.is_sss_or_ddd( words[3] ) ) {
      174:  458:		if( this->is_data_fixed ) {
      116:  459:			return true;
        -:  460:		}
       58:  461:		this->is_data_fixed = true;
       58:  462:		sss = info.sss_or_ddd_id[words[3]];
       58:  463:		this->set_code_size( &info, 1 );
       58:  464:		this->data.push_back( op1 | sss );
       58:  465:		return true;
        -:  466:	}
      312:  467:	if( words.size() == 4 && words[1] == "A" && words[2] == "," && info.is_ix_hl( words[3] ) ) {
       48:  468:		if( this->is_data_fixed ) {
       32:  469:			return true;
        -:  470:		}
       16:  471:		this->is_data_fixed = true;
       16:  472:		sss = info.ix_hl[words[3]];
       16:  473:		this->set_code_size( &info, 2 );
       16:  474:		this->data.push_back( 0xDD );
       16:  475:		this->data.push_back( op1 | sss );
       16:  476:		return true;
        -:  477:	}
      264:  478:	if( words.size() == 4 && words[1] == "A" && words[2] == "," && info.is_iy_hl( words[3] ) ) {
       48:  479:		if( this->is_data_fixed ) {
       32:  480:			return true;
        -:  481:		}
       16:  482:		this->is_data_fixed = true;
       16:  483:		sss = info.iy_hl[words[3]];
       16:  484:		this->set_code_size( &info, 2 );
       16:  485:		this->data.push_back( 0xFD );
       16:  486:		this->data.push_back( op1 | sss );
       16:  487:		return true;
        -:  488:	}
      216:  489:	return false;
        -:  490:}
        -:  491:
        -:  492:// --------------------------------------------------------------------
       30:  493:bool CZMA_PARSE::opecode_ddd_c( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c, unsigned char op2 ) {
        -:  494:	int ddd;
       60:  495:	CVALUE nn;
        -:  496:
       30:  497:	if( words.size() == 6 && info.is_sss_or_ddd( words[1] ) && words[2] == "," && words[3] == "[" && words[4] == "C" && words[5] == "]" ) {
       23:  498:		if( this->is_data_fixed ) {
       16:  499:			return true;
        -:  500:		}
        7:  501:		this->is_data_fixed = true;
        7:  502:		ddd = info.sss_or_ddd_id[words[1]];
        7:  503:		this->set_code_size( &info, 2 );
        7:  504:		this->data.push_back( op1c );
        7:  505:		this->data.push_back( op2 | (ddd << 3) );
        7:  506:		return true;
        -:  507:	}
        7:  508:	if( words.size() == 6 && words[ 1 ] == "F" && words[ 2 ] == "," && words[ 3 ] == "[" && words[ 4 ] == "C" && words[ 5 ] == "]" ){
        1:  509:		if( this->is_data_fixed ){
    #####:  510:			return true;
        -:  511:		}
        1:  512:		this->is_data_fixed = true;
        1:  513:		ddd = info.sss_or_ddd_id[ words[ 1 ] ];
        1:  514:		this->set_code_size( &info, 2 );
        1:  515:		this->data.push_back( op1c );
        1:  516:		this->data.push_back( op2 | ( 6 << 3 ) );
        1:  517:		return true;
        -:  518:	}
        6:  519:	if( words.size() >= 6 && words[1] == "A" && words[2] == "," && words[3] == "[" ) {
        6:  520:		this->set_code_size( &info, 2 );
        6:  521:		if( !this->expression( info, 4, nn ) ) {
        3:  522:			return false;
        -:  523:		}
        3:  524:		if( nn.type != CVALUE::CV_INTEGER ) {
    #####:  525:			put_error( "Illegal operand." );
    #####:  526:			return false;
        -:  527:		}
        3:  528:		if( this->is_data_fixed ) {
        2:  529:			return true;
        -:  530:		}
        1:  531:		this->is_data_fixed = true;
        1:  532:		this->data.push_back( op1 );
        1:  533:		this->data.push_back( nn.i );
        1:  534:		return true;
        -:  535:	}
    #####:  536:	return false;
        -:  537:}
        -:  538:
        -:  539:// --------------------------------------------------------------------
       30:  540:bool CZMA_PARSE::opecode_c_sss( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c, unsigned char op2 ) {
        -:  541:	int sss, n;
       60:  542:	CVALUE nn;
        -:  543:
       30:  544:	if( words.size() == 6 && words[1] == "[" && words[2] == "C" && words[3] == "]" && words[4] == "," && info.is_sss_or_ddd( words[5] ) ) {
       21:  545:		if( this->is_data_fixed ) {
       14:  546:			return true;
        -:  547:		}
        7:  548:		this->is_data_fixed = true;
        7:  549:		sss = info.sss_or_ddd_id[words[5]];
        7:  550:		this->set_code_size( &info, 2 );
        7:  551:		this->data.push_back( op1c );
        7:  552:		this->data.push_back( op2 | (sss << 3) );
        7:  553:		return true;
        -:  554:	}
        9:  555:	if( words.size() == 6 && words[ 1 ] == "[" && words[ 2 ] == "C" && words[ 3 ] == "]" && words[ 4 ] == "," && words[ 5 ] == "0" ){
        3:  556:		if( this->is_data_fixed ){
        2:  557:			return true;
        -:  558:		}
        1:  559:		this->is_data_fixed = true;
        1:  560:		this->set_code_size( &info, 2 );
        1:  561:		this->data.push_back( op1c );
        1:  562:		this->data.push_back( op2 | ( 6 << 3 ) );
        1:  563:		return true;
        -:  564:	}
        6:  565:	for( n = 2; n < (int)words.size() && words[n] != "]"; n++ ) {
        -:  566:	}
        6:  567:	if( n >= (int)words.size() ) {
    #####:  568:		return false;
        -:  569:	}
        6:  570:	n++;
        6:  571:	if( words.size() >= 6 && words[1] == "[" && words[n] == "," && words[n+1] == "A" ) {
        6:  572:		this->set_code_size( &info, 2 );
        6:  573:		if( !this->expression( info, 2, nn ) ) {
        3:  574:			return false;
        -:  575:		}
        3:  576:		if( nn.type != CVALUE::CV_INTEGER ) {
    #####:  577:			put_error( "Illegal operand." );
    #####:  578:			return false;
        -:  579:		}
        3:  580:		if( this->is_data_fixed ) {
        2:  581:			return true;
        -:  582:		}
        1:  583:		this->is_data_fixed = true;
        1:  584:		this->data.push_back( op1 );
        1:  585:		this->data.push_back( nn.i );
        1:  586:		return true;
        -:  587:	}
    #####:  588:	return false;
        -:  589:}
        -:  590:
        -:  591:// --------------------------------------------------------------------
      738:  592:bool CZMA_PARSE::opecode_n_sss( CZMA_INFORMATION& info, unsigned char op1, bool no_3operand ) {
        -:  593:	int sss, ddd, n;
     1476:  594:	CVALUE b, d;
        -:  595:
      738:  596:	for( n = 1; n < (int) words.size() && words[n] != ","; n++ ) {
        -:  597:	}
      738:  598:	if( n >= (int) words.size() ) {
    #####:  599:		return false;
        -:  600:	}
      738:  601:	if( !this->expression( info, 1, b ) ) {
    #####:  602:		return false;
        -:  603:	}
      738:  604:	if( b.type != CVALUE::CV_INTEGER ) {
    #####:  605:		put_error( "Illegal operand." );
    #####:  606:		return false;
        -:  607:	}
      738:  608:	if( b.i < 0 || b.i > 7 ) {
    #####:  609:		put_error( "Bit number is out of range." );
    #####:  610:		b.i &= 7;
        -:  611:	}
      738:  612:	n++;
      738:  613:	if( (int) words.size() == (n + 1) && info.is_sss_or_ddd( words[n] ) ) {
      504:  614:		if( this->is_data_fixed ) {
      336:  615:			return true;
        -:  616:		}
      168:  617:		this->is_data_fixed = true;
      168:  618:		sss = info.sss_or_ddd_id[words[n]];
      168:  619:		this->set_code_size( &info, 2 );
      168:  620:		this->data.push_back( 0xCB );
      168:  621:		this->data.push_back( op1 | (b.i << 3) | sss );
      168:  622:		return true;
        -:  623:	}
      234:  624:	if( (int) words.size() == (n + 3) && this->check_location_hl( n ) ) {
       72:  625:		if( this->is_data_fixed ) {
       48:  626:			return true;
        -:  627:		}
       24:  628:		this->is_data_fixed = true;
       24:  629:		this->set_code_size( &info, 2 );
       24:  630:		this->data.push_back( 0xCB );
       24:  631:		this->data.push_back( op1 | (b.i << 3) | 0x06 );
       24:  632:		return true;
        -:  633:	}
      162:  634:	if( (int) words.size() >= (n + 5) && this->check_location_ix( n ) ) {
       81:  635:		this->set_code_size( &info, 4 );
       81:  636:		if( words[n + 2] == "+" || words[n + 2] == "-" ) {
       81:  637:			n = this->expression( info, n + 2, d );
       81:  638:			if( n == 0 ) {
    #####:  639:				return false;
        -:  640:			}
       81:  641:			if( words[ n ] != "]" ){
    #####:  642:				put_error( "Illegal operand." );
    #####:  643:				return false;
        -:  644:			}
       81:  645:			if( d.type != CVALUE::CV_INTEGER ) {
    #####:  646:				put_error( "Illegal operand." );
    #####:  647:				return false;
        -:  648:			}
       81:  649:			if( d.i < -128 || d.i > 127 ) {
    #####:  650:				put_error( "Offset value is out of range (" + std::to_string( d.i ) + ")." );
    #####:  651:				return false;
        -:  652:			}
       81:  653:			if( !no_3operand && words.size() > (unsigned)(n + 2) && words[ n + 1 ] == "," && info.is_sss_or_ddd( words[ n + 2 ] ) ){
        6:  654:				ddd = info.sss_or_ddd_id[ words[ n + 2 ] ];
        -:  655:			}
        -:  656:			else{
       75:  657:				ddd = 6;
        -:  658:			}
        -:  659:		}
        -:  660:		else {
    #####:  661:			d.i = 0;
    #####:  662:			ddd = 6;
        -:  663:		}
       81:  664:		if( this->is_data_fixed ) {
       54:  665:			return true;
        -:  666:		}
       27:  667:		this->is_data_fixed = true;
       27:  668:		this->data.push_back( 0xDD );
       27:  669:		this->data.push_back( 0xCB );
       27:  670:		this->data.push_back( d.i );
       27:  671:		this->data.push_back( op1 | (b.i << 3) | ddd );
       27:  672:		return true;
        -:  673:	}
       81:  674:	if( (int) words.size() >= (n + 5) && this->check_location_iy( n ) ) {
       72:  675:		this->set_code_size( &info, 4 );
       72:  676:		if( words[n + 2] == "+" || words[n + 2] == "-" ) {
       72:  677:			n = this->expression( info, n + 2, d );
       72:  678:			if( n == 0 ){
    #####:  679:				return false;
        -:  680:			}
       72:  681:			if( d.type != CVALUE::CV_INTEGER ) {
    #####:  682:				put_error( "Illegal operand." );
    #####:  683:				return false;
        -:  684:			}
       72:  685:			if( d.i < -128 || d.i > 127 ) {
    #####:  686:				put_error( "Offset value is out of range (" + std::to_string( d.i ) + ")." );
    #####:  687:				return false;
        -:  688:			}
       72:  689:			if( !no_3operand && words.size() > (unsigned)( n + 2 ) && words[ n + 1 ] == "," && info.is_sss_or_ddd( words[ n + 2 ] ) ){
    #####:  690:				ddd = info.sss_or_ddd_id[ words[ n + 2 ] ];
        -:  691:			}
        -:  692:			else{
       72:  693:				ddd = 6;
        -:  694:			}
        -:  695:		}
        -:  696:		else{
    #####:  697:			d.i = 0;
    #####:  698:			ddd = 6;
        -:  699:		}
       72:  700:		if( this->is_data_fixed ) {
       48:  701:			return true;
        -:  702:		}
       24:  703:		this->is_data_fixed = true;
       24:  704:		this->data.push_back( 0xFD );
       24:  705:		this->data.push_back( 0xCB );
       24:  706:		this->data.push_back( d.i );
       24:  707:		this->data.push_back( op1 | ( b.i << 3 ) | ddd );
       24:  708:		return true;
        -:  709:	}
        9:  710:	return false;
        -:  711:}
        -:  712:
        -:  713:// --------------------------------------------------------------------
       63:  714:bool CZMA_PARSE::opecode_hl_rp( CZMA_INFORMATION& info, unsigned char op1 ) {
        -:  715:	int rp;
        -:  716:
       63:  717:	if( words.size() == 4 && words[1] == "HL" && words[2] == "," && info.is_rp( words[3] ) ) {
       12:  718:		if( this->is_data_fixed ) {
        8:  719:			return true;
        -:  720:		}
        4:  721:		this->is_data_fixed = true;
        4:  722:		rp = info.rp_id[words[3]];
        4:  723:		this->set_code_size( &info, 1 );
        4:  724:		this->data.push_back( op1 | (rp << 4) );
        4:  725:		return true;
        -:  726:	}
       51:  727:	if( words.size() == 4 && words[1] == "IX" && words[2] == "," && info.is_ix_rp( words[3] ) ) {
       21:  728:		if( this->is_data_fixed ) {
       14:  729:			return true;
        -:  730:		}
        7:  731:		this->is_data_fixed = true;
        7:  732:		rp = info.ix_rp_id[words[3]];
        7:  733:		this->set_code_size( &info, 2 );
        7:  734:		this->data.push_back( 0xDD );
        7:  735:		this->data.push_back( op1 | (rp << 4) );
        7:  736:		return true;
        -:  737:	}
       30:  738:	if( words.size() == 4 && words[1] == "IY" && words[2] == "," && info.is_iy_rp( words[3] ) ) {
       21:  739:		if( this->is_data_fixed ) {
       14:  740:			return true;
        -:  741:		}
        7:  742:		this->is_data_fixed = true;
        7:  743:		rp = info.iy_rp_id[words[3]];
        7:  744:		this->set_code_size( &info, 2 );
        7:  745:		this->data.push_back( 0xFD );
        7:  746:		this->data.push_back( op1 | (rp << 4) );
        7:  747:		return true;
        -:  748:	}
        9:  749:	return false;
        -:  750:}
        -:  751:
        -:  752:// --------------------------------------------------------------------
       30:  753:bool CZMA_PARSE::opecode_hl_rp_witnout_ix( CZMA_INFORMATION& info, unsigned char op1, unsigned char op2 ) {
        -:  754:	int rp;
        -:  755:
       30:  756:	if( words.size() == 4 && words[1] == "HL" && words[2] == "," && info.is_rp( words[3] ) ) {
       24:  757:		if( this->is_data_fixed ) {
       16:  758:			return true;
        -:  759:		}
        8:  760:		this->is_data_fixed = true;
        8:  761:		rp = info.rp_id[words[3]];
        8:  762:		this->set_code_size( &info, 2 );
        8:  763:		this->data.push_back( op1 );
        8:  764:		this->data.push_back( op2 | (rp << 4) );
        8:  765:		return true;
        -:  766:	}
        6:  767:	return false;
        -:  768:}
        -:  769:
        -:  770:// --------------------------------------------------------------------
      793:  771:bool CZMA_PARSE::opecode_ddd_ref_hl( CZMA_INFORMATION& info, unsigned char op1 ) {
        -:  772:	int ddd, index;
     1586:  773:	CVALUE d;
        -:  774:
      793:  775:	if( words.size() < 6 || !info.is_sss_or_ddd( words[1] ) || words[2] != "," || (!check_location_hl( 3 ) && !check_location_ix( 3 ) && !check_location_iy( 3 )) ) {
      706:  776:		return false;
        -:  777:	}
       87:  778:	ddd = info.sss_or_ddd_id[words[1]];
       87:  779:	if( words.size() >= 6 && check_location_ix( 3 ) ) {
       33:  780:		this->set_code_size( &info, 3 );
       33:  781:		if( words[5] == "+" || words[5] == "-" ) {
       30:  782:			index = this->expression( info, 5, d );
       30:  783:			if( index == 0 ) {
    #####:  784:				return false;
        -:  785:			}
       30:  786:			if( d.type != CVALUE::CV_INTEGER ) {
    #####:  787:				put_error( "Illegal operand." );
    #####:  788:				return false;
        -:  789:			}
       30:  790:			if( d.i < -128 || d.i > 127 ) {
        6:  791:				put_error( "Offset value is out of range (" + std::to_string( d.i ) + ")." );
        6:  792:				return false;
        -:  793:			}
       24:  794:			if( (int)words.size() > (index + 1) ) {
        3:  795:				put_error( "There is an extra account that can not be interpreted." );
        3:  796:				return false;
        -:  797:			}
        -:  798:		}
        -:  799:		else {
        3:  800:			if( words.size() > 6 ) {
    #####:  801:				put_error( "There is an extra account that can not be interpreted." );
    #####:  802:				return false;
        -:  803:			}
        3:  804:			d.i = 0;
        -:  805:		}
       24:  806:		if( this->is_data_fixed ) {
       16:  807:			return true;
        -:  808:		}
        8:  809:		this->is_data_fixed = true;
        8:  810:		this->data.push_back( 0xDD );
        8:  811:		this->data.push_back( op1 | (ddd << 3) );
        8:  812:		this->data.push_back( d.i );
        8:  813:		return true;
        -:  814:	}
       54:  815:	else if( words.size() >= 6 && check_location_iy( 3 ) ) {
       30:  816:		this->set_code_size( &info, 3 );
       30:  817:		if( words[5] == "+" || words[5] == "-" ) {
       27:  818:			index = this->expression( info, 5, d );
       27:  819:			if( index == 0 ) {
    #####:  820:				return false;
        -:  821:			}
       27:  822:			if( d.type != CVALUE::CV_INTEGER ) {
    #####:  823:				put_error( "Illegal operand." );
    #####:  824:				return false;
        -:  825:			}
       27:  826:			if( d.i < -128 || d.i > 127 ) {
        6:  827:				put_error( "Offset value is out of range (" + std::to_string( d.i ) + ")." );
        6:  828:				return false;
        -:  829:			}
       21:  830:			if( (int)words.size() > (index + 1) ) {
    #####:  831:				put_error( "There is an extra account that can not be interpreted." );
    #####:  832:				return false;
        -:  833:			}
        -:  834:		}
        -:  835:		else {
        3:  836:			if( words.size() > 6 ) {
    #####:  837:				put_error( "There is an extra account that can not be interpreted." );
    #####:  838:				return false;
        -:  839:			}
        3:  840:			d.i = 0;
        -:  841:		}
       24:  842:		if( this->is_data_fixed ) {
       16:  843:			return true;
        -:  844:		}
        8:  845:		this->is_data_fixed = true;
        8:  846:		this->data.push_back( 0xFD );
        8:  847:		this->data.push_back( op1 | (ddd << 3) );
        8:  848:		this->data.push_back( d.i );
        8:  849:		return true;
        -:  850:	}
       24:  851:	else if( words.size() == 6 ) {
       24:  852:		if( this->is_data_fixed ) {
       16:  853:			return true;
        -:  854:		}
        8:  855:		this->set_code_size( &info, 1 );
        8:  856:		this->is_data_fixed = true;
        8:  857:		this->data.push_back( op1 | (ddd << 3) );
        8:  858:		return true;
        -:  859:	}
    #####:  860:	return true;
        -:  861:}
        -:  862:
        -:  863:// --------------------------------------------------------------------
      201:  864:bool CZMA_PARSE::opecode_a_ref_hl( CZMA_INFORMATION& info, unsigned char op1 ) {
      402:  865:	CVALUE d;
        -:  866:
      201:  867:	if( words.size() < 6 || words[1] != "A" || words[2] != "," || (!check_location_hl( 3 ) && !check_location_ix( 3 ) && !check_location_iy( 3 )) ) {
      120:  868:		return false;
        -:  869:	}
       81:  870:	if( words.size() >= 6 && check_location_ix( 3 ) ) {
       30:  871:		this->set_code_size( &info, 3 );
       30:  872:		if( words[5] == "+" || words[5] == "-" ) {
       27:  873:			if( !this->expression( info, 5, d ) ) {
    #####:  874:				return false;
        -:  875:			}
       27:  876:			if( d.type != CVALUE::CV_INTEGER ) {
    #####:  877:				put_error( "Illegal operand." );
    #####:  878:				return false;
        -:  879:			}
       27:  880:			if( d.i < -128 || d.i > 127 ) {
    #####:  881:				put_error( "Offset value is out of range (" + std::to_string( d.i ) + ")." );
    #####:  882:				return false;
        -:  883:			}
        -:  884:		}
        -:  885:		else {
        3:  886:			d.i = 0;
        -:  887:		}
       30:  888:		if( this->is_data_fixed ) {
       20:  889:			return true;
        -:  890:		}
       10:  891:		this->is_data_fixed = true;
       10:  892:		this->data.push_back( 0xDD );
       10:  893:		this->data.push_back( op1 );
       10:  894:		this->data.push_back( d.i );
       10:  895:		return true;
        -:  896:	}
       51:  897:	else if( words.size() >= 6 && check_location_iy( 3 ) ) {
       24:  898:		this->set_code_size( &info, 3 );
       24:  899:		if( words[5] == "+" || words[5] == "-" ) {
       24:  900:			if( !this->expression( info, 5, d ) ) {
    #####:  901:				return false;
        -:  902:			}
       24:  903:			if( d.type != CVALUE::CV_INTEGER ) {
    #####:  904:				put_error( "Illegal operand." );
    #####:  905:				return false;
        -:  906:			}
       24:  907:			if( d.i < -128 || d.i > 127 ) {
    #####:  908:				put_error( "Offset value is out of range (" + std::to_string( d.i ) + ")." );
    #####:  909:				return false;
        -:  910:			}
        -:  911:		}
        -:  912:		else {
    #####:  913:			d.i = 0;
        -:  914:		}
       24:  915:		if( this->is_data_fixed ) {
       16:  916:			return true;
        -:  917:		}
        8:  918:		this->is_data_fixed = true;
        8:  919:		this->data.push_back( 0xFD );
        8:  920:		this->data.push_back( op1 );
        8:  921:		this->data.push_back( d.i );
        8:  922:		return true;
        -:  923:	}
       27:  924:	else if( words.size() == 6 ) {
       24:  925:		if( this->is_data_fixed ) {
       16:  926:			return true;
        -:  927:		}
        8:  928:		this->set_code_size( &info, 1 );
        8:  929:		this->is_data_fixed = true;
        8:  930:		this->data.push_back( op1 );
        8:  931:		return true;
        -:  932:	}
        3:  933:	return false;
        -:  934:}
        -:  935:
        -:  936:// --------------------------------------------------------------------
       78:  937:bool CZMA_PARSE::opecode_ref_hl( CZMA_INFORMATION& info, unsigned char op1 ) {
      156:  938:	CVALUE d;
        -:  939:	int index;
        -:  940:
       78:  941:	if( words.size() < 4 || !(check_location_hl( 1 ) || check_location_ix( 1 ) || check_location_iy( 1 )) ) {
       42:  942:		return false;
        -:  943:	}
       36:  944:	if( check_location_ix( 1 ) ) {
       15:  945:		this->set_code_size( &info, 3 );
       15:  946:		if( words[3] == "+" || words[3] == "-" ) {
       12:  947:			index = this->expression( info, 3, d );
       12:  948:			if( index == 0 ) {
    #####:  949:				put_error( "Illegal operand." );
    #####:  950:				return false;
        -:  951:			}
       12:  952:			if( d.type != CVALUE::CV_INTEGER ) {
    #####:  953:				put_error( "Illegal operand." );
    #####:  954:				return false;
        -:  955:			}
       12:  956:			if( (index + 1) < (int) words.size() ) {
    #####:  957:				put_error( "Illegal operand." );
    #####:  958:				return false;
        -:  959:			}
       12:  960:			if( d.i < -128 || d.i > 127 ) {
        6:  961:				put_error( "Offset value is out of range (" + std::to_string( d.i ) + ")." );
        6:  962:				return false;
        -:  963:			}
        -:  964:		}
        -:  965:		else {
        3:  966:			d.i = 0;
        -:  967:		}
        9:  968:		if( this->is_data_fixed ) {
        6:  969:			return true;
        -:  970:		}
        3:  971:		this->is_data_fixed = true;
        3:  972:		this->data.push_back( 0xDD );
        3:  973:		this->data.push_back( op1 );
        3:  974:		this->data.push_back( d.i );
        -:  975:	}
       21:  976:	else if( check_location_iy( 1 ) ) {
       15:  977:		this->set_code_size( &info, 3 );
       15:  978:		if( words[3] == "+" || words[3] == "-" ) {
       12:  979:			index = this->expression( info, 3, d );
       12:  980:			if( index == 0 ) {
    #####:  981:				put_error( "Illegal operand." );
    #####:  982:				return false;
        -:  983:			}
       12:  984:			if( d.type != CVALUE::CV_INTEGER ) {
    #####:  985:				put_error( "Illegal operand." );
    #####:  986:				return false;
        -:  987:			}
       12:  988:			if( (index + 1) < (int) words.size() ) {
    #####:  989:				put_error( "Illegal operand." );
    #####:  990:				return false;
        -:  991:			}
       12:  992:			if( d.i < -128 || d.i > 127 ) {
        6:  993:				put_error( "Offset value is out of range (" + std::to_string( d.i ) + ")." );
        6:  994:				return false;
        -:  995:			}
        -:  996:		}
        -:  997:		else {
        3:  998:			d.i = 0;
        -:  999:		}
        9: 1000:		if( this->is_data_fixed ) {
        6: 1001:			return true;
        -: 1002:		}
        3: 1003:		this->is_data_fixed = true;
        3: 1004:		this->data.push_back( 0xFD );
        3: 1005:		this->data.push_back( op1 );
        3: 1006:		this->data.push_back( d.i );
        -: 1007:	}
        -: 1008:	else {
        6: 1009:		if( this->is_data_fixed ) {
        4: 1010:			return true;
        -: 1011:		}
        2: 1012:		this->set_code_size( &info, 1 );
        2: 1013:		this->is_data_fixed = true;
        2: 1014:		this->data.push_back( op1 );
        -: 1015:	}
        8: 1016:	return true;
        -: 1017:}
        -: 1018:
        -: 1019:// --------------------------------------------------------------------
      712: 1020:bool CZMA_PARSE::opecode_ddd_n( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1021:	int ddd;
     1424: 1022:	CVALUE imm8;
        -: 1023:
      712: 1024:	if( words.size() < 4 || (!info.is_sss_or_ddd( words[1] ) && !info.is_ix_hl( words[1] ) && !info.is_iy_hl( words[1] )) || words[2] != "," || words[3] == "[" ) {
      579: 1025:		return false;
        -: 1026:	}
      133: 1027:	if( info.is_sss_or_ddd( words[1] ) ) {
       73: 1028:		this->set_code_size( &info, 2 );
        -: 1029:	}
       60: 1030:	else if( info.is_ix_hl( words[1] ) ) {
       30: 1031:		this->set_code_size( &info, 3 );
        -: 1032:	}
        -: 1033:	else {
       30: 1034:		this->set_code_size( &info, 3 );
        -: 1035:	}
      133: 1036:	if( !this->expression( info, 3, imm8 ) ) {
       72: 1037:		return false;
        -: 1038:	}
       61: 1039:	if( imm8.type != CVALUE::CV_INTEGER ) {
    #####: 1040:		put_error( "Illegal operand." );
    #####: 1041:		return false;
        -: 1042:	}
       61: 1043:	if( imm8.i < -128 || imm8.i > 255) {
        3: 1044:		put_error( "Operand is out of range." );
        3: 1045:		return false;
        -: 1046:	}
       58: 1047:	if( this->is_data_fixed ) {
       39: 1048:		return true;
        -: 1049:	}
       19: 1050:	this->is_data_fixed = true;
       19: 1051:	if( info.is_sss_or_ddd( words[1] ) ) {
       15: 1052:		ddd = info.sss_or_ddd_id[words[1]];
        -: 1053:	}
        4: 1054:	else if( info.is_ix_hl( words[1] ) ) {
        2: 1055:		ddd = info.ix_hl[words[1]];
        2: 1056:		this->data.push_back( 0xDD );
        -: 1057:	}
        -: 1058:	else {
        2: 1059:		ddd = info.iy_hl[words[1]];
        2: 1060:		this->data.push_back( 0xFD );
        -: 1061:	}
       19: 1062:	this->data.push_back( op1 | (ddd << 3) );
       19: 1063:	this->data.push_back( imm8.i );
       19: 1064:	return true;
        -: 1065:}
        -: 1066:
        -: 1067:// --------------------------------------------------------------------
      180: 1068:bool CZMA_PARSE::opecode_a_n( CZMA_INFORMATION& info, unsigned char op1 ) {
      360: 1069:	CVALUE imm8;
        -: 1070:
      180: 1071:	if( words.size() < 4 || words[1] != "A" || words[2] != "," || words[3] == "[" ) {
      129: 1072:		return false;
        -: 1073:	}
       51: 1074:	this->set_code_size( &info, 2 );
       51: 1075:	if( !this->expression( info, 3, imm8 ) ) {
       24: 1076:		return false;
        -: 1077:	}
       27: 1078:	if( imm8.type != CVALUE::CV_INTEGER ) {
    #####: 1079:		put_error( "Illegal operand." );
    #####: 1080:		return false;
        -: 1081:	}
       27: 1082:	if( this->is_data_fixed ) {
       18: 1083:		return true;
        -: 1084:	}
        9: 1085:	this->is_data_fixed = true;
        9: 1086:	this->data.push_back( op1 );
        9: 1087:	this->data.push_back( imm8.i );
        9: 1088:	return true;
        -: 1089:}
        -: 1090:
        -: 1091:// --------------------------------------------------------------------
      114: 1092:bool CZMA_PARSE::opecode_rp( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1093:	int rp;
        -: 1094:
      114: 1095:	if( words.size() != 2 || (!info.is_rp( words[1] ) && words[1] != "IX" && words[1] != "IY") ) {
       78: 1096:		return false;
        -: 1097:	}
       36: 1098:	if( this->is_data_fixed ) {
       24: 1099:		return true;
        -: 1100:	}
       12: 1101:	this->is_data_fixed = true;
       12: 1102:	if( words[1] == "IX" ) {
        2: 1103:		rp = 2;
        2: 1104:		this->set_code_size( &info, 2 );
        2: 1105:		this->data.push_back( 0xDD );
        -: 1106:	}
       10: 1107:	else if( words[1] == "IY" ) {
        2: 1108:		rp = 2;
        2: 1109:		this->set_code_size( &info, 2 );
        2: 1110:		this->data.push_back( 0xFD );
        -: 1111:	}
        -: 1112:	else {
        8: 1113:		rp = info.rp_id[words[1]];
        8: 1114:		this->set_code_size( &info, 1 );
        -: 1115:	}
       12: 1116:	this->data.push_back( op1 | (rp << 4) );
       12: 1117:	return true;
        -: 1118:}
        -: 1119:
        -: 1120:// --------------------------------------------------------------------
      645: 1121:bool CZMA_PARSE::opecode_rp_nn( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1122:	int rp;
     1290: 1123:	CVALUE nn;
        -: 1124:
      645: 1125:	if( words.size() < 4 || (!info.is_rp( words[1] ) && words[1] != "IX" && words[1] != "IY") || words[2] != "," || words[3] == "[" ) {
      282: 1126:		return false;
        -: 1127:	}
      363: 1128:	if( words[1] == "IX" || words[1] == "IY" ) {
        6: 1129:		this->set_code_size( &info, 4 );
        -: 1130:	}
        -: 1131:	else {
      357: 1132:		this->set_code_size( &info, 3 );
        -: 1133:	}
      363: 1134:	if( !this->expression( info, 3, nn ) ) {
       94: 1135:		put_error( "Illegal operand." );
       94: 1136:		return false;
        -: 1137:	}
      269: 1138:	if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1139:		put_error( "Illegal operand." );
    #####: 1140:		return false;
        -: 1141:	}
      269: 1142:	if( nn.i < -32768 || nn.i > 65535 ) {
        3: 1143:		put_error( "Operand is out of range." );
        3: 1144:		return false;
        -: 1145:	}
      266: 1146:	if( this->is_data_fixed ) {
      177: 1147:		return true;
        -: 1148:	}
       89: 1149:	this->is_data_fixed = true;
       89: 1150:	if( words[1] == "IX" ) {
        1: 1151:		rp = 2;
        1: 1152:		this->data.push_back( 0xDD );
        -: 1153:	}
       88: 1154:	else if( words[1] == "IY" ) {
        1: 1155:		rp = 2;
        1: 1156:		this->data.push_back( 0xFD );
        -: 1157:	}
        -: 1158:	else {
       87: 1159:		rp = info.rp_id[words[1]];
        -: 1160:	}
       89: 1161:	this->data.push_back( op1 | (rp << 4) );
       89: 1162:	this->data.push_back( nn.i & 255 );
       89: 1163:	this->data.push_back( (nn.i >> 8) & 255 );
       89: 1164:	return true;
        -: 1165:}
        -: 1166:
        -: 1167:// --------------------------------------------------------------------
      379: 1168:bool CZMA_PARSE::opecode_rp_ref_nn( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c ) {
        -: 1169:	int rp;
      758: 1170:	CVALUE nn;
        -: 1171:
      379: 1172:	if( words.size() < 6 || (!info.is_rp( words[1] ) && words[1] != "IX" && words[1] != "IY") || words[2] != "," || words[3] != "[" ) {
      355: 1173:		return false;
        -: 1174:	}
       24: 1175:	if( words[1] == "HL" ) {
        9: 1176:		this->set_code_size( &info, 3 );
        -: 1177:	}
        -: 1178:	else {
       15: 1179:		this->set_code_size( &info, 4 );
        -: 1180:	}
       24: 1181:	if( !this->expression( info, 4, nn ) ) {
    #####: 1182:		put_error( "Illegal operand." );
    #####: 1183:		return false;
        -: 1184:	}
       24: 1185:	if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1186:		put_error( "Illegal operand." );
    #####: 1187:		return false;
        -: 1188:	}
       24: 1189:	if( nn.i < -32768 || nn.i > 65535 ) {
    #####: 1190:		put_error( "Operand is out of range." );
    #####: 1191:		return false;
        -: 1192:	}
       24: 1193:	if( this->is_data_fixed ) {
       16: 1194:		return true;
        -: 1195:	}
        8: 1196:	this->is_data_fixed = true;
        8: 1197:	if( words[1] == "HL" ) {
        3: 1198:		this->data.push_back( op1 );
        -: 1199:	}
        5: 1200:	else if( words[1] == "IX" ) {
        1: 1201:		this->data.push_back( 0xDD );
        1: 1202:		this->data.push_back( op1 );
        -: 1203:	}
        4: 1204:	else if( words[1] == "IY" ) {
        1: 1205:		this->data.push_back( 0xFD );
        1: 1206:		this->data.push_back( op1 );
        -: 1207:	}
        -: 1208:	else {
        3: 1209:		rp = info.rp_id[words[1]];
        3: 1210:		this->data.push_back( 0xED );
        3: 1211:		this->data.push_back( op1c | (rp << 4) );
        -: 1212:	}
        8: 1213:	this->data.push_back( nn.i & 255 );
        8: 1214:	this->data.push_back( (nn.i >> 8) & 255 );
        8: 1215:	return true;
        -: 1216:}
        -: 1217:
        -: 1218:// --------------------------------------------------------------------
      355: 1219:bool CZMA_PARSE::opecode_ref_hl_sss( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1220:	int i, sss;
      710: 1221:	CVALUE nn;
        -: 1222:
      355: 1223:	if( words[1] != "[" ) {
      226: 1224:		return false;
        -: 1225:	}
      129: 1226:	for( i = 2; i < (int)words.size() && words[i] != "]"; i++ ) {
        -: 1227:	}
      129: 1228:	if( i >= (int)words.size() ) {
    #####: 1229:		return false;
        -: 1230:	}
      129: 1231:	if( words[i + 1] != "," || !info.is_sss_or_ddd( words[i + 2] ) ) {
       42: 1232:		return false;
        -: 1233:	}
       87: 1234:	sss = info.sss_or_ddd_id[words[i + 2]];
       87: 1235:	if( this->check_location_hl( 1 ) ) {
       18: 1236:		if( this->is_data_fixed ) {
       12: 1237:			return true;
        -: 1238:		}
        6: 1239:		this->set_code_size( &info, 1 );
        6: 1240:		this->is_data_fixed = true;
        6: 1241:		this->data.push_back( op1 | sss );
        6: 1242:		return true;
        -: 1243:	}
       69: 1244:	if( this->check_location_ix( 1 ) ) {
       30: 1245:		this->set_code_size( &info, 3 );
       30: 1246:		if( words[3] == "+" || words[3] == "-" ) {
       27: 1247:			if( !this->expression( info, 3, nn ) ) {
    #####: 1248:				put_error( "Illegal operand." );
    #####: 1249:				return false;
        -: 1250:			}
       27: 1251:			if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1252:				put_error( "Illegal operand." );
    #####: 1253:				return false;
        -: 1254:			}
       27: 1255:			if( nn.i < -128 || nn.i > 127 ) {
        6: 1256:				put_error( "Offset value is out of range (" + std::to_string(nn.i) + ")." );
        6: 1257:				return false;
        -: 1258:			}
        -: 1259:		}
        -: 1260:		else {
        3: 1261:			nn.i = 0;
        -: 1262:		}
       24: 1263:		if( this->is_data_fixed ) {
       16: 1264:			return true;
        -: 1265:		}
        8: 1266:		this->is_data_fixed = true;
        8: 1267:		this->data.push_back( 0xDD );
        8: 1268:		this->data.push_back( op1 | sss );
        8: 1269:		this->data.push_back( nn.i );
        8: 1270:		return true;
        -: 1271:	}
       39: 1272:	if( this->check_location_iy( 1 ) ) {
       30: 1273:		this->set_code_size( &info, 3 );
       30: 1274:		if( words[3] == "+" || words[3] == "-" ) {
       27: 1275:			if( !this->expression( info, 3, nn ) ) {
    #####: 1276:				put_error( "Illegal operand." );
    #####: 1277:				return false;
        -: 1278:			}
       27: 1279:			if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1280:				put_error( "Illegal operand." );
    #####: 1281:				return false;
        -: 1282:			}
       27: 1283:			if( nn.i < -128 || nn.i > 127 ) {
        6: 1284:				put_error( "Offset value is out of range (" + std::to_string( nn.i ) + ")." );
        6: 1285:				return false;
        -: 1286:			}
        -: 1287:		}
        -: 1288:		else {
        3: 1289:			nn.i = 0;
        -: 1290:		}
       24: 1291:		if( this->is_data_fixed ) {
       16: 1292:			return true;
        -: 1293:		}
        8: 1294:		this->is_data_fixed = true;
        8: 1295:		this->data.push_back( 0xFD );
        8: 1296:		this->data.push_back( op1 | sss );
        8: 1297:		this->data.push_back( nn.i );
        8: 1298:		return true;
        -: 1299:	}
        9: 1300:	return false;
        -: 1301:}
        -: 1302:
        -: 1303:// --------------------------------------------------------------------
      289: 1304:bool CZMA_PARSE::opecode_ref_hl_n( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1305:	int i;
      578: 1306:	CVALUE n, d;
        -: 1307:
      289: 1308:	if( words[1] != "[" ) {
      226: 1309:		return false;
        -: 1310:	}
       63: 1311:	for( i = 2; i < (int) words.size() && words[i] != "]"; i++ ) {
        -: 1312:	}
       63: 1313:	if( i >= (int) words.size() ) {
    #####: 1314:		return false;
        -: 1315:	}
       63: 1316:	if( words[i + 1] != "," || info.is_sss_or_ddd( words[i + 2] ) ) {
       21: 1317:		return false;
        -: 1318:	}
       42: 1319:	if( this->check_location_hl( 1 ) ) {
        6: 1320:		if( !this->expression( info, i + 2, n ) ) {
        3: 1321:			put_error( "Illegal operand." );
        3: 1322:			return false;
        -: 1323:		}
        3: 1324:		if( n.type != CVALUE::CV_INTEGER ) {
    #####: 1325:			put_error( "Illegal operand." );
    #####: 1326:			return false;
        -: 1327:		}
        3: 1328:		if( n.i < -128 || n.i > 255 ) {
    #####: 1329:			put_error( "Operand is out of range." );
    #####: 1330:			return false;
        -: 1331:		}
        3: 1332:		this->set_code_size( &info, 2 );
        3: 1333:		if( this->is_data_fixed ) {
        2: 1334:			return true;
        -: 1335:		}
        1: 1336:		this->is_data_fixed = true;
        1: 1337:		this->data.push_back( op1 );
        1: 1338:		this->data.push_back( n.i & 255 );
        1: 1339:		return true;
        -: 1340:	}
       36: 1341:	if( this->check_location_ix( 1 ) ) {
       12: 1342:		if( words[3] == "+" || words[3] == "-" ) {
       12: 1343:			if( !this->expression( info, 3, d ) ) {
    #####: 1344:				put_error( "Illegal operand." );
    #####: 1345:				return false;
        -: 1346:			}
       12: 1347:			if( d.type != CVALUE::CV_INTEGER ) {
    #####: 1348:				put_error( "Illegal operand." );
    #####: 1349:				return false;
        -: 1350:			}
       12: 1351:			if( d.i < -128 || d.i > 127 ) {
    #####: 1352:				put_error( "Offset value is out of range (" + std::to_string( d.i ) + ")." );
    #####: 1353:				return false;
        -: 1354:			}
        -: 1355:		}
        -: 1356:		else {
    #####: 1357:			d.i = 0;
        -: 1358:		}
       12: 1359:		if( !this->expression( info, i + 2, n ) ) {
        9: 1360:			put_error( "Illegal operand." );
        9: 1361:			return false;
        -: 1362:		}
        3: 1363:		if( n.type != CVALUE::CV_INTEGER ) {
    #####: 1364:			put_error( "Illegal operand." );
    #####: 1365:			return false;
        -: 1366:		}
        3: 1367:		if( n.i < -128 || n.i > 255 ) {
    #####: 1368:			put_error( "Operand is out of range." );
    #####: 1369:			return false;
        -: 1370:		}
        3: 1371:		this->set_code_size( &info, 4 );
        3: 1372:		if( this->is_data_fixed ) {
        2: 1373:			return true;
        -: 1374:		}
        1: 1375:		this->is_data_fixed = true;
        1: 1376:		this->data.push_back( 0xDD );
        1: 1377:		this->data.push_back( op1 );
        1: 1378:		this->data.push_back( d.i );
        1: 1379:		this->data.push_back( n.i & 255 );
        1: 1380:		return true;
        -: 1381:	}
       24: 1382:	if( this->check_location_iy( 1 ) ) {
        3: 1383:		if( words[3] == "+" || words[3] == "-" ) {
        3: 1384:			if( !this->expression( info, 3, d ) ) {
    #####: 1385:				put_error( "Illegal operand." );
    #####: 1386:				return false;
        -: 1387:			}
        3: 1388:			if( d.type != CVALUE::CV_INTEGER ) {
    #####: 1389:				put_error( "Illegal operand." );
    #####: 1390:				return false;
        -: 1391:			}
        3: 1392:			if( d.i < -128 || d.i > 127 ) {
    #####: 1393:				put_error( "Offset value is out of range (" + std::to_string( d.i ) + ")." );
    #####: 1394:				return false;
        -: 1395:			}
        -: 1396:		}
        -: 1397:		else {
    #####: 1398:			d.i = 0;
        -: 1399:		}
        3: 1400:		if( !this->expression( info, i + 2, n ) ) {
    #####: 1401:			put_error( "Illegal operand." );
    #####: 1402:			return false;
        -: 1403:		}
        3: 1404:		if( n.type != CVALUE::CV_INTEGER ) {
    #####: 1405:			put_error( "Illegal operand." );
    #####: 1406:			return false;
        -: 1407:		}
        3: 1408:		if( n.i < -128 || n.i > 255 ) {
    #####: 1409:			put_error( "Operand is out of range." );
    #####: 1410:			return false;
        -: 1411:		}
        3: 1412:		this->set_code_size( &info, 4 );
        3: 1413:		if( this->is_data_fixed ) {
        2: 1414:			return true;
        -: 1415:		}
        1: 1416:		this->is_data_fixed = true;
        1: 1417:		this->data.push_back( 0xFD );
        1: 1418:		this->data.push_back( op1 );
        1: 1419:		this->data.push_back( d.i );
        1: 1420:		this->data.push_back( n.i & 255 );
        1: 1421:		return true;
        -: 1422:	}
       21: 1423:	return false;
        -: 1424:}
        -: 1425:
        -: 1426:// --------------------------------------------------------------------
      721: 1427:bool CZMA_PARSE::opecode_a_ref_bc( CZMA_INFORMATION& info, unsigned char op1 ) {
     1442: 1428:	CVALUE nn;
        -: 1429:	int index;
        -: 1430:
      721: 1431:	if( words.size() == 6 && words[1] == "A" && words[2] == "," && words[3] == "[" && words[4] == "BC" && words[5] == "]" ) {
        3: 1432:		if( this->is_data_fixed ) {
        2: 1433:			return true;
        -: 1434:		}
        1: 1435:		this->set_code_size( &info, 1 );
        1: 1436:		this->is_data_fixed = true;
        1: 1437:		this->data.push_back( op1 | 0x00 );
        1: 1438:		return true;
        -: 1439:	}
      718: 1440:	if( words.size() == 6 && words[1] == "A" && words[2] == "," && words[3] == "[" && words[4] == "DE" && words[5] == "]" ) {
        3: 1441:		if( this->is_data_fixed ) {
        2: 1442:			return true;
        -: 1443:		}
        1: 1444:		this->set_code_size( &info, 1 );
        1: 1445:		this->is_data_fixed = true;
        1: 1446:		this->data.push_back( op1 | 0x10 );
        1: 1447:		return true;
        -: 1448:	}
      715: 1449:	if( words.size() >= 6 && words[1] == "A" && words[2] == "," && words[3] == "[" ) {
       42: 1450:		this->set_code_size( &info, 3 );
       42: 1451:		index = this->expression( info, 4, nn );
       42: 1452:		if( index == 0 ) {
        -: 1453:			//	\AG[o
       39: 1454:			return false;	//	}b` false
        -: 1455:		}
        3: 1456:		if( words[index] != "]" ) {
    #####: 1457:			put_error( "Illegal operand." );
    #####: 1458:			return false;
        -: 1459:		}
        3: 1460:		if( (index + 1) < (int)words.size() ) {
    #####: 1461:			put_error( "Illegal operand." );
    #####: 1462:			return false;
        -: 1463:		}
        3: 1464:		if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1465:			put_error( "Illegal operand." );
    #####: 1466:			return false;
        -: 1467:		}
        3: 1468:		if( nn.i < -32768 || nn.i > 65535 ) {
    #####: 1469:			put_error( "Operand is out of range." );
    #####: 1470:			return false;
        -: 1471:		}
        3: 1472:		if( this->is_data_fixed ) {
        2: 1473:			return true;
        -: 1474:		}
        1: 1475:		this->is_data_fixed = true;
        1: 1476:		this->data.push_back( op1 | 0x30 );
        1: 1477:		this->data.push_back( nn.i & 255 );
        1: 1478:		this->data.push_back( (nn.i >> 8) & 255 );
        1: 1479:		return true;
        -: 1480:	}
      673: 1481:	return false;
        -: 1482:}
        -: 1483:
        -: 1484:// --------------------------------------------------------------------
      280: 1485:bool CZMA_PARSE::opecode_ref_bc_a( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1486:	int i;
      560: 1487:	CVALUE nn;
        -: 1488:
      280: 1489:	if( words.size() == 6 && words[1] == "[" && words[2] == "BC" && words[3] == "]" && words[4] == "," && words[5] == "A" ) {
        3: 1490:		if( this->is_data_fixed ) {
        2: 1491:			return true;
        -: 1492:		}
        1: 1493:		this->set_code_size( &info, 1 );
        1: 1494:		this->is_data_fixed = true;
        1: 1495:		this->data.push_back( op1 | 0x00 );
        1: 1496:		return true;
        -: 1497:	}
      277: 1498:	if( words.size() == 6 && words[1] == "[" && words[2] == "DE" && words[3] == "]" && words[4] == "," && words[5] == "A" ) {
        3: 1499:		if( this->is_data_fixed ) {
        2: 1500:			return true;
        -: 1501:		}
        1: 1502:		this->set_code_size( &info, 1 );
        1: 1503:		this->is_data_fixed = true;
        1: 1504:		this->data.push_back( op1 | 0x10 );
        1: 1505:		return true;
        -: 1506:	}
      274: 1507:	for( i = 2; i < (int)words.size() && words[i] != "]"; i++ ) {
        -: 1508:	}
      274: 1509:	if( i >= (int)words.size() ) {
      211: 1510:		return false;
        -: 1511:	}
       63: 1512:	if( (int)words.size() == (i + 3) && words[1] == "[" && words[i] == "]" && words[i + 1] == "," && words[i + 2] == "A" ) {
       15: 1513:		this->set_code_size( &info, 3 );
       15: 1514:		if( !this->expression( info, 2, nn ) ) {
       12: 1515:			put_error( "Illegal operand." );
       12: 1516:			return false;
        -: 1517:		}
        3: 1518:		if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1519:			put_error( "Illegal operand." );
    #####: 1520:			return false;
        -: 1521:		}
        3: 1522:		if( nn.i < -32768 || nn.i > 65535 ) {
    #####: 1523:			put_error( "Operand is out of range." );
    #####: 1524:			return false;
        -: 1525:		}
        3: 1526:		if( this->is_data_fixed ) {
        2: 1527:			return true;
        -: 1528:		}
        1: 1529:		this->is_data_fixed = true;
        1: 1530:		this->data.push_back( op1 | 0x30 );
        1: 1531:		this->data.push_back( nn.i & 255 );
        1: 1532:		this->data.push_back( (nn.i >> 8) & 255 );
        1: 1533:		return true;
        -: 1534:	}
       48: 1535:	return false;
        -: 1536:}
        -: 1537:
        -: 1538:// --------------------------------------------------------------------
      271: 1539:bool CZMA_PARSE::opecode_ref_nn_rp( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c, unsigned char op2 ) {
        -: 1540:	int i, rp;
      542: 1541:	CVALUE nn;
        -: 1542:
      271: 1543:	if( words[1] != "[" ) {
      226: 1544:		return false;
        -: 1545:	}
       45: 1546:	for( i = 2; i < (int) words.size() && words[i] != "]"; i++ ) {
        -: 1547:	}
       45: 1548:	if( (int)words.size() != (i + 3) || words[i + 1] != "," ) {
       12: 1549:		return false;
        -: 1550:	}
       33: 1551:	if(  words[i + 2] == "HL" ) {
        6: 1552:		this->set_code_size( &info, 3 );
        6: 1553:		if( !this->expression( info, 2, nn ) ) {
        3: 1554:			put_error( "Illegal operand." );
        3: 1555:			return false;
        -: 1556:		}
        3: 1557:		if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1558:			put_error( "Illegal operand." );
    #####: 1559:			return false;
        -: 1560:		}
        3: 1561:		if( nn.i < -32768 || nn.i > 65535 ) {
    #####: 1562:			put_error( "Operand is out of range." );
    #####: 1563:			return false;
        -: 1564:		}
        3: 1565:		if( this->is_data_fixed ) {
        2: 1566:			return true;
        -: 1567:		}
        1: 1568:		this->is_data_fixed = true;
        1: 1569:		this->data.push_back( op1c );
        1: 1570:		this->data.push_back( nn.i & 255 );
        1: 1571:		this->data.push_back( (nn.i >> 8) & 255 );
        1: 1572:		return true;
        -: 1573:	}
       27: 1574:	if( info.is_rp(words[i+2]) ) {
        9: 1575:		this->set_code_size( &info, 4 );
        9: 1576:		if( !this->expression( info, 2, nn ) ) {
    #####: 1577:			put_error( "Illegal operand." );
    #####: 1578:			return false;
        -: 1579:		}
        9: 1580:		if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1581:			put_error( "Illegal operand." );
    #####: 1582:			return false;
        -: 1583:		}
        9: 1584:		if(nn.i < -32768 || nn.i > 65535) {
    #####: 1585:			put_error( "Operand is out of range." );
    #####: 1586:			return false;
        -: 1587:		}
        9: 1588:		rp = info.rp_id[words[i + 2]];
        9: 1589:		if( this->is_data_fixed ) {
        6: 1590:			return true;
        -: 1591:		}
        3: 1592:		this->is_data_fixed = true;
        3: 1593:		this->data.push_back( op1 );
        3: 1594:		this->data.push_back( op2 | (rp << 4) );
        3: 1595:		this->data.push_back( nn.i & 255 );
        3: 1596:		this->data.push_back( (nn.i >> 8) & 255 );
        3: 1597:		return true;
        -: 1598:	}
       18: 1599:	if( words[i + 2] == "IX" ) {
        3: 1600:		this->set_code_size( &info, 4 );
        3: 1601:		if( !this->expression( info, 2, nn ) ) {
    #####: 1602:			put_error( "Illegal operand." );
    #####: 1603:			return false;
        -: 1604:		}
        3: 1605:		if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1606:			put_error( "Illegal operand." );
    #####: 1607:			return false;
        -: 1608:		}
        3: 1609:		if(nn.i < -32768 || nn.i > 65535) {
    #####: 1610:			put_error( "Operand is out of range." );
    #####: 1611:			return false;
        -: 1612:		}
        3: 1613:		if( this->is_data_fixed ) {
        2: 1614:			return true;
        -: 1615:		}
        1: 1616:		this->is_data_fixed = true;
        1: 1617:		this->data.push_back( 0xDD );
        1: 1618:		this->data.push_back( op1c );
        1: 1619:		this->data.push_back( nn.i & 255 );
        1: 1620:		this->data.push_back( (nn.i >> 8) & 255 );
        1: 1621:		return true;
        -: 1622:	}
       15: 1623:	if( words[i + 2] == "IY" ) {
        3: 1624:		this->set_code_size( &info, 4 );
        3: 1625:		if( !this->expression( info, 2, nn ) ) {
    #####: 1626:			put_error( "Illegal operand." );
    #####: 1627:			return false;
        -: 1628:		}
        3: 1629:		if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1630:			put_error( "Illegal operand." );
    #####: 1631:			return false;
        -: 1632:		}
        3: 1633:		if(nn.i < -32768 || nn.i > 65535) {
    #####: 1634:			put_error( "Operand is out of range." );
    #####: 1635:			return false;
        -: 1636:		}
        3: 1637:		if( this->is_data_fixed ) {
        2: 1638:			return true;
        -: 1639:		}
        1: 1640:		this->is_data_fixed = true;
        1: 1641:		this->data.push_back( 0xFD );
        1: 1642:		this->data.push_back( op1c );
        1: 1643:		this->data.push_back( nn.i & 255 );
        1: 1644:		this->data.push_back( (nn.i >> 8) & 255 );
        1: 1645:		return true;
        -: 1646:	}
       12: 1647:	return false;
        -: 1648:}
        -: 1649:
        -: 1650:// --------------------------------------------------------------------
      654: 1651:bool CZMA_PARSE::opecode_sp_hl( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1652:
      654: 1653:	if( words.size() != 4 || words[1] != "SP" || words[2] != "," ) {
      642: 1654:		return false;
        -: 1655:	}
       12: 1656:	if( words[3] == "HL" ) {
        3: 1657:		if( this->is_data_fixed ) {
        2: 1658:			return true;
        -: 1659:		}
        1: 1660:		this->is_data_fixed = true;
        1: 1661:		this->set_code_size( &info, 1 );
        1: 1662:		this->data.push_back( op1 );
        1: 1663:		return true;
        -: 1664:	}
        9: 1665:	if( words[3] == "IX" ) {
        3: 1666:		if( this->is_data_fixed ) {
        2: 1667:			return true;
        -: 1668:		}
        1: 1669:		this->is_data_fixed = true;
        1: 1670:		this->set_code_size( &info, 2 );
        1: 1671:		this->data.push_back( 0xDD );
        1: 1672:		this->data.push_back( op1 );
        1: 1673:		return true;
        -: 1674:	}
        6: 1675:	if( words[3] == "IY" ) {
        3: 1676:		if( this->is_data_fixed ) {
        2: 1677:			return true;
        -: 1678:		}
        1: 1679:		this->is_data_fixed = true;
        1: 1680:		this->set_code_size( &info, 2 );
        1: 1681:		this->data.push_back( 0xFD );
        1: 1682:		this->data.push_back( op1 );
        1: 1683:		return true;
        -: 1684:	}
        3: 1685:	return false;
        -: 1686:}
        -: 1687:
        -: 1688:// --------------------------------------------------------------------
       42: 1689:bool CZMA_PARSE::opecode_rp_with_af( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1690:	int rp;
        -: 1691:
       42: 1692:	if( words.size() != 2 || (!info.is_rp_with_af( words[1] ) && words[1] != "IX" && words[1] != "IY") ) {
        6: 1693:		return false;
        -: 1694:	}
       36: 1695:	if( this->is_data_fixed ) {
       24: 1696:		return true;
        -: 1697:	}
       12: 1698:	this->is_data_fixed = true;
       12: 1699:	if( words[1] == "IX" ) {
        2: 1700:		rp = 2;
        2: 1701:		this->set_code_size( &info, 2 );
        2: 1702:		this->data.push_back( 0xDD );
        -: 1703:	}
       10: 1704:	else if( words[1] == "IY" ) {
        2: 1705:		rp = 2;
        2: 1706:		this->set_code_size( &info, 2 );
        2: 1707:		this->data.push_back( 0xFD );
        -: 1708:	}
        -: 1709:	else {
        8: 1710:		rp = info.rp_with_af_id[words[1]];
        8: 1711:		this->set_code_size( &info, 1 );
        -: 1712:	}
       12: 1713:	this->data.push_back( op1 | (rp << 4) );
       12: 1714:	return true;
        -: 1715:}
        -: 1716:
        -: 1717:// --------------------------------------------------------------------
      246: 1718:bool CZMA_PARSE::opecode_sss( CZMA_INFORMATION& info, unsigned char op1, int op2 ) {
        -: 1719:	int sss, ddd, n;
      492: 1720:	CVALUE nn;
        -: 1721:
      246: 1722:	if( words.size() == 2 && info.is_sss_or_ddd( words[1] ) ) {
      147: 1723:		if( this->is_data_fixed ) {
       98: 1724:			return true;
        -: 1725:		}
       49: 1726:		sss = info.sss_or_ddd_id[words[1]];
       49: 1727:		this->is_data_fixed = true;
       49: 1728:		if( op2 != -1 ) {
       49: 1729:			this->set_code_size( &info, 2 );
       49: 1730:			this->data.push_back( op1 );
       49: 1731:			this->data.push_back( op2 | sss );
        -: 1732:		}
        -: 1733:		else {
    #####: 1734:			this->set_code_size( &info, 1 );
    #####: 1735:			this->data.push_back( op1 | sss );
        -: 1736:		}
       49: 1737:		return true;
        -: 1738:	}
       99: 1739:	if( words.size() == 4 && this->check_location_hl( 1 ) ) {
       21: 1740:		if( this->is_data_fixed ) {
       14: 1741:			return true;
        -: 1742:		}
        7: 1743:		this->is_data_fixed = true;
        7: 1744:		if( op2 != -1 ) {
        7: 1745:			this->set_code_size( &info, 2 );
        7: 1746:			this->data.push_back( op1 );
        7: 1747:			this->data.push_back( op2 | 0x06 );
        -: 1748:		}
        -: 1749:		else {
    #####: 1750:			this->set_code_size( &info, 1 );
    #####: 1751:			this->data.push_back( op1 | 0x06 );
        -: 1752:		}
        7: 1753:		return true;
        -: 1754:	}
       78: 1755:	if( words.size() >= 6 && this->check_location_ix( 1 ) ) {
       36: 1756:		if( op2 != -1 ) {
       36: 1757:			this->set_code_size( &info, 4 );
        -: 1758:		}
        -: 1759:		else {
    #####: 1760:			this->set_code_size( &info, 3 );
        -: 1761:		}
       36: 1762:		if( words[3] == "+" || words[3] == "-" ) {
       36: 1763:			n = this->expression( info, 3, nn );
       36: 1764:			if( n == 0 ) {
    #####: 1765:				put_error( "Illegal operand." );
    #####: 1766:				return false;
        -: 1767:			}
       36: 1768:			if( words[ n ] != "]" ){
    #####: 1769:				put_error( "Illegal operand." );
    #####: 1770:				return false;
        -: 1771:			}
       36: 1772:			if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1773:				put_error( "Illegal operand." );
    #####: 1774:				return false;
        -: 1775:			}
       36: 1776:			if( nn.i < -128 || nn.i > 127 ) {
    #####: 1777:				put_error( "Offset value is out of range (" + std::to_string( nn.i ) + ")." );
    #####: 1778:				return false;
        -: 1779:			}
       36: 1780:			if( words.size() > (unsigned)(n + 2) && words[ n + 1 ] == "," && info.is_sss_or_ddd( words[ n + 2 ] ) ){
       15: 1781:				ddd = info.sss_or_ddd_id[ words[ n + 2 ] ];
        -: 1782:			}
        -: 1783:			else{
       21: 1784:				ddd = 6;
        -: 1785:			}
        -: 1786:		}
        -: 1787:		else {
    #####: 1788:			nn.i = 0;
    #####: 1789:			ddd = 6;
        -: 1790:		}
       36: 1791:		if( this->is_data_fixed ) {
       24: 1792:			return true;
        -: 1793:		}
       12: 1794:		this->is_data_fixed = true;
       12: 1795:		this->data.push_back( 0xDD );
       12: 1796:		if( op2 != -1 ) {
       12: 1797:			this->data.push_back( op1 );
       12: 1798:			this->data.push_back( nn.i );
       12: 1799:			this->data.push_back( op2 | ddd );
        -: 1800:		}
        -: 1801:		else {
    #####: 1802:			this->data.push_back( op1 | ddd );
    #####: 1803:			this->data.push_back( nn.i );
        -: 1804:		}
       12: 1805:		return true;
        -: 1806:	}
       42: 1807:	if( words.size() >= 6 && this->check_location_iy( 1 ) ) {
       21: 1808:		if( op2 != -1 ) {
       21: 1809:			this->set_code_size( &info, 4 );
        -: 1810:		}
        -: 1811:		else {
    #####: 1812:			this->set_code_size( &info, 3 );
        -: 1813:		}
       21: 1814:		if( words[3] == "+" || words[3] == "-" ) {
       21: 1815:			n = this->expression( info, 3, nn );
       21: 1816:			if( n == 0 ){
    #####: 1817:				put_error( "Illegal operand." );
    #####: 1818:				return false;
        -: 1819:			}
       21: 1820:			if( words[ n ] != "]" ){
    #####: 1821:				put_error( "Illegal operand." );
    #####: 1822:				return false;
        -: 1823:			}
       21: 1824:			if( nn.type != CVALUE::CV_INTEGER ) {
    #####: 1825:				put_error( "Illegal operand." );
    #####: 1826:				return false;
        -: 1827:			}
       21: 1828:			if( nn.i < -128 || nn.i > 127 ) {
    #####: 1829:				put_error( "Offset value is out of range (" + std::to_string( nn.i ) + ")." );
    #####: 1830:				return false;
        -: 1831:			}
       21: 1832:			if( words.size() > (unsigned)(n + 2) && words[ n + 1 ] == "," && info.is_sss_or_ddd( words[ n + 2 ] ) ){
    #####: 1833:				ddd = info.sss_or_ddd_id[ words[ n + 2 ] ];
        -: 1834:			}
        -: 1835:			else{
       21: 1836:				ddd = 6;
        -: 1837:			}
        -: 1838:		}
        -: 1839:		else{
    #####: 1840:			nn.i = 0;
    #####: 1841:			ddd = 6;
        -: 1842:		}
       21: 1843:		if( this->is_data_fixed ) {
       14: 1844:			return true;
        -: 1845:		}
        7: 1846:		this->is_data_fixed = true;
        7: 1847:		this->data.push_back( 0xFD );
        7: 1848:		if( op2 != -1 ) {
        7: 1849:			this->data.push_back( op1 );
        7: 1850:			this->data.push_back( nn.i );
        7: 1851:			this->data.push_back( op2 | ddd );
        -: 1852:		}
        -: 1853:		else {
    #####: 1854:			this->data.push_back( op1 | ddd );
    #####: 1855:			this->data.push_back( nn.i );
        -: 1856:		}
        7: 1857:		return true;
        -: 1858:	}
       21: 1859:	return false;
        -: 1860:}
        -: 1861:
        -: 1862:// --------------------------------------------------------------------
       81: 1863:bool CZMA_PARSE::opecode_ccc_nnn( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c ) {
        -: 1864:	int ccc, index;
      162: 1865:	CVALUE address;
        -: 1866:
       81: 1867:	if( words.size() == 2 && (words[1] == "HL" || words[1] == "IX" || words[1] == "IY") ) {
        9: 1868:		return false;
        -: 1869:	}
       72: 1870:	if( words.size() >= 4 && info.is_ccc( words[1] ) ) {
       54: 1871:		this->set_code_size( &info, 3 );
       54: 1872:		index = this->expression( info, 3, address );
       54: 1873:		if( index == 0 ) {
    #####: 1874:			put_error( "Illegal operand." );
    #####: 1875:			return false;
        -: 1876:		}
       54: 1877:		if( address.type != CVALUE::CV_INTEGER ) {
    #####: 1878:			put_error( "Illegal operand." );
    #####: 1879:			return false;
        -: 1880:		}
       54: 1881:		if( index < (int)words.size() ) {
        6: 1882:			return false;
        -: 1883:		}
       48: 1884:		ccc = info.ccc_id[words[1]];
       48: 1885:		if( this->is_data_fixed ) {
       32: 1886:			return true;
        -: 1887:		}
       16: 1888:		this->is_data_fixed = true;
       16: 1889:		this->data.push_back( op1c | (ccc << 3) );
       16: 1890:		this->data.push_back( address.i & 255 );
       16: 1891:		this->data.push_back( (address.i >> 8) & 255 );
       16: 1892:		return true;
        -: 1893:	}
        -: 1894:	else {
       18: 1895:		this->set_code_size( &info, 3 );
       18: 1896:		index = this->expression( info, 1, address );
       18: 1897:		if( index == 0 ) {
    #####: 1898:			put_error( "Illegal operand." );
    #####: 1899:			return false;
        -: 1900:		}
       18: 1901:		if( address.type != CVALUE::CV_INTEGER ) {
        6: 1902:			put_error( "Illegal operand." );
        6: 1903:			return false;
        -: 1904:		}
       12: 1905:		if( index < (int)words.size() ) {
        6: 1906:			return false;
        -: 1907:		}
        6: 1908:		if( this->is_data_fixed ) {
        4: 1909:			return true;
        -: 1910:		}
        2: 1911:		this->is_data_fixed = true;
        2: 1912:		this->data.push_back( op1 );
        2: 1913:		this->data.push_back( address.i & 255 );
        2: 1914:		this->data.push_back( (address.i >> 8) & 255 );
        2: 1915:		return true;
        -: 1916:	}
        -: 1917:	return false;
        -: 1918:}
        -: 1919:
        -: 1920:// --------------------------------------------------------------------
       30: 1921:bool CZMA_PARSE::opecode_ccc_e( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c ) {
        -: 1922:	int address, ccc;
        -: 1923:
       30: 1924:	if( words.size() >= 4 && info.is_cc2( words[1] ) ) {
       15: 1925:		this->set_code_size( &info, 2 );
       15: 1926:		address = this->relative_address( info, 3 );
       15: 1927:		if( address == -9999 ) {
        7: 1928:			return false;
        -: 1929:		}
        8: 1930:		ccc = info.cc2_id[words[1]];
        8: 1931:		if( this->is_data_fixed ) {
        4: 1932:			return true;
        -: 1933:		}
        4: 1934:		this->is_data_fixed = true;
        4: 1935:		this->data.push_back( op1c | (ccc << 3) );
        4: 1936:		this->data.push_back( address );
        4: 1937:		return true;
        -: 1938:	}
       15: 1939:	if( words.size() >= 2 ) {
       15: 1940:		this->set_code_size( &info, 2 );
       15: 1941:		address = this->relative_address( info, 1 );
       15: 1942:		if( address == -9999 ) {
       13: 1943:			return false;
        -: 1944:		}
        2: 1945:		if( this->is_data_fixed ) {
        1: 1946:			return true;
        -: 1947:		}
        1: 1948:		this->is_data_fixed = true;
        1: 1949:		this->data.push_back( op1 );
        1: 1950:		this->data.push_back( address );
        1: 1951:		return true;
        -: 1952:	}
    #####: 1953:	return false;
        -: 1954:}
        -: 1955:
        -: 1956:// --------------------------------------------------------------------
       39: 1957:bool CZMA_PARSE::opecode_ccc( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c ) {
        -: 1958:	int ccc;
        -: 1959:
       39: 1960:	if( words.size() == 2 && info.is_ccc( words[1] ) ) {
       24: 1961:		ccc = info.ccc_id[words[1]];
       24: 1962:		this->set_code_size( &info, 1 );
       24: 1963:		if( this->is_data_fixed ) {
       16: 1964:			return true;
        -: 1965:		}
        8: 1966:		this->is_data_fixed = true;
        8: 1967:		this->data.push_back( op1c | (ccc << 3) );
        8: 1968:		return true;
        -: 1969:	}
       15: 1970:	else if( words.size() == 1 ) {
       12: 1971:		this->set_code_size( &info, 1 );
       12: 1972:		if( this->is_data_fixed ) {
        8: 1973:			return true;
        -: 1974:		}
        4: 1975:		this->is_data_fixed = true;
        4: 1976:		this->data.push_back( op1 );
        4: 1977:		return true;
        -: 1978:	}
        3: 1979:	return false;
        -: 1980:}
        -: 1981:
        -: 1982:// --------------------------------------------------------------------
       15: 1983:bool CZMA_PARSE::opecode_mulub( CZMA_INFORMATION& info, unsigned char op1, int op2 ) {
        -: 1984:	int ddd;
        -: 1985:
       15: 1986:	if( words.size() != 4 ) {
        3: 1987:		return false;
        -: 1988:	}
       12: 1989:	if( words[1] != "A" || words[2] != "," ) {
    #####: 1990:		return false;
        -: 1991:	}
       12: 1992:	if( words[3] != "B" && words[3] != "C" && words[3] != "D" && words[3] != "E" ) {
    #####: 1993:		return false;
        -: 1994:	}
       12: 1995:	if( this->is_data_fixed ) {
        8: 1996:		return true;
        -: 1997:	}
        4: 1998:	this->is_data_fixed = true;
        4: 1999:	this->set_code_size( &info, 2 );
        4: 2000:	ddd = info.sss_or_ddd_id[words[3]];
        4: 2001:	this->data.push_back( op1 );
        4: 2002:	this->data.push_back( op2 | (ddd << 3) );
        4: 2003:	return true;
        -: 2004:}
        -: 2005:
        -: 2006:// --------------------------------------------------------------------
        9: 2007:bool CZMA_PARSE::opecode_muluw( CZMA_INFORMATION& info ) {
        -: 2008:
        9: 2009:	if( words.size() != 4 ) {
        3: 2010:		return false;
        -: 2011:	}
        6: 2012:	if( words[1] != "HL" || words[2] != "," ) {
    #####: 2013:		return false;
        -: 2014:	}
        6: 2015:	if( words[3] == "BC" ) {
        3: 2016:		if( this->is_data_fixed ) {
        2: 2017:			return true;
        -: 2018:		}
        1: 2019:		this->is_data_fixed = true;
        1: 2020:		this->set_code_size( &info, 2 );
        1: 2021:		this->data.push_back( 0xED );
        1: 2022:		this->data.push_back( 0xC3 );
        1: 2023:		return true;
        -: 2024:	}
        3: 2025:	if( words[3] == "SP" ) {
        3: 2026:		if( this->is_data_fixed ) {
        2: 2027:			return true;
        -: 2028:		}
        1: 2029:		this->is_data_fixed = true;
        1: 2030:		this->set_code_size( &info, 2 );
        1: 2031:		this->data.push_back( 0xED );
        1: 2032:		this->data.push_back( 0xC5 );
        1: 2033:		return true;
        -: 2034:	}
    #####: 2035:	return false;
        -: 2036:}
        -: 2037:
        -: 2038:// --------------------------------------------------------------------
      180: 2039:bool CZMA_PARSE::opecode_ddd( CZMA_INFORMATION& info, unsigned char op1, int op2 ) {
        -: 2040:	int ddd;
      360: 2041:	CVALUE nn;
        -: 2042:
      180: 2043:	if( words.size() == 2 && info.is_sss_or_ddd( words[1] ) ) {
       42: 2044:		ddd = info.sss_or_ddd_id[words[1]];
       42: 2045:		if( this->is_data_fixed ) {
       28: 2046:			return true;
        -: 2047:		}
       14: 2048:		this->is_data_fixed = true;
       14: 2049:		if( op2 != -1 ) {
    #####: 2050:			this->set_code_size( &info, 2 );
    #####: 2051:			this->data.push_back( op1 );
    #####: 2052:			this->data.push_back( op2 | (ddd << 3) );
        -: 2053:		}
        -: 2054:		else {
       14: 2055:			this->set_code_size( &info, 1 );
       14: 2056:			this->data.push_back( op1 | (ddd << 3) );
        -: 2057:		}
       14: 2058:		return true;
        -: 2059:	}
      138: 2060:	if( words.size() == 2 && info.is_ix_hl( words[1] ) ) {
       12: 2061:		ddd = info.ix_hl[words[1]];
       12: 2062:		if( this->is_data_fixed ) {
        8: 2063:			return true;
        -: 2064:		}
        4: 2065:		this->is_data_fixed = true;
        4: 2066:		if( op2 != -1 ) {
    #####: 2067:			this->set_code_size( &info, 3 );
    #####: 2068:			this->data.push_back( 0xDD );
    #####: 2069:			this->data.push_back( op1 );
    #####: 2070:			this->data.push_back( op2 | (ddd << 3) );
        -: 2071:		}
        -: 2072:		else {
        4: 2073:			this->set_code_size( &info, 2 );
        4: 2074:			this->data.push_back( 0xDD );
        4: 2075:			this->data.push_back( op1 | (ddd << 3) );
        -: 2076:		}
        4: 2077:		return true;
        -: 2078:	}
      126: 2079:	if( words.size() == 2 && info.is_iy_hl( words[1] ) ) {
       12: 2080:		ddd = info.iy_hl[words[1]];
       12: 2081:		if( this->is_data_fixed ) {
        8: 2082:			return true;
        -: 2083:		}
        4: 2084:		this->is_data_fixed = true;
        4: 2085:		if( op2 != -1 ) {
    #####: 2086:			this->set_code_size( &info, 3 );
    #####: 2087:			this->data.push_back( 0xFD );
    #####: 2088:			this->data.push_back( op1 );
    #####: 2089:			this->data.push_back( op2 | (ddd << 3) );
        -: 2090:		}
        -: 2091:		else {
        4: 2092:			this->set_code_size( &info, 2 );
        4: 2093:			this->data.push_back( 0xFD );
        4: 2094:			this->data.push_back( op1 | (ddd << 3) );
        -: 2095:		}
        4: 2096:		return true;
        -: 2097:	}
      114: 2098:	return false;
        -: 2099:}
        -: 2100:
        -: 2101:// --------------------------------------------------------------------
     8072: 2102:bool CZMA_PARSE::write( CZMA_INFORMATION &info, std::ofstream *f ) {
        -: 2103:	unsigned char c;
        -: 2104:
    66028: 2105:	for( auto d: data ) {
    57956: 2106:		c = d;
    57956: 2107:		f->write( (const char*) &c, 1 );
        -: 2108:	}
    23526: 2109:	for( auto line : log ) {
    15454: 2110:		info.log << line << std::endl;
        -: 2111:	}
     8072: 2112:	return true;
      168: 2113:}
