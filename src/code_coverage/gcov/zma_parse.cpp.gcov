        -:    0:Source:../zma_parse.cpp
        -:    0:Programs:106
        -:    1:// --------------------------------------------------------------------
        -:    2://	Z80 Macro Assembler parse
        -:    3:// ====================================================================
        -:    4://	2019/05/04	t.hara
        -:    5:// --------------------------------------------------------------------
        -:    6:
        -:    7:#include "zma_parse.hpp"
        -:    8:#include "zma_text.hpp"
        -:    9:#include <string>
        -:   10:#include <cctype>
        -:   11:#include <iostream>
        -:   12:#include <fstream>
        -:   13:#include <sstream>
        -:   14:#include <algorithm>
        -:   15:
        -:   16:// --------------------------------------------------------------------
   448552:   17:std::string CZMA_PARSE::get_word( int index ) {
   897104:   18:	if( index >= (int)words.size() ) {
    63378:   19:		return "";
        -:   20:	}
   385174:   21:	return words[index];
        -:   22:}
        -:   23:
        -:   24:// --------------------------------------------------------------------
    44861:   25:std::string CZMA_PARSE::delete_head_space( std::string s ) {
        -:   26:	int i;
        -:   27:
   159676:   28:	for( i = 0; isspace( s[i] ); i++ );
    44861:   29:	return s.substr( i );
        -:   30:}
        -:   31:
        -:   32:// --------------------------------------------------------------------
        -:   33:static bool is_shift_jis_1st( char c ) {
     1428:   34:	unsigned char cc = (unsigned char) c;
     1428:   35:	if( ((cc >= 0x81) && (cc <= 0x9f)) || ((cc >= 0xe0) && (cc <= 0xfc)) ) {
        -:   36:		return true;
        -:   37:	}
        -:   38:	return false;
        -:   39:}
        -:   40:
        -:   41:// --------------------------------------------------------------------
    14662:   42:std::vector<std::string> CZMA_PARSE::get_word_split( std::string s ) {
        -:   43:	int i;
        -:   44:	std::string word;
        -:   45:	std::vector< std::string > words;
        -:   46:	static std::vector< std::string > operator_list = { 
        -:   47:		"<<", ">>", "!=", "==", "<=", ">=", "::", "&&", "||", ":="
    14744:   48:	};
        -:   49:
        -:   50:	for(;;) {
   134583:   51:		s = delete_head_space( s );
    44861:   52:		if( s[0] == ';' || s[0] == '\0' ) {
        -:   53:			break;
        -:   54:		}
    30199:   55:		else if( s[0] == '\'' ) {
       17:   56:			if( (int)s.size() < 2 ) {
        -:   57:				break;
        -:   58:			}
       34:   59:			if( s[1] == '\\' ) {
    #####:   60:				if( ( int) s.size() < 4 ) {
        -:   61:					break;
        -:   62:				}
    #####:   63:				switch( s[2] ) {
        -:   64:				case 'a':	word = "'\a";		break;
        -:   65:				case 'b':	word = "'\b";		break;
        -:   66:				case 'f':	word = "'\f";		break;
        -:   67:				case 'n':	word = "'\n";		break;
        -:   68:				case 'r':	word = "'\r";		break;
        -:   69:				case 't':	word = "'\t";		break;
        -:   70:				case '\\':	word = "'\\";		break;
        -:   71:				case '\'':	word = "'\'";		break;
        -:   72:				case '\"':	word = "'\"";		break;
    #####:   73:				default:	word = std::string("'") + s[2];	break;
        -:   74:				}
    #####:   75:				words.push_back( word );
    #####:   76:				if( s[3] != '\'' ) {
    #####:   77:					s = s.substr( 3 );
    #####:   78:					continue;
        -:   79:				}
    #####:   80:				s = s.substr( 4 );
    #####:   81:				continue;
        -:   82:			}
        -:   83:			else {
       51:   84:				word = std::string( "\'" ) + s[1];
       17:   85:				words.push_back( word );
       17:   86:				if( s[2] != '\'' ) {
    #####:   87:					s = s.substr( 2 );
    #####:   88:					continue;
        -:   89:				}
       34:   90:				s = s.substr( 3 );
       17:   91:				continue;
        -:   92:			}
        -:   93:		}
    30392:   94:		else if( s[0] == '\"' ) {
        -:   95:			word = "\"";
     3086:   96:			for( i = 1; i < (int)s.size(); i++ ) {
     3306:   97:				if( s[i] == '\\' ) {
       10:   98:					i++;
       10:   99:					if( i >= (int)s.size() ) {
        -:  100:						break;
        -:  101:					}
       20:  102:					switch( s[i] ) {
        2:  103:					case 'a':	word = word + "\a";	break;
        2:  104:					case 'b':	word = word + "\b";	break;
        2:  105:					case 'f':	word = word + "\f";	break;
        2:  106:					case 'n':	word = word + "\n";	break;
        2:  107:					case 'r':	word = word + "\r";	break;
        2:  108:					case 't':	word = word + "\t";	break;
        2:  109:					case '\\':	word = word + "\\";	break;
        2:  110:					case '\'':	word = word + "\'";	break;
        2:  111:					case '\"':	word = word + "\"";	break;
        2:  112:					default:	word = word + s[i];	break;
        -:  113:					}
       10:  114:					continue;
        -:  115:				}
     1638:  116:				else if( s[i] == '\"' ) {
      210:  117:					i++;
      210:  118:					break;
        -:  119:				}
     1428:  120:				else if( is_shift_jis_1st( s[i] ) ) {
       88:  121:					word = word + s[i];
       44:  122:					i++;
       44:  123:					if( i >= (int)s.size() ) {
        -:  124:						break;
        -:  125:					}
        -:  126:				}
     4284:  127:				word = word + s[i];
        -:  128:			}
      210:  129:			words.push_back( word );
      420:  130:			s = s.substr( i );
      210:  131:			continue;
        -:  132:		}
    29972:  133:		else if( isalpha( s[0] ) || isdigit( s[0] ) || s[0] == '_' ) {
        -:  134:			//	symbols or numbers
   164750:  135:			for( i = 0; isalpha( s[i] ) || isdigit( s[i] ) || s[i] == '_' || s[i] == '\''; i++ );
        -:  136:		}
     9336:  137:		else if( s[ 0 ] == '$' && s[ 1 ] == '$' ){
        -:  138:			i = 2;
        -:  139:		}
     9317:  140:		else if( s[ 0 ] == '$' ){
        -:  141:			//	numbers
       58:  142:			for( i = 1; isxdigit( s[ i ] ) || s[ i ] == '_'; i++ );
        -:  143:		}
        -:  144:		else {
        -:  145:			//	operators
        -:  146:			i = 1;
   101795:  147:			for( std::string &op : operator_list ) {
   185194:  148:				if( op == s.substr( 0, op.length() ) ) {
      102:  149:					i = (int)op.length();
      102:  150:					break;
        -:  151:				}
        -:  152:			}
        -:  153:		}
    59944:  154:		word = s.substr( 0, i );
        -:  155:		std::transform( word.begin(), word.end(), word.begin(), ::toupper );
    29972:  156:		words.push_back( word );
    59944:  157:		s = s.substr( i );
        -:  158:	}
    14662:  159:	return words;
        -:  160:}
        -:  161:
        -:  162:// --------------------------------------------------------------------
    31242:  163:CZMA_PARSE::CZMA_PARSE( std::vector<std::string> words, const char* p_file_name, int line_no ) {
    15621:  164:	this->code_address = -1;
    15621:  165:	this->next_code_address = -1;
    15621:  166:	this->file_address = -1;
    15621:  167:	this->code_size = -1;
    15621:  168:	this->is_data_fixed = false;
    15621:  169:	this->words = words;
    15621:  170:	this->p_file_name = p_file_name;
    15621:  171:	this->line_no = line_no;
    15621:  172:	this->is_analyze_phase = true;
    15621:  173:	this->is_label_search_state = true;
    15621:  174:	this->is_structure_error = false;
    15621:  175:	this->number_of_error_for_this = 0;
    15621:  176:}
        -:  177:
        -:  178:// --------------------------------------------------------------------
    45669:  179:bool CZMA_PARSE::update_flags( CZMA_INFORMATION* p_info, const CZMA_PARSE* p_last_line ) {
        -:  180:	bool result = true;
    45669:  181:	if( p_last_line == nullptr ) {
        -:  182:		this->set_code_address( p_info, 0 );
        -:  183:		this->set_file_address( p_info, 0 );
        -:  184:	}
        -:  185:	else {
    45412:  186:		if( p_last_line->is_fixed_next_code_address() ) {
        -:  187:			this->set_code_address( p_info, p_last_line->get_next_code_address() );
        -:  188:		}
        -:  189:		else {
        -:  190:			result = false;
        -:  191:		}
        -:  192:
    45412:  193:		if( p_last_line->is_fixed_file_address() && p_last_line->is_fixed_code_size() ) {
    25557:  194:			this->set_file_address( p_info, p_last_line->get_file_address() + p_last_line->get_code_size() );
        -:  195:		}
        -:  196:		else {
        -:  197:			result = false;
        -:  198:		}
        -:  199:	}
    45669:  200:	if( !this->is_data_fixed ) {
        -:  201:		result = false;
        -:  202:	}
    45669:  203:	if( this->is_fixed_code_address() && this->is_fixed_code_size() ) {
    17641:  204:		if( this->next_code_address == -1 ) {
      284:  205:			p_info->is_updated = true;
        -:  206:		}
    17641:  207:		this->next_code_address = this->get_code_address() + this->get_code_size();
        -:  208:	}
        -:  209:	else {
        -:  210:		result = false;
        -:  211:	}
    45669:  212:	return result;
        -:  213:}
        -:  214:
        -:  215:// --------------------------------------------------------------------
      922:  216:bool CZMA_PARSE::check_location_hl( int index ) {
     4048:  217:	if( (int)words.size() >= (index + 3) && words[index] == "[" && words[(int)(index+1)] == "HL" && words[(int)(index+2)] == "]" ) {
        -:  218:		return true;
        -:  219:	}
        -:  220:	return false;
        -:  221:}
        -:  222:
        -:  223:// --------------------------------------------------------------------
     1393:  224:int CZMA_PARSE::check_location_ix( int index ) {
     2786:  225:	if( (int)words.size() < (index + 3) ) {
        -:  226:		return 0;
        -:  227:	}
     4780:  228:	if( words[index] == "[" && words[(int)(index + 1)] == "IX" && words[(int)(index + 2)] == "]" ) {
       21:  229:		return index + 3;
        -:  230:	}
     3357:  231:	if( words[index] != "[" || words[(int)(index + 1)] != "IX" || (words[(int)(index + 2)] != "+" && words[(int)(index + 2)] != "-") ) {
        -:  232:		return 0;
        -:  233:	}
     4700:  234:	for( index += 2; (size_t)index < words.size() && words[index] != "]"; index++ );
      595:  235:	if( (size_t)index >= words.size() ) {
        -:  236:		return 0;
        -:  237:	}
      571:  238:	return index + 1;
        -:  239:}
        -:  240:
        -:  241:// --------------------------------------------------------------------
      801:  242:int CZMA_PARSE::check_location_iy( int index ) {
     1602:  243:	if( (int)words.size() < (index + 3) ) {
        -:  244:		return 0;
        -:  245:	}
     2952:  246:	if( words[index] == "[" && words[(int)(index + 1)] == "IY" && words[(int)(index + 2)] == "]" ) {
       15:  247:		return index + 3;
        -:  248:	}
     2139:  249:	if( words[index] != "[" || words[(int)(index + 1)] != "IY" || (words[(int)(index + 2)] != "+" && words[(int)(index + 2)] != "-") ) {
        -:  250:		return false;
        -:  251:	}
     4332:  252:	for( index += 2; (size_t)index < words.size() && words[index] != "]"; index++ );
      549:  253:	if( (size_t)index >= words.size() ) {
        -:  254:		return 0;
        -:  255:	}
      525:  256:	return index + 1;
        -:  257:}
        -:  258:
        -:  259:// --------------------------------------------------------------------
       89:  260:int CZMA_PARSE::relative_address( CZMA_INFORMATION &info, int index ) {
        -:  261:	int relative;
        -:  262:	CVALUE imm;
       89:  263:	if( this->code_address == -1 ){
      195:  264:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ADDRESS_DETERMINED ), info.all_error_enable, info.error_disable );
       39:  265:		info.error_disable = true;
       39:  266:		return -9999;
        -:  267:	}
       50:  268:	index = this->expression( info, index, imm );
       50:  269:	if( index == 0 ) {
       50:  270:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_EXPRESSION ), info.all_error_enable, info.error_disable );
       10:  271:		info.error_disable = true;
       10:  272:		return -9999;
        -:  273:	}
       40:  274:	if( imm.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  275:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ), info.all_error_enable, info.error_disable );
    #####:  276:		info.error_disable = true;
    #####:  277:		return -9999;
        -:  278:	}
       80:  279:	if( index < ( int) words.size() ) {
    #####:  280:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ), info.all_error_enable, info.error_disable );
    #####:  281:		info.error_disable = true;
    #####:  282:		return -9999;
        -:  283:	}
       40:  284:	relative = imm.i - (this->code_address + this->get_code_size() );
       40:  285:	if( relative < -128 || relative > 127 ) {
       30:  286:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ), info.all_error_enable, info.error_disable );
        6:  287:		info.error_disable = true;
        6:  288:		return -9999;
        -:  289:	}
        -:  290:	return relative;
        -:  291:}
        -:  292:
        -:  293:// --------------------------------------------------------------------
     1604:  294:void CZMA_PARSE::put_error( std::string message, bool is_all_error, bool error_disable ) {
        -:  295:
     1604:  296:	if( this->is_analyze_phase ) {
        -:  297:		return;
        -:  298:	}
      478:  299:	if( number_of_error_for_this == 0 ){
      710:  300:		log.write_line_infomation( this->line_no, this->code_address, this->file_address, this->get_line() );
        -:  301:	}
      478:  302:	if( message != last_error ){
      408:  303:		log.write_error_message( p_file_name, this->line_no, message, is_all_error, error_disable );
      408:  304:		number_of_error++;
      408:  305:		number_of_error_for_this++;
        -:  306:		last_error = message;
        -:  307:	}
        -:  308:}
        -:  309:
        -:  310:// --------------------------------------------------------------------
       66:  311:std::string CZMA_PARSE::escape( const std::string &s ){
        -:  312:	std::string ss;
        -:  313:
      972:  314:	for( auto c : s ){
      906:  315:		switch( c ) {
        2:  316:		case '\a': ss = ss + "\\a";	break;
        2:  317:		case '\b': ss = ss + "\\b";	break;
        2:  318:		case '\f': ss = ss + "\\f";	break;
        2:  319:		case '\n': ss = ss + "\\n";	break;
        2:  320:		case '\r': ss = ss + "\\r";	break;
        2:  321:		case '\t': ss = ss + "\\t";	break;
     1800:  322:		default:   ss = ss + c;     break;
        -:  323:		}
        -:  324:	}
       66:  325:	return ss;
        -:  326:}
        -:  327:
        -:  328:// --------------------------------------------------------------------
       66:  329:void CZMA_PARSE::put_message( std::string message ) {
      132:  330:	std::stringstream ss;
        -:  331:	std::string s;
        -:  332:
       66:  333:	if(this->is_analyze_phase) {
        -:  334:		return;
        -:  335:	}
      264:  336:	ss << "MESSAGE: " << this->escape( message ) << ": " << p_file_name << "(" << line_no << ")";
      132:  337:	s = ss.str();
       66:  338:	std::cout << s << "\n";
       66:  339:	log.write_message( s );
        -:  340:}
        -:  341:
        -:  342:// --------------------------------------------------------------------
    #####:  343:void CZMA_PARSE::put_structure_error( std::string message, bool is_all_error, bool error_disable ) {
    #####:  344:	std::stringstream ss;
        -:  345:	std::string s;
        -:  346:
    #####:  347:	if( this->is_structure_error ) {
        -:  348:		return;
        -:  349:	}
    #####:  350:	this->is_structure_error = true;
    #####:  351:	ss << message << ": " << p_file_name << "(" << line_no << ")";
    #####:  352:	s = ss.str();
    #####:  353:	std::cerr << s << "\n";
    #####:  354:	this->structure_error = s;
    #####:  355:	log.write_error_message( this->p_file_name, this->line_no, s, is_all_error, error_disable );
    #####:  356:	number_of_error++;
        -:  357:}
        -:  358:
        -:  359:// --------------------------------------------------------------------
     9813:  360:bool CZMA_PARSE::opecode( CZMA_INFORMATION& info, unsigned char op1, int op2 ) {
        -:  361:
    19626:  362:	if( words.size() != 1 ) {
        -:  363:		return false;
        -:  364:	}
     9702:  365:	if( this->is_data_fixed ) {
        -:  366:		return true;
        -:  367:	}
     3234:  368:	this->is_data_fixed = true;
     3234:  369:	if( op2 == -1 ) {
        -:  370:		this->set_code_size( &info, 1 );
     3186:  371:		this->data.push_back( op1 );
        -:  372:	}
        -:  373:	else {
        -:  374:		this->set_code_size( &info, 2 );
       48:  375:		this->data.push_back( op1 );
       96:  376:		this->data.push_back( op2 );
        -:  377:	}
        -:  378:	return true;
        -:  379:}
        -:  380:
        -:  381:// --------------------------------------------------------------------
     1890:  382:bool CZMA_PARSE::opecode_a_i_r( CZMA_INFORMATION& info ) {
        -:  383:
     4952:  384:	if( words.size() != 4 || words[2] != "," ) {
        -:  385:		return false;
        -:  386:	}
     1391:  387:	if( words[1] == "A" && words[3] == "I" ) {
        6:  388:		if( this->is_data_fixed ) {
        -:  389:			return true;
        -:  390:		}
        2:  391:		this->is_data_fixed = true;
        -:  392:		this->set_code_size( &info, 2 );
        4:  393:		this->data.push_back( 0xED );
        4:  394:		this->data.push_back( 0x57 );
        2:  395:		return true;
        -:  396:	}
     1172:  397:	if( words[1] == "I" && words[3] == "A" ) {
        6:  398:		if( this->is_data_fixed ) {
        -:  399:			return true;
        -:  400:		}
        2:  401:		this->is_data_fixed = true;
        -:  402:		this->set_code_size( &info, 2 );
        4:  403:		this->data.push_back( 0xED );
        4:  404:		this->data.push_back( 0x47 );
        2:  405:		return true;
        -:  406:	}
     1373:  407:	if( words[1] == "A" && words[3] == "R" ) {
        6:  408:		if( this->is_data_fixed ) {
        -:  409:			return true;
        -:  410:		}
        2:  411:		this->is_data_fixed = true;
        -:  412:		this->set_code_size( &info, 2 );
        4:  413:		this->data.push_back( 0xED );
        4:  414:		this->data.push_back( 0x5F );
        2:  415:		return true;
        -:  416:	}
     1160:  417:	if( words[1] == "R" && words[3] == "A" ) {
        6:  418:		if( this->is_data_fixed ) {
        -:  419:			return true;
        -:  420:		}
        2:  421:		this->is_data_fixed = true;
        -:  422:		this->set_code_size( &info, 2 );
        4:  423:		this->data.push_back( 0xED );
        4:  424:		this->data.push_back( 0x4F );
        2:  425:		return true;
        -:  426:	}
        -:  427:	return false;
        -:  428:}
        -:  429:
        -:  430:
        -:  431:// --------------------------------------------------------------------
     1866:  432:bool CZMA_PARSE::opecode_destination8_source8( CZMA_INFORMATION& info, unsigned char op1 ) {
        -:  433:	int ddd, sss;
        -:  434:	int ixhl = 0;
        -:  435:
    12204:  436:	if( words.size() != 4 || (!info.is_sss_or_ddd( words[1] ) && !info.is_ix_hl( words[1] ) && !info.is_iy_hl( words[1] )) || 
    10048:  437:		words[2] != ","   || (!info.is_sss_or_ddd( words[3] ) && !info.is_ix_hl( words[3] ) && !info.is_iy_hl( words[3] )) ) {
        -:  438:		return false;
        -:  439:	}
     1424:  440:	if( info.is_sss_or_ddd( words[1] ) ) {
      992:  441:		ddd = info.sss_or_ddd_id[words[1]];
        -:  442:	}
      432:  443:	else if( info.is_ix_hl( words[1] ) ) {
      216:  444:		ddd = info.ix_hl[words[1]];
        -:  445:		ixhl = 1;
        -:  446:	}
        -:  447:	else {
      216:  448:		ddd = info.iy_hl[words[1]];
        -:  449:		ixhl = 2;
        -:  450:	}
     1424:  451:	if( info.is_sss_or_ddd( words[3] ) ) {
     1040:  452:		sss = info.sss_or_ddd_id[words[3]];
        -:  453:	}
      384:  454:	else if( info.is_ix_hl( words[3] ) ) {
      192:  455:		sss = info.ix_hl[words[3]];
      234:  456:		if( ixhl || words[1] == "H" || words[1] == "L" ) {
      180:  457:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
       36:  458:			return false;
        -:  459:		}
        -:  460:		ixhl = 1;
        -:  461:	}
        -:  462:	else {
      192:  463:		sss = info.iy_hl[words[3]];
      234:  464:		if( ixhl || words[1] == "H" || words[1] == "L" ) {
      180:  465:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
       36:  466:			return false;
        -:  467:		}
        -:  468:		ixhl = 2;
        -:  469:	}
      640:  470:	if( this->is_data_fixed ) {
        -:  471:		return true;
        -:  472:	}
      213:  473:	this->is_data_fixed = true;
      213:  474:	if( ixhl == 1 ) {
        -:  475:		this->set_code_size( &info, 2 );
       96:  476:		this->data.push_back( 0xDD );
        -:  477:	}
      165:  478:	else if( ixhl == 2 ) {
        -:  479:		this->set_code_size( &info, 2 );
       96:  480:		this->data.push_back( 0xFD );
        -:  481:	}
        -:  482:	else {
        -:  483:		this->set_code_size( &info, 1 );
        -:  484:	}
      426:  485:	this->data.push_back( op1 | (ddd << 3) | sss );
      213:  486:	return true;
        -:  487:}
        -:  488:
        -:  489:// --------------------------------------------------------------------
     1425:  490:bool CZMA_PARSE::opecode_a_source8( CZMA_INFORMATION& info, unsigned char op1 ) {
        -:  491:	int sss;
        -:  492:	CVALUE d;
        -:  493:
     6774:  494:	if( words.size() == 4 && words[1] == "A" && words[2] == "," && info.is_sss_or_ddd( words[3] ) ) {
      465:  495:		if( this->is_data_fixed ) {
        -:  496:			return true;
        -:  497:		}
      155:  498:		this->is_data_fixed = true;
      310:  499:		sss = info.sss_or_ddd_id[words[3]];
        -:  500:		this->set_code_size( &info, 1 );
      310:  501:		this->data.push_back( (unsigned char)(op1 | sss) );
      155:  502:		return true;
        -:  503:	}
     3984:  504:	if( words.size() == 4 && words[1] == "A" && words[2] == "," && info.is_ix_hl( words[3] ) ) {
      126:  505:		if( this->is_data_fixed ) {
        -:  506:			return true;
        -:  507:		}
       42:  508:		this->is_data_fixed = true;
       84:  509:		sss = info.ix_hl[words[3]];
        -:  510:		this->set_code_size( &info, 2 );
       84:  511:		this->data.push_back( 0xDD );
       84:  512:		this->data.push_back( (unsigned char)(op1 | sss) );
       42:  513:		return true;
        -:  514:	}
     3228:  515:	if( words.size() == 4 && words[1] == "A" && words[2] == "," && info.is_iy_hl( words[3] ) ) {
      126:  516:		if( this->is_data_fixed ) {
        -:  517:			return true;
        -:  518:		}
       42:  519:		this->is_data_fixed = true;
       84:  520:		sss = info.iy_hl[words[3]];
        -:  521:		this->set_code_size( &info, 2 );
       84:  522:		this->data.push_back( 0xFD );
       84:  523:		this->data.push_back( (unsigned char)(op1 | sss) );
       42:  524:		return true;
        -:  525:	}
        -:  526:	return false;
        -:  527:}
        -:  528:
        -:  529:// --------------------------------------------------------------------
       54:  530:bool CZMA_PARSE::opecode_destination8_c( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c, unsigned char op2 ) {
        -:  531:	int ddd;
        -:  532:	CVALUE nn;
        -:  533:
      407:  534:	if( words.size() == 6 && info.is_sss_or_ddd( words[1] ) && words[2] == "," && words[3] == "[" && words[4] == "C" && words[5] == "]" ) {
       44:  535:		if( this->is_data_fixed ) {
        -:  536:			return true;
        -:  537:		}
       14:  538:		this->is_data_fixed = true;
       28:  539:		ddd = info.sss_or_ddd_id[words[1]];
        -:  540:		this->set_code_size( &info, 2 );
       14:  541:		this->data.push_back( op1c );
       28:  542:		this->data.push_back( (unsigned char)(op2 | (ddd << 3)) );
       14:  543:		return true;
        -:  544:	}
       31:  545:	if( words.size() == 6 && words[ 1 ] == "F" && words[ 2 ] == "," && words[ 3 ] == "[" && words[ 4 ] == "C" && words[ 5 ] == "]" ){
        1:  546:		if( this->is_data_fixed ){
        -:  547:			return true;
        -:  548:		}
        1:  549:		this->is_data_fixed = true;
        1:  550:		ddd = info.sss_or_ddd_id[ words[ 1 ] ];
        -:  551:		this->set_code_size( &info, 2 );
        1:  552:		this->data.push_back( op1c );
        2:  553:		this->data.push_back( op2 | ( 6 << 3 ) );
        1:  554:		return true;
        -:  555:	}
       36:  556:	if( words.size() >= 6 && words[1] == "A" && words[2] == "," && words[3] == "[" ) {
        -:  557:		this->set_code_size( &info, 2 );
        9:  558:		if( !this->expression( info, 4, nn ) ) {
        -:  559:			return false;
        -:  560:		}
        6:  561:		if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  562:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  563:			return false;
        -:  564:		}
        6:  565:		if( this->is_data_fixed ) {
        -:  566:			return true;
        -:  567:		}
        2:  568:		this->is_data_fixed = true;
        2:  569:		this->data.push_back( op1 );
        4:  570:		this->data.push_back( nn.i );
        2:  571:		return true;
        -:  572:	}
        -:  573:	return false;
        -:  574:}
        -:  575:
        -:  576:// --------------------------------------------------------------------
       72:  577:bool CZMA_PARSE::opecode_c_source8( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c, unsigned char op2 ) {
        -:  578:	int sss, n;
        -:  579:	CVALUE nn;
        -:  580:
      543:  581:	if( words.size() == 6 && words[1] == "[" && words[2] == "C" && words[3] == "]" && words[4] == "," && info.is_sss_or_ddd( words[5] ) ) {
       60:  582:		if( this->is_data_fixed ) {
        -:  583:			return true;
        -:  584:		}
       20:  585:		this->is_data_fixed = true;
       40:  586:		sss = info.sss_or_ddd_id[words[5]];
        -:  587:		this->set_code_size( &info, 2 );
       20:  588:		this->data.push_back( op1c );
       40:  589:		this->data.push_back( (unsigned char)(op2 | (sss << 3)) );
       20:  590:		return true;
        -:  591:	}
       51:  592:	if( words.size() == 6 && words[ 1 ] == "[" && words[ 2 ] == "C" && words[ 3 ] == "]" && words[ 4 ] == "," && words[ 5 ] == "0" ){
        3:  593:		if( this->is_data_fixed ){
        -:  594:			return true;
        -:  595:		}
        1:  596:		this->is_data_fixed = true;
        -:  597:		this->set_code_size( &info, 2 );
        1:  598:		this->data.push_back( op1c );
        2:  599:		this->data.push_back( op2 | ( 6 << 3 ) );
        1:  600:		return true;
        -:  601:	}
       45:  602:	for( n = 2; n < (int)words.size() && words[n] != "]"; n++ ) {
        -:  603:	}
        9:  604:	if( n >= (int)words.size() ) {
        -:  605:		return false;
        -:  606:	}
        9:  607:	n++;
       36:  608:	if( words.size() >= 6 && words[1] == "[" && words[n] == "," && words[n+1] == "A" ) {
        -:  609:		this->set_code_size( &info, 2 );
        9:  610:		if( !this->expression( info, 2, nn ) ) {
        -:  611:			return false;
        -:  612:		}
        6:  613:		if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  614:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  615:			return false;
        -:  616:		}
        6:  617:		if( this->is_data_fixed ) {
        -:  618:			return true;
        -:  619:		}
        2:  620:		this->is_data_fixed = true;
        2:  621:		this->data.push_back( op1 );
        4:  622:		this->data.push_back( nn.i );
        2:  623:		return true;
        -:  624:	}
        -:  625:	return false;
        -:  626:}
        -:  627:
        -:  628:// --------------------------------------------------------------------
     1458:  629:bool CZMA_PARSE::opecode_bit_source8( CZMA_INFORMATION& info, unsigned char op1, bool no_3operand ) {
        -:  630:	int sss, ddd, n;
        -:  631:	CVALUE b, d;
        -:  632:
     8748:  633:	for( n = 1; n < (int) words.size() && words[n] != ","; n++ ) {
        -:  634:	}
     1458:  635:	if( n >= (int) words.size() ) {
        -:  636:		return false;
        -:  637:	}
     1458:  638:	if( !this->expression( info, 1, b ) ) {
        -:  639:		return false;
        -:  640:	}
     1458:  641:	if( b.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  642:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  643:		return false;
        -:  644:	}
     1458:  645:	if( b.i < 0 || b.i > 7 ) {
    #####:  646:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_BIT_NUMBER ) );
    #####:  647:		b.i &= 7;
        -:  648:	}
     1458:  649:	n++;
     5382:  650:	if( (int) words.size() == (n + 1) && info.is_sss_or_ddd( words[n] ) ) {
     1008:  651:		if( this->is_data_fixed ) {
        -:  652:			return true;
        -:  653:		}
      336:  654:		this->is_data_fixed = true;
      672:  655:		sss = info.sss_or_ddd_id[words[n]];
        -:  656:		this->set_code_size( &info, 2 );
      672:  657:		this->data.push_back( 0xCB );
      672:  658:		this->data.push_back( op1 | (b.i << 3) | sss );
      336:  659:		return true;
        -:  660:	}
      900:  661:	if( (int) words.size() == (n + 3) && this->check_location_hl( n ) ) {
      144:  662:		if( this->is_data_fixed ) {
        -:  663:			return true;
        -:  664:		}
       48:  665:		this->is_data_fixed = true;
        -:  666:		this->set_code_size( &info, 2 );
       96:  667:		this->data.push_back( 0xCB );
       96:  668:		this->data.push_back( op1 | (b.i << 3) | 0x06 );
       48:  669:		return true;
        -:  670:	}
      603:  671:	if( (int) words.size() >= (n + 5) && this->check_location_ix( n ) ) {
        -:  672:		this->set_code_size( &info, 4 );
      306:  673:		if( words[n + 2] == "+" || words[n + 2] == "-" ) {
      153:  674:			n = this->expression( info, n + 2, d );
      153:  675:			if( n == 0 ) {
        -:  676:				return false;
        -:  677:			}
      306:  678:			if( words[ n ] != "]" ){
    #####:  679:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  680:				return false;
        -:  681:			}
      153:  682:			if( d.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  683:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  684:				return false;
        -:  685:			}
      153:  686:			if( d.i < -128 || d.i > 127 ) {
    #####:  687:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####:  688:				return false;
        -:  689:			}
      420:  690:			if( !no_3operand && words.size() > (unsigned)(n + 2) && words[ n + 1 ] == "," && info.is_sss_or_ddd( words[ n + 2 ] ) ){
       12:  691:				ddd = info.sss_or_ddd_id[ words[ n + 2 ] ];
        -:  692:			}
        -:  693:			else{
        -:  694:				ddd = 6;
        -:  695:			}
        -:  696:		}
        -:  697:		else {
    #####:  698:			d.i = 0;
        -:  699:			ddd = 6;
        -:  700:		}
      153:  701:		if( this->is_data_fixed ) {
        -:  702:			return true;
        -:  703:		}
       51:  704:		this->is_data_fixed = true;
      102:  705:		this->data.push_back( 0xDD );
      102:  706:		this->data.push_back( 0xCB );
      102:  707:		this->data.push_back( d.i );
      102:  708:		this->data.push_back( op1 | (b.i << 3) | ddd );
       51:  709:		return true;
        -:  710:	}
      297:  711:	if( (int) words.size() >= (n + 5) && this->check_location_iy( n ) ) {
        -:  712:		this->set_code_size( &info, 4 );
      288:  713:		if( words[n + 2] == "+" || words[n + 2] == "-" ) {
      144:  714:			n = this->expression( info, n + 2, d );
      144:  715:			if( n == 0 ){
        -:  716:				return false;
        -:  717:			}
      144:  718:			if( d.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  719:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  720:				return false;
        -:  721:			}
      144:  722:			if( d.i < -128 || d.i > 127 ) {
    #####:  723:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####:  724:				return false;
        -:  725:			}
      384:  726:			if( !no_3operand && words.size() > (unsigned)( n + 2 ) && words[ n + 1 ] == "," && info.is_sss_or_ddd( words[ n + 2 ] ) ){
    #####:  727:				ddd = info.sss_or_ddd_id[ words[ n + 2 ] ];
        -:  728:			}
        -:  729:			else{
        -:  730:				ddd = 6;
        -:  731:			}
        -:  732:		}
        -:  733:		else{
    #####:  734:			d.i = 0;
        -:  735:			ddd = 6;
        -:  736:		}
      144:  737:		if( this->is_data_fixed ) {
        -:  738:			return true;
        -:  739:		}
       48:  740:		this->is_data_fixed = true;
       96:  741:		this->data.push_back( 0xFD );
       96:  742:		this->data.push_back( 0xCB );
       96:  743:		this->data.push_back( d.i );
       96:  744:		this->data.push_back( op1 | ( b.i << 3 ) | ddd );
       48:  745:		return true;
        -:  746:	}
        -:  747:	return false;
        -:  748:}
        -:  749:
        -:  750:// --------------------------------------------------------------------
       99:  751:bool CZMA_PARSE::opecode_hl_source16( CZMA_INFORMATION& info, unsigned char op1 ) {
        -:  752:	int rp;
        -:  753:
      441:  754:	if( words.size() == 4 && words[1] == "HL" && words[2] == "," && info.is_rp( words[3] ) ) {
       24:  755:		if( this->is_data_fixed ) {
        -:  756:			return true;
        -:  757:		}
        8:  758:		this->is_data_fixed = true;
       16:  759:		rp = info.rp_id[words[3]];
        -:  760:		this->set_code_size( &info, 1 );
       16:  761:		this->data.push_back( (unsigned char)(op1 | (rp << 4)) );
        8:  762:		return true;
        -:  763:	}
      369:  764:	if( words.size() == 4 && words[1] == "IX" && words[2] == "," && info.is_ix_rp( words[3] ) ) {
       36:  765:		if( this->is_data_fixed ) {
        -:  766:			return true;
        -:  767:		}
       12:  768:		this->is_data_fixed = true;
       24:  769:		rp = info.ix_rp_id[words[3]];
        -:  770:		this->set_code_size( &info, 2 );
       24:  771:		this->data.push_back( 0xDD );
       24:  772:		this->data.push_back( (unsigned char)(op1 | (rp << 4)) );
       12:  773:		return true;
        -:  774:	}
      225:  775:	if( words.size() == 4 && words[1] == "IY" && words[2] == "," && info.is_iy_rp( words[3] ) ) {
       36:  776:		if( this->is_data_fixed ) {
        -:  777:			return true;
        -:  778:		}
       12:  779:		this->is_data_fixed = true;
       24:  780:		rp = info.iy_rp_id[words[3]];
        -:  781:		this->set_code_size( &info, 2 );
       24:  782:		this->data.push_back( 0xFD );
       24:  783:		this->data.push_back( (unsigned char)(op1 | (rp << 4)) );
       12:  784:		return true;
        -:  785:	}
        -:  786:	return false;
        -:  787:}
        -:  788:
        -:  789:// --------------------------------------------------------------------
       54:  790:bool CZMA_PARSE::opecode_hl_source16_witnout_ix( CZMA_INFORMATION& info, unsigned char op1, unsigned char op2 ) {
        -:  791:	int rp;
        -:  792:
      306:  793:	if( words.size() == 4 && words[1] == "HL" && words[2] == "," && info.is_rp( words[3] ) ) {
       48:  794:		if( this->is_data_fixed ) {
        -:  795:			return true;
        -:  796:		}
       16:  797:		this->is_data_fixed = true;
       16:  798:		rp = info.rp_id[words[3]];
        -:  799:		this->set_code_size( &info, 2 );
       16:  800:		this->data.push_back( op1 );
       32:  801:		this->data.push_back( (unsigned char)(op2 | (rp << 4)) );
       16:  802:		return true;
        -:  803:	}
        -:  804:	return false;
        -:  805:}
        -:  806:
        -:  807:// --------------------------------------------------------------------
     1226:  808:bool CZMA_PARSE::opecode_destination8_memory_hl( CZMA_INFORMATION& info, unsigned char op1 ) {
        -:  809:	int ddd, index;
        -:  810:	CVALUE d;
        -:  811:
     4525:  812:	if( words.size() < 6 || !info.is_sss_or_ddd( words[1] ) || words[2] != "," || (!check_location_hl( 3 ) && !check_location_ix( 3 ) && !check_location_iy( 3 )) ) {
        -:  813:		return false;
        -:  814:	}
      324:  815:	ddd = info.sss_or_ddd_id[words[1]];
      324:  816:	if( words.size() >= 6 && check_location_ix( 3 ) ) {
        -:  817:		this->set_code_size( &info, 3 );
       69:  818:		if( words[5] == "+" || words[5] == "-" ) {
       57:  819:			index = this->expression( info, 5, d );
       57:  820:			if( index == 0 ) {
        -:  821:				return false;
        -:  822:			}
       57:  823:			if( d.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  824:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  825:				return false;
        -:  826:			}
       57:  827:			if( d.i < -128 || d.i > 127 ) {
       30:  828:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
        6:  829:				return false;
        -:  830:			}
      102:  831:			if( (int)words.size() > (index + 1) ) {
       15:  832:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::TOO_MANY_PARAMETERS ) );
        3:  833:				return false;
        -:  834:			}
        -:  835:		}
        -:  836:		else {
        3:  837:			if( words.size() > 6 ) {
    #####:  838:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::TOO_MANY_PARAMETERS ) );
    #####:  839:				return false;
        -:  840:			}
        3:  841:			d.i = 0;
        -:  842:		}
       51:  843:		if( this->is_data_fixed ) {
        -:  844:			return true;
        -:  845:		}
       17:  846:		this->is_data_fixed = true;
       34:  847:		this->data.push_back( 0xDD );
       34:  848:		this->data.push_back( (unsigned char)(op1 | (ddd << 3)) );
       34:  849:		this->data.push_back( d.i );
       17:  850:		return true;
        -:  851:	}
      204:  852:	else if( words.size() >= 6 && check_location_iy( 3 ) ) {
        -:  853:		this->set_code_size( &info, 3 );
       66:  854:		if( words[5] == "+" || words[5] == "-" ) {
       54:  855:			index = this->expression( info, 5, d );
       54:  856:			if( index == 0 ) {
        -:  857:				return false;
        -:  858:			}
       54:  859:			if( d.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  860:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  861:				return false;
        -:  862:			}
       54:  863:			if( d.i < -128 || d.i > 127 ) {
       30:  864:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
        6:  865:				return false;
        -:  866:			}
       96:  867:			if( (int)words.size() > (index + 1) ) {
    #####:  868:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::TOO_MANY_PARAMETERS ) );
    #####:  869:				return false;
        -:  870:			}
        -:  871:		}
        -:  872:		else {
        3:  873:			if( words.size() > 6 ) {
    #####:  874:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::TOO_MANY_PARAMETERS ) );
    #####:  875:				return false;
        -:  876:			}
        3:  877:			d.i = 0;
        -:  878:		}
       51:  879:		if( this->is_data_fixed ) {
        -:  880:			return true;
        -:  881:		}
       17:  882:		this->is_data_fixed = true;
       34:  883:		this->data.push_back( 0xFD );
       34:  884:		this->data.push_back( (unsigned char)(op1 | (ddd << 3)) );
       34:  885:		this->data.push_back( d.i );
       17:  886:		return true;
        -:  887:	}
       45:  888:	else if( words.size() == 6 ) {
       45:  889:		if( this->is_data_fixed ) {
        -:  890:			return true;
        -:  891:		}
        -:  892:		this->set_code_size( &info, 1 );
       15:  893:		this->is_data_fixed = true;
       30:  894:		this->data.push_back( (unsigned char)(op1 | (ddd << 3)) );
       15:  895:		return true;
        -:  896:	}
        -:  897:	return true;
        -:  898:}
        -:  899:
        -:  900:// --------------------------------------------------------------------
      669:  901:bool CZMA_PARSE::opecode_a_memory_hl( CZMA_INFORMATION& info, unsigned char op1 ) {
        -:  902:	CVALUE d;
        -:  903:
     1764:  904:	if( words.size() < 6 || words[1] != "A" || words[2] != "," || (!check_location_hl( 3 ) && !check_location_ix( 3 ) && !check_location_iy( 3 )) ) {
        -:  905:		return false;
        -:  906:	}
      198:  907:	if( words.size() >= 6 && check_location_ix( 3 ) ) {
        -:  908:		this->set_code_size( &info, 3 );
       72:  909:		if( words[5] == "+" || words[5] == "-" ) {
       66:  910:			if( !this->expression( info, 5, d ) ) {
        -:  911:				return false;
        -:  912:			}
       66:  913:			if( d.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  914:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  915:				return false;
        -:  916:			}
       66:  917:			if( d.i < -128 || d.i > 127 ) {
    #####:  918:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####:  919:				return false;
        -:  920:			}
        -:  921:		}
        -:  922:		else {
        3:  923:			d.i = 0;
        -:  924:		}
       69:  925:		if( this->is_data_fixed ) {
        -:  926:			return true;
        -:  927:		}
       23:  928:		this->is_data_fixed = true;
       46:  929:		this->data.push_back( 0xDD );
       23:  930:		this->data.push_back( op1 );
       46:  931:		this->data.push_back( d.i );
       23:  932:		return true;
        -:  933:	}
      129:  934:	else if( words.size() >= 6 && check_location_iy( 3 ) ) {
        -:  935:		this->set_code_size( &info, 3 );
       63:  936:		if( words[5] == "+" || words[5] == "-" ) {
       63:  937:			if( !this->expression( info, 5, d ) ) {
        -:  938:				return false;
        -:  939:			}
       63:  940:			if( d.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  941:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  942:				return false;
        -:  943:			}
       63:  944:			if( d.i < -128 || d.i > 127 ) {
    #####:  945:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####:  946:				return false;
        -:  947:			}
        -:  948:		}
        -:  949:		else {
    #####:  950:			d.i = 0;
        -:  951:		}
       63:  952:		if( this->is_data_fixed ) {
        -:  953:			return true;
        -:  954:		}
       21:  955:		this->is_data_fixed = true;
       42:  956:		this->data.push_back( 0xFD );
       21:  957:		this->data.push_back( op1 );
       42:  958:		this->data.push_back( d.i );
       21:  959:		return true;
        -:  960:	}
       66:  961:	else if( words.size() == 6 ) {
       63:  962:		if( this->is_data_fixed ) {
        -:  963:			return true;
        -:  964:		}
        -:  965:		this->set_code_size( &info, 1 );
       21:  966:		this->is_data_fixed = true;
       21:  967:		this->data.push_back( op1 );
        -:  968:		return true;
        -:  969:	}
        -:  970:	return false;
        -:  971:}
        -:  972:
        -:  973:// --------------------------------------------------------------------
       96:  974:bool CZMA_PARSE::opecode_memory_hl( CZMA_INFORMATION& info, unsigned char op1 ) {
        -:  975:	CVALUE d;
        -:  976:	int index;
        -:  977:
      192:  978:	if( words.size() < 4 || !(check_location_hl( 1 ) || check_location_ix( 1 ) || check_location_iy( 1 )) ) {
        -:  979:		return false;
        -:  980:	}
       54:  981:	if( check_location_ix( 1 ) ) {
        -:  982:		this->set_code_size( &info, 3 );
       27:  983:		if( words[3] == "+" || words[3] == "-" ) {
       18:  984:			index = this->expression( info, 3, d );
       18:  985:			if( index == 0 ) {
    #####:  986:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  987:				return false;
        -:  988:			}
       18:  989:			if( d.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####:  990:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  991:				return false;
        -:  992:			}
       36:  993:			if( (index + 1) < (int) words.size() ) {
    #####:  994:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####:  995:				return false;
        -:  996:			}
       18:  997:			if( d.i < -128 || d.i > 127 ) {
       30:  998:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
        6:  999:				return false;
        -: 1000:			}
        -: 1001:		}
        -: 1002:		else {
        3: 1003:			d.i = 0;
        -: 1004:		}
       15: 1005:		if( this->is_data_fixed ) {
        -: 1006:			return true;
        -: 1007:		}
        5: 1008:		this->is_data_fixed = true;
       10: 1009:		this->data.push_back( 0xDD );
        5: 1010:		this->data.push_back( op1 );
       10: 1011:		this->data.push_back( d.i );
        -: 1012:	}
       33: 1013:	else if( check_location_iy( 1 ) ) {
        -: 1014:		this->set_code_size( &info, 3 );
       27: 1015:		if( words[3] == "+" || words[3] == "-" ) {
       18: 1016:			index = this->expression( info, 3, d );
       18: 1017:			if( index == 0 ) {
    #####: 1018:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1019:				return false;
        -: 1020:			}
       18: 1021:			if( d.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1022:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1023:				return false;
        -: 1024:			}
       36: 1025:			if( (index + 1) < (int) words.size() ) {
    #####: 1026:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1027:				return false;
        -: 1028:			}
       18: 1029:			if( d.i < -128 || d.i > 127 ) {
       30: 1030:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
        6: 1031:				return false;
        -: 1032:			}
        -: 1033:		}
        -: 1034:		else {
        3: 1035:			d.i = 0;
        -: 1036:		}
       15: 1037:		if( this->is_data_fixed ) {
        -: 1038:			return true;
        -: 1039:		}
        5: 1040:		this->is_data_fixed = true;
       10: 1041:		this->data.push_back( 0xFD );
        5: 1042:		this->data.push_back( op1 );
       10: 1043:		this->data.push_back( d.i );
        -: 1044:	}
        -: 1045:	else {
       12: 1046:		if( this->is_data_fixed ) {
        -: 1047:			return true;
        -: 1048:		}
        -: 1049:		this->set_code_size( &info, 1 );
        4: 1050:		this->is_data_fixed = true;
        4: 1051:		this->data.push_back( op1 );
        -: 1052:	}
        -: 1053:	return true;
        -: 1054:}
        -: 1055:
        -: 1056:// --------------------------------------------------------------------
     1061: 1057:bool CZMA_PARSE::opecode_destination8_n8( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1058:	int ddd;
        -: 1059:	CVALUE imm8;
        -: 1060:
     8587: 1061:	if( words.size() < 4 || (!info.is_sss_or_ddd( words[1] ) && !info.is_ix_hl( words[1] ) && !info.is_iy_hl( words[1] )) || words[2] != "," || words[3] == "[" ) {
        -: 1062:		return false;
        -: 1063:	}
      598: 1064:	if( info.is_sss_or_ddd( words[1] ) ) {
        -: 1065:		this->set_code_size( &info, 2 );
        -: 1066:	}
      144: 1067:	else if( info.is_ix_hl( words[1] ) ) {
        -: 1068:		this->set_code_size( &info, 3 );
        -: 1069:	}
        -: 1070:	else {
        -: 1071:		this->set_code_size( &info, 3 );
        -: 1072:	}
      299: 1073:	if( !this->expression( info, 3, imm8 ) ) {
        -: 1074:		return false;
        -: 1075:	}
      223: 1076:	if( imm8.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1077:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1078:		return false;
        -: 1079:	}
      223: 1080:	if( imm8.i < -128 || imm8.i > 255) {
       20: 1081:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
        4: 1082:		return false;
        -: 1083:	}
      219: 1084:	if( this->is_data_fixed ) {
        -: 1085:		return true;
        -: 1086:	}
       72: 1087:	this->is_data_fixed = true;
      144: 1088:	if( info.is_sss_or_ddd( words[1] ) ) {
      128: 1089:		ddd = info.sss_or_ddd_id[words[1]];
        -: 1090:	}
       16: 1091:	else if( info.is_ix_hl( words[1] ) ) {
        8: 1092:		ddd = info.ix_hl[words[1]];
        8: 1093:		this->data.push_back( 0xDD );
        -: 1094:	}
        -: 1095:	else {
        8: 1096:		ddd = info.iy_hl[words[1]];
        8: 1097:		this->data.push_back( 0xFD );
        -: 1098:	}
      144: 1099:	this->data.push_back( (unsigned char)(op1 | (ddd << 3)) );
      144: 1100:	this->data.push_back( imm8.i );
       72: 1101:	return true;
        -: 1102:}
        -: 1103:
        -: 1104:// --------------------------------------------------------------------
      627: 1105:bool CZMA_PARSE::opecode_a_n8( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1106:	CVALUE imm8;
        -: 1107:
     2064: 1108:	if( words.size() < 4 || words[1] != "A" || words[2] != "," || words[3] == "[" ) {
        -: 1109:		return false;
        -: 1110:	}
        -: 1111:	this->set_code_size( &info, 2 );
       90: 1112:	if( !this->expression( info, 3, imm8 ) ) {
        -: 1113:		return false;
        -: 1114:	}
       66: 1115:	if( imm8.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1116:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1117:		return false;
        -: 1118:	}
       66: 1119:	if( this->is_data_fixed ) {
        -: 1120:		return true;
        -: 1121:	}
       22: 1122:	this->is_data_fixed = true;
       22: 1123:	this->data.push_back( op1 );
       44: 1124:	this->data.push_back( imm8.i );
       22: 1125:	return true;
        -: 1126:}
        -: 1127:
        -: 1128:// --------------------------------------------------------------------
       42: 1129:bool CZMA_PARSE::opecode_n8( CZMA_INFORMATION &info, unsigned char op1 ){
        -: 1130:	CVALUE imm8;
        -: 1131:
      123: 1132:	if( words.size() < 2 || words[ 1 ] == "[" ){
        -: 1133:		return false;
        -: 1134:	}
        -: 1135:	this->set_code_size( &info, 2 );
       39: 1136:	if( !this->expression( info, 1, imm8 ) ){
        -: 1137:		return false;
        -: 1138:	}
       21: 1139:	if( imm8.value_type != CVALUE_TYPE::CV_INTEGER ){
    #####: 1140:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1141:		return false;
        -: 1142:	}
       21: 1143:	if( this->is_data_fixed ){
        -: 1144:		return true;
        -: 1145:	}
        7: 1146:	this->is_data_fixed = true;
        7: 1147:	this->data.push_back( op1 );
       14: 1148:	this->data.push_back( imm8.i );
        7: 1149:	return true;
        -: 1150:}
        -: 1151:
        -: 1152:// --------------------------------------------------------------------
      168: 1153:bool CZMA_PARSE::opecode_register16( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1154:	int rp;
        -: 1155:
      621: 1156:	if( words.size() != 2 || (!info.is_rp( words[1] ) && words[1] != "IX" && words[1] != "IY") ) {
        -: 1157:		return false;
        -: 1158:	}
       72: 1159:	if( this->is_data_fixed ) {
        -: 1160:		return true;
        -: 1161:	}
       24: 1162:	this->is_data_fixed = true;
       48: 1163:	if( words[1] == "IX" ) {
        -: 1164:		rp = 2;
        -: 1165:		this->set_code_size( &info, 2 );
        8: 1166:		this->data.push_back( 0xDD );
        -: 1167:	}
       20: 1168:	else if( words[1] == "IY" ) {
        -: 1169:		rp = 2;
        -: 1170:		this->set_code_size( &info, 2 );
        8: 1171:		this->data.push_back( 0xFD );
        -: 1172:	}
        -: 1173:	else {
       16: 1174:		rp = info.rp_id[words[1]];
        -: 1175:		this->set_code_size( &info, 1 );
        -: 1176:	}
       48: 1177:	this->data.push_back( (unsigned char)(op1 | (rp << 4)) );
       24: 1178:	return true;
        -: 1179:}
        -: 1180:
        -: 1181:// --------------------------------------------------------------------
      824: 1182:bool CZMA_PARSE::opecode_destination16_n16( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1183:	int rp;
        -: 1184:	CVALUE nn;
        -: 1185:
     4971: 1186:	if( words.size() < 4 || (!info.is_rp( words[1] ) && words[1] != "IX" && words[1] != "IY") || words[2] != "," || words[3] == "[" ) {
        -: 1187:		return false;
        -: 1188:	}
     1260: 1189:	if( words[1] == "IX" || words[1] == "IY" ) {
        -: 1190:		this->set_code_size( &info, 4 );
        -: 1191:	}
        -: 1192:	else {
        -: 1193:		this->set_code_size( &info, 3 );
        -: 1194:	}
      422: 1195:	if( !this->expression( info, 3, nn ) ) {
      470: 1196:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
       94: 1197:		return false;
        -: 1198:	}
      328: 1199:	if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1200:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1201:		return false;
        -: 1202:	}
      328: 1203:	if( nn.i < -32768 || nn.i > 65535 ) {
       20: 1204:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
        4: 1205:		return false;
        -: 1206:	}
      324: 1207:	if( this->is_data_fixed ) {
        -: 1208:		return true;
        -: 1209:	}
      108: 1210:	this->is_data_fixed = true;
      216: 1211:	if( words[1] == "IX" ) {
        -: 1212:		rp = 2;
        4: 1213:		this->data.push_back( 0xDD );
        -: 1214:	}
      106: 1215:	else if( words[1] == "IY" ) {
        -: 1216:		rp = 2;
        4: 1217:		this->data.push_back( 0xFD );
        -: 1218:	}
        -: 1219:	else {
      104: 1220:		rp = info.rp_id[words[1]];
        -: 1221:	}
      216: 1222:	this->data.push_back( (unsigned char)(op1 | (rp << 4)) );
      216: 1223:	this->data.push_back( nn.i & 255 );
      216: 1224:	this->data.push_back( (nn.i >> 8) & 255 );
      108: 1225:	return true;
        -: 1226:}
        -: 1227:
        -: 1228:// --------------------------------------------------------------------
      500: 1229:bool CZMA_PARSE::opecode_destination16_memory16( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c ) {
        -: 1230:	int rp;
        -: 1231:	CVALUE nn;
        -: 1232:
     2466: 1233:	if( words.size() < 6 || (!info.is_rp( words[1] ) && words[1] != "IX" && words[1] != "IY") || words[2] != "," || words[3] != "[" ) {
        -: 1234:		return false;
        -: 1235:	}
       84: 1236:	if( words[1] == "HL" ) {
        -: 1237:		this->set_code_size( &info, 3 );
        -: 1238:	}
        -: 1239:	else {
        -: 1240:		this->set_code_size( &info, 4 );
        -: 1241:	}
       42: 1242:	if( !this->expression( info, 4, nn ) ) {
    #####: 1243:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1244:		return false;
        -: 1245:	}
       42: 1246:	if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1247:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1248:		return false;
        -: 1249:	}
       42: 1250:	if( nn.i < -32768 || nn.i > 65535 ) {
    #####: 1251:		put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####: 1252:		return false;
        -: 1253:	}
       42: 1254:	if( this->is_data_fixed ) {
        -: 1255:		return true;
        -: 1256:	}
       14: 1257:	this->is_data_fixed = true;
       28: 1258:	if( words[1] == "HL" ) {
        4: 1259:		this->data.push_back( op1 );
        -: 1260:	}
       10: 1261:	else if( words[1] == "IX" ) {
        4: 1262:		this->data.push_back( 0xDD );
        2: 1263:		this->data.push_back( op1 );
        -: 1264:	}
        8: 1265:	else if( words[1] == "IY" ) {
        4: 1266:		this->data.push_back( 0xFD );
        2: 1267:		this->data.push_back( op1 );
        -: 1268:	}
        -: 1269:	else {
        6: 1270:		rp = info.rp_id[words[1]];
       12: 1271:		this->data.push_back( 0xED );
       12: 1272:		this->data.push_back( (unsigned char)(op1c | (rp << 4)) );
        -: 1273:	}
       28: 1274:	this->data.push_back( nn.i & 255 );
       28: 1275:	this->data.push_back( (nn.i >> 8) & 255 );
       14: 1276:	return true;
        -: 1277:}
        -: 1278:
        -: 1279:// --------------------------------------------------------------------
      458: 1280:bool CZMA_PARSE::opecode_memory_hl_source8( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1281:	int i, sss;
        -: 1282:	CVALUE nn;
        -: 1283:
      916: 1284:	if( words[1] != "[" ) {
        -: 1285:		return false;
        -: 1286:	}
     2064: 1287:	for( i = 2; i < (int)words.size() && words[i] != "]"; i++ ) {
        -: 1288:	}
      226: 1289:	if( i >= (int)words.size() ) {
        -: 1290:		return false;
        -: 1291:	}
      904: 1292:	if( words[i + 1] != "," || !info.is_sss_or_ddd( words[i + 2] ) ) {
        -: 1293:		return false;
        -: 1294:	}
      312: 1295:	sss = info.sss_or_ddd_id[words[i + 2]];
      156: 1296:	if( this->check_location_hl( 1 ) ) {
       36: 1297:		if( this->is_data_fixed ) {
        -: 1298:			return true;
        -: 1299:		}
        -: 1300:		this->set_code_size( &info, 1 );
       12: 1301:		this->is_data_fixed = true;
       24: 1302:		this->data.push_back( (unsigned char)(op1 | sss) );
       12: 1303:		return true;
        -: 1304:	}
      120: 1305:	if( this->check_location_ix( 1 ) ) {
        -: 1306:		this->set_code_size( &info, 3 );
      108: 1307:		if( words[3] == "+" || words[3] == "-" ) {
       48: 1308:			if( !this->expression( info, 3, nn ) ) {
    #####: 1309:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1310:				return false;
        -: 1311:			}
       48: 1312:			if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1313:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1314:				return false;
        -: 1315:			}
       48: 1316:			if( nn.i < -128 || nn.i > 127 ) {
       30: 1317:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
        6: 1318:				return false;
        -: 1319:			}
        -: 1320:		}
        -: 1321:		else {
        3: 1322:			nn.i = 0;
        -: 1323:		}
       45: 1324:		if( this->is_data_fixed ) {
        -: 1325:			return true;
        -: 1326:		}
       15: 1327:		this->is_data_fixed = true;
       30: 1328:		this->data.push_back( 0xDD );
       30: 1329:		this->data.push_back( (unsigned char)(op1 | sss) );
       30: 1330:		this->data.push_back( nn.i );
       15: 1331:		return true;
        -: 1332:	}
       69: 1333:	if( this->check_location_iy( 1 ) ) {
        -: 1334:		this->set_code_size( &info, 3 );
      108: 1335:		if( words[3] == "+" || words[3] == "-" ) {
       48: 1336:			if( !this->expression( info, 3, nn ) ) {
    #####: 1337:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1338:				return false;
        -: 1339:			}
       48: 1340:			if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1341:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1342:				return false;
        -: 1343:			}
       48: 1344:			if( nn.i < -128 || nn.i > 127 ) {
       30: 1345:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
        6: 1346:				return false;
        -: 1347:			}
        -: 1348:		}
        -: 1349:		else {
        3: 1350:			nn.i = 0;
        -: 1351:		}
       45: 1352:		if( this->is_data_fixed ) {
        -: 1353:			return true;
        -: 1354:		}
       15: 1355:		this->is_data_fixed = true;
       30: 1356:		this->data.push_back( 0xFD );
       30: 1357:		this->data.push_back( (unsigned char)(op1 | sss) );
       30: 1358:		this->data.push_back( nn.i );
       15: 1359:		return true;
        -: 1360:	}
        -: 1361:	return false;
        -: 1362:}
        -: 1363:
        -: 1364:// --------------------------------------------------------------------
      332: 1365:bool CZMA_PARSE::opecode_memory_hl_n8( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1366:	int i;
        -: 1367:	CVALUE n, d;
        -: 1368:
      664: 1369:	if( words[1] != "[" ) {
        -: 1370:		return false;
        -: 1371:	}
      804: 1372:	for( i = 2; i < (int) words.size() && words[i] != "]"; i++ ) {
        -: 1373:	}
      100: 1374:	if( i >= (int) words.size() ) {
        -: 1375:		return false;
        -: 1376:	}
      400: 1377:	if( words[i + 1] != "," || info.is_sss_or_ddd( words[i + 2] ) ) {
        -: 1378:		return false;
        -: 1379:	}
       70: 1380:	if( this->check_location_hl( 1 ) ) {
        9: 1381:		if( !this->expression( info, i + 2, n ) ) {
       15: 1382:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
        3: 1383:			return false;
        -: 1384:		}
        6: 1385:		if( n.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1386:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1387:			return false;
        -: 1388:		}
        6: 1389:		if( n.i < -128 || n.i > 127 ) {
    #####: 1390:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ), info.all_error_enable, info.error_disable );
    #####: 1391:			info.error_disable = true;
    #####: 1392:			return false;
        -: 1393:		}
        -: 1394:		this->set_code_size( &info, 2 );
        6: 1395:		if( this->is_data_fixed ) {
        -: 1396:			return true;
        -: 1397:		}
        2: 1398:		this->is_data_fixed = true;
        2: 1399:		this->data.push_back( op1 );
        4: 1400:		this->data.push_back( n.i & 255 );
        2: 1401:		return true;
        -: 1402:	}
       61: 1403:	if( this->check_location_ix( 1 ) ) {
        -: 1404:		//	LD [IX + nn], mm
        -: 1405:		//	       ^
       32: 1406:		if( words[3] == "+" || words[3] == "-" ) {
        -: 1407:			//	LD [IX + nn], mm
        -: 1408:			//	         ^^
       16: 1409:			if( !this->expression( info, 3, d ) ) {
    #####: 1410:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1411:				return false;
        -: 1412:			}
       16: 1413:			if( d.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1414:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1415:				return false;
        -: 1416:			}
       16: 1417:			if( d.i < -128 || d.i > 127 ) {
    #####: 1418:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ), info.all_error_enable, info.error_disable );
    #####: 1419:				info.error_disable = true;
    #####: 1420:				return false;
        -: 1421:			}
        -: 1422:		}
        -: 1423:		else {
    #####: 1424:			d.i = 0;
        -: 1425:		}
        -: 1426:		//	LD [IX + nn], mm
        -: 1427:		//	              ^^
       16: 1428:		if( !this->expression( info, i + 2, n ) ) {
       50: 1429:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
       10: 1430:			return false;
        -: 1431:		}
        6: 1432:		if( n.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1433:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1434:			return false;
        -: 1435:		}
        6: 1436:		if( n.i < -128 || n.i > 255 ) {
    #####: 1437:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ), info.all_error_enable, info.error_disable );
    #####: 1438:			info.error_disable = true;
    #####: 1439:			return false;
        -: 1440:		}
        -: 1441:		this->set_code_size( &info, 4 );
        6: 1442:		if( this->is_data_fixed ) {
        -: 1443:			return true;
        -: 1444:		}
        2: 1445:		this->is_data_fixed = true;
        4: 1446:		this->data.push_back( 0xDD );
        2: 1447:		this->data.push_back( op1 );
        4: 1448:		this->data.push_back( d.i );
        4: 1449:		this->data.push_back( n.i & 255 );
        2: 1450:		return true;
        -: 1451:	}
       45: 1452:	if( this->check_location_iy( 1 ) ) {
        -: 1453:		//	LD [IY + nn], mm
        -: 1454:		//	       ^
       12: 1455:		if( words[3] == "+" || words[3] == "-" ) {
        -: 1456:			//	LD [IY + nn], mm
        -: 1457:			//	         ^^
        6: 1458:			if( !this->expression( info, 3, d ) ) {
    #####: 1459:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1460:				return false;
        -: 1461:			}
        6: 1462:			if( d.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1463:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1464:				return false;
        -: 1465:			}
        6: 1466:			if( d.i < -128 || d.i > 127 ) {
    #####: 1467:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ), info.all_error_enable, info.error_disable );
    #####: 1468:				info.error_disable = true;
    #####: 1469:				return false;
        -: 1470:			}
        -: 1471:		}
        -: 1472:		else {
    #####: 1473:			d.i = 0;
        -: 1474:		}
        -: 1475:		//	LD [IY + nn], mm
        -: 1476:		//	              ^^
        6: 1477:		if( !this->expression( info, i + 2, n ) ) {
    #####: 1478:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1479:			return false;
        -: 1480:		}
        6: 1481:		if( n.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1482:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1483:			return false;
        -: 1484:		}
        6: 1485:		if( n.i < -128 || n.i > 255 ) {
    #####: 1486:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ), info.all_error_enable, info.error_disable );
    #####: 1487:			info.error_disable = true;
    #####: 1488:			return false;
        -: 1489:		}
        -: 1490:		this->set_code_size( &info, 4 );
        6: 1491:		if( this->is_data_fixed ) {
        -: 1492:			return true;
        -: 1493:		}
        2: 1494:		this->is_data_fixed = true;
        4: 1495:		this->data.push_back( 0xFD );
        2: 1496:		this->data.push_back( op1 );
        4: 1497:		this->data.push_back( d.i );
        4: 1498:		this->data.push_back( n.i & 255 );
        2: 1499:		return true;
        -: 1500:	}
        -: 1501:	return false;
        -: 1502:}
        -: 1503:
        -: 1504:// --------------------------------------------------------------------
     1079: 1505:bool CZMA_PARSE::opecode_a_memory_bc( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1506:	CVALUE nn;
        -: 1507:	int index;
        -: 1508:
     2569: 1509:	if( words.size() == 6 && words[1] == "A" && words[2] == "," && words[3] == "[" && words[4] == "BC" && words[5] == "]" ) {
        6: 1510:		if( this->is_data_fixed ) {
        -: 1511:			return true;
        -: 1512:		}
        -: 1513:		this->set_code_size( &info, 1 );
        2: 1514:		this->is_data_fixed = true;
        4: 1515:		this->data.push_back( op1 | 0x00 );
        2: 1516:		return true;
        -: 1517:	}
     1460: 1518:	if( words.size() == 6 && words[1] == "A" && words[2] == "," && words[3] == "[" && words[4] == "DE" && words[5] == "]" ) {
        6: 1519:		if( this->is_data_fixed ) {
        -: 1520:			return true;
        -: 1521:		}
        -: 1522:		this->set_code_size( &info, 1 );
        2: 1523:		this->is_data_fixed = true;
        4: 1524:		this->data.push_back( op1 | 0x10 );
        2: 1525:		return true;
        -: 1526:	}
     1653: 1527:	if( words.size() >= 6 && words[1] == "A" && words[2] == "," && words[3] == "[" ) {
        -: 1528:		this->set_code_size( &info, 3 );
       45: 1529:		index = this->expression( info, 4, nn );
       45: 1530:		if( index == 0 ) {
        -: 1531:			//	\AG[o
        -: 1532:			return false;	//	}b` false
        -: 1533:		}
       12: 1534:		if( words[index] != "]" ) {
    #####: 1535:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1536:			return false;
        -: 1537:		}
       12: 1538:		if( (index + 1) < (int)words.size() ) {
    #####: 1539:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1540:			return false;
        -: 1541:		}
        6: 1542:		if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1543:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1544:			return false;
        -: 1545:		}
        6: 1546:		if( nn.i < -32768 || nn.i > 65535 ) {
    #####: 1547:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####: 1548:			return false;
        -: 1549:		}
        6: 1550:		if( this->is_data_fixed ) {
        -: 1551:			return true;
        -: 1552:		}
        2: 1553:		this->is_data_fixed = true;
        4: 1554:		this->data.push_back( op1 | 0x30 );
        4: 1555:		this->data.push_back( nn.i & 255 );
        4: 1556:		this->data.push_back( (nn.i >> 8) & 255 );
        2: 1557:		return true;
        -: 1558:	}
        -: 1559:	return false;
        -: 1560:}
        -: 1561:
        -: 1562:// --------------------------------------------------------------------
      314: 1563:bool CZMA_PARSE::opecode_memory_bc_a( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1564:	int i;
        -: 1565:	CVALUE nn;
        -: 1566:
      775: 1567:	if( words.size() == 6 && words[1] == "[" && words[2] == "BC" && words[3] == "]" && words[4] == "," && words[5] == "A" ) {
        6: 1568:		if( this->is_data_fixed ) {
        -: 1569:			return true;
        -: 1570:		}
        -: 1571:		this->set_code_size( &info, 1 );
        2: 1572:		this->is_data_fixed = true;
        4: 1573:		this->data.push_back( op1 | 0x00 );
        2: 1574:		return true;
        -: 1575:	}
      443: 1576:	if( words.size() == 6 && words[1] == "[" && words[2] == "DE" && words[3] == "]" && words[4] == "," && words[5] == "A" ) {
        6: 1577:		if( this->is_data_fixed ) {
        -: 1578:			return true;
        -: 1579:		}
        -: 1580:		this->set_code_size( &info, 1 );
        2: 1581:		this->is_data_fixed = true;
        4: 1582:		this->data.push_back( op1 | 0x10 );
        2: 1583:		return true;
        -: 1584:	}
     2688: 1585:	for( i = 2; i < (int)words.size() && words[i] != "]"; i++ ) {
        -: 1586:	}
      302: 1587:	if( i >= (int)words.size() ) {
        -: 1588:		return false;
        -: 1589:	}
      317: 1590:	if( (int)words.size() == (i + 3) && words[1] == "[" && words[i] == "]" && words[i + 1] == "," && words[i + 2] == "A" ) {
        -: 1591:		this->set_code_size( &info, 3 );
       18: 1592:		if( !this->expression( info, 2, nn ) ) {
       60: 1593:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
       12: 1594:			return false;
        -: 1595:		}
        6: 1596:		if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1597:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1598:			return false;
        -: 1599:		}
        6: 1600:		if( nn.i < -32768 || nn.i > 65535 ) {
    #####: 1601:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####: 1602:			return false;
        -: 1603:		}
        6: 1604:		if( this->is_data_fixed ) {
        -: 1605:			return true;
        -: 1606:		}
        2: 1607:		this->is_data_fixed = true;
        4: 1608:		this->data.push_back( op1 | 0x30 );
        4: 1609:		this->data.push_back( nn.i & 255 );
        4: 1610:		this->data.push_back( (nn.i >> 8) & 255 );
        2: 1611:		return true;
        -: 1612:	}
        -: 1613:	return false;
        -: 1614:}
        -: 1615:
        -: 1616:// --------------------------------------------------------------------
      296: 1617:bool CZMA_PARSE::opecode_memory16_source16( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c, unsigned char op2 ) {
        -: 1618:	int i, rp;
        -: 1619:	CVALUE nn;
        -: 1620:
      592: 1621:	if( words[1] != "[" ) {
        -: 1622:		return false;
        -: 1623:	}
      516: 1624:	for( i = 2; i < (int) words.size() && words[i] != "]"; i++ ) {
        -: 1625:	}
      116: 1626:	if( (int)words.size() != (i + 3) || words[i + 1] != "," ) {
        -: 1627:		return false;
        -: 1628:	}
      104: 1629:	if(  words[i + 2] == "HL" ) {
        -: 1630:		this->set_code_size( &info, 3 );
       10: 1631:		if( !this->expression( info, 2, nn ) ) {
       20: 1632:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
        4: 1633:			return false;
        -: 1634:		}
        6: 1635:		if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1636:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1637:			return false;
        -: 1638:		}
        6: 1639:		if( nn.i < -32768 || nn.i > 65535 ) {
    #####: 1640:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####: 1641:			return false;
        -: 1642:		}
        6: 1643:		if( this->is_data_fixed ) {
        -: 1644:			return true;
        -: 1645:		}
        2: 1646:		this->is_data_fixed = true;
        2: 1647:		this->data.push_back( op1c );
        4: 1648:		this->data.push_back( nn.i & 255 );
        4: 1649:		this->data.push_back( (nn.i >> 8) & 255 );
        2: 1650:		return true;
        -: 1651:	}
       42: 1652:	if( info.is_rp(words[i+2]) ) {
        -: 1653:		this->set_code_size( &info, 4 );
       18: 1654:		if( !this->expression( info, 2, nn ) ) {
    #####: 1655:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1656:			return false;
        -: 1657:		}
       18: 1658:		if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1659:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1660:			return false;
        -: 1661:		}
       18: 1662:		if(nn.i < -32768 || nn.i > 65535) {
    #####: 1663:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####: 1664:			return false;
        -: 1665:		}
       36: 1666:		rp = info.rp_id[words[i + 2]];
       18: 1667:		if( this->is_data_fixed ) {
        -: 1668:			return true;
        -: 1669:		}
        6: 1670:		this->is_data_fixed = true;
        6: 1671:		this->data.push_back( op1 );
       12: 1672:		this->data.push_back( (unsigned char)(op2 | (rp << 4)) );
       12: 1673:		this->data.push_back( nn.i & 255 );
       12: 1674:		this->data.push_back( (nn.i >> 8) & 255 );
        6: 1675:		return true;
        -: 1676:	}
       48: 1677:	if( words[i + 2] == "IX" ) {
        -: 1678:		this->set_code_size( &info, 4 );
        6: 1679:		if( !this->expression( info, 2, nn ) ) {
    #####: 1680:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1681:			return false;
        -: 1682:		}
        6: 1683:		if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1684:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1685:			return false;
        -: 1686:		}
        6: 1687:		if(nn.i < -32768 || nn.i > 65535) {
    #####: 1688:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####: 1689:			return false;
        -: 1690:		}
        6: 1691:		if( this->is_data_fixed ) {
        -: 1692:			return true;
        -: 1693:		}
        2: 1694:		this->is_data_fixed = true;
        4: 1695:		this->data.push_back( 0xDD );
        2: 1696:		this->data.push_back( op1c );
        4: 1697:		this->data.push_back( nn.i & 255 );
        4: 1698:		this->data.push_back( (nn.i >> 8) & 255 );
        2: 1699:		return true;
        -: 1700:	}
       18: 1701:	if( words[i + 2] == "IY" ) {
        -: 1702:		this->set_code_size( &info, 4 );
        6: 1703:		if( !this->expression( info, 2, nn ) ) {
    #####: 1704:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1705:			return false;
        -: 1706:		}
        6: 1707:		if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1708:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1709:			return false;
        -: 1710:		}
        6: 1711:		if(nn.i < -32768 || nn.i > 65535) {
    #####: 1712:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####: 1713:			return false;
        -: 1714:		}
        6: 1715:		if( this->is_data_fixed ) {
        -: 1716:			return true;
        -: 1717:		}
        2: 1718:		this->is_data_fixed = true;
        4: 1719:		this->data.push_back( 0xFD );
        2: 1720:		this->data.push_back( op1c );
        4: 1721:		this->data.push_back( nn.i & 255 );
        4: 1722:		this->data.push_back( (nn.i >> 8) & 255 );
        2: 1723:		return true;
        -: 1724:	}
        -: 1725:	return false;
        -: 1726:}
        -: 1727:
        -: 1728:// --------------------------------------------------------------------
      842: 1729:bool CZMA_PARSE::opecode_sp_hl( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1730:
     2009: 1731:	if( words.size() != 4 || words[1] != "SP" || words[2] != "," ) {
        -: 1732:		return false;
        -: 1733:	}
       24: 1734:	if( words[3] == "HL" ) {
        6: 1735:		if( this->is_data_fixed ) {
        -: 1736:			return true;
        -: 1737:		}
        2: 1738:		this->is_data_fixed = true;
        -: 1739:		this->set_code_size( &info, 1 );
        2: 1740:		this->data.push_back( op1 );
        2: 1741:		return true;
        -: 1742:	}
       18: 1743:	if( words[3] == "IX" ) {
        6: 1744:		if( this->is_data_fixed ) {
        -: 1745:			return true;
        -: 1746:		}
        2: 1747:		this->is_data_fixed = true;
        -: 1748:		this->set_code_size( &info, 2 );
        4: 1749:		this->data.push_back( 0xDD );
        2: 1750:		this->data.push_back( op1 );
        2: 1751:		return true;
        -: 1752:	}
       12: 1753:	if( words[3] == "IY" ) {
        6: 1754:		if( this->is_data_fixed ) {
        -: 1755:			return true;
        -: 1756:		}
        2: 1757:		this->is_data_fixed = true;
        -: 1758:		this->set_code_size( &info, 2 );
        4: 1759:		this->data.push_back( 0xFD );
        2: 1760:		this->data.push_back( op1 );
        2: 1761:		return true;
        -: 1762:	}
        -: 1763:	return false;
        -: 1764:}
        -: 1765:
        -: 1766:// --------------------------------------------------------------------
       78: 1767:bool CZMA_PARSE::opecode_register16_with_af( CZMA_INFORMATION& info, unsigned char op1 ) {
        -: 1768:	int rp;
        -: 1769:
      342: 1770:	if( words.size() != 2 || (!info.is_rp_with_af( words[1] ) && words[1] != "IX" && words[1] != "IY") ) {
        -: 1771:		return false;
        -: 1772:	}
       72: 1773:	if( this->is_data_fixed ) {
        -: 1774:		return true;
        -: 1775:	}
       24: 1776:	this->is_data_fixed = true;
       48: 1777:	if( words[1] == "IX" ) {
        -: 1778:		rp = 2;
        -: 1779:		this->set_code_size( &info, 2 );
        8: 1780:		this->data.push_back( 0xDD );
        -: 1781:	}
       20: 1782:	else if( words[1] == "IY" ) {
        -: 1783:		rp = 2;
        -: 1784:		this->set_code_size( &info, 2 );
        8: 1785:		this->data.push_back( 0xFD );
        -: 1786:	}
        -: 1787:	else {
       16: 1788:		rp = info.rp_with_af_id[words[1]];
        -: 1789:		this->set_code_size( &info, 1 );
        -: 1790:	}
       48: 1791:	this->data.push_back( (unsigned char)(op1 | (rp << 4)) );
       24: 1792:	return true;
        -: 1793:}
        -: 1794:
        -: 1795:// --------------------------------------------------------------------
      777: 1796:bool CZMA_PARSE::opecode_source8( CZMA_INFORMATION& info, unsigned char op1, int op2 ) {
        -: 1797:	int sss, ddd, n;
        -: 1798:	CVALUE nn;
        -: 1799:
     2874: 1800:	if( words.size() == 2 && info.is_sss_or_ddd( words[1] ) ) {
      462: 1801:		if( this->is_data_fixed ) {
        -: 1802:			return true;
        -: 1803:		}
      308: 1804:		sss = info.sss_or_ddd_id[words[1]];
      154: 1805:		this->is_data_fixed = true;
      154: 1806:		if( op2 != -1 ) {
        -: 1807:			this->set_code_size( &info, 2 );
      105: 1808:			this->data.push_back( op1 );
      210: 1809:			this->data.push_back( op2 | sss );
        -: 1810:		}
        -: 1811:		else {
        -: 1812:			this->set_code_size( &info, 1 );
       98: 1813:			this->data.push_back( (unsigned char)(op1 | sss) );
        -: 1814:		}
        -: 1815:		return true;
        -: 1816:	}
     1026: 1817:	if( words.size() == 2 && info.is_ix_hl( words[ 1 ] ) ){
       30: 1818:		if( this->is_data_fixed ){
        -: 1819:			return true;
        -: 1820:		}
       10: 1821:		this->is_data_fixed = true;
       20: 1822:		sss = info.ix_hl[ words[ 1 ] ];
        -: 1823:		this->set_code_size( &info, 2 );
       20: 1824:		this->data.push_back( 0xDD );
       20: 1825:		this->data.push_back( (unsigned char)( op1 | sss ) );
       10: 1826:		return true;
        -: 1827:	}
      906: 1828:	if( words.size() == 2 && info.is_iy_hl( words[ 1 ] ) ){
       30: 1829:		if( this->is_data_fixed ){
        -: 1830:			return true;
        -: 1831:		}
       10: 1832:		this->is_data_fixed = true;
       20: 1833:		sss = info.iy_hl[ words[ 1 ] ];
        -: 1834:		this->set_code_size( &info, 2 );
       20: 1835:		this->data.push_back( 0xFD );
       20: 1836:		this->data.push_back( (unsigned char)( op1 | sss ) );
       10: 1837:		return true;
        -: 1838:	}
      510: 1839:	if( words.size() == 4 && this->check_location_hl( 1 ) ) {
       60: 1840:		if( this->is_data_fixed ) {
        -: 1841:			return true;
        -: 1842:		}
       20: 1843:		this->is_data_fixed = true;
       20: 1844:		if( op2 != -1 ) {
        -: 1845:			this->set_code_size( &info, 2 );
       15: 1846:			this->data.push_back( op1 );
       30: 1847:			this->data.push_back( op2 | 0x06 );
        -: 1848:		}
        -: 1849:		else {
        -: 1850:			this->set_code_size( &info, 1 );
       10: 1851:			this->data.push_back( op1 | 0x06 );
        -: 1852:		}
        -: 1853:		return true;
        -: 1854:	}
      327: 1855:	if( words.size() >= 6 && this->check_location_ix( 1 ) ) {
       72: 1856:		if( op2 != -1 ) {
        -: 1857:			this->set_code_size( &info, 4 );
        -: 1858:		}
        -: 1859:		else {
        -: 1860:			this->set_code_size( &info, 3 );
        -: 1861:		}
      144: 1862:		if( words[3] == "+" || words[3] == "-" ) {
       72: 1863:			n = this->expression( info, 3, nn );
       72: 1864:			if( n == 0 ) {
    #####: 1865:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1866:				return false;
        -: 1867:			}
      144: 1868:			if( words[ n ] != "]" ){
    #####: 1869:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1870:				return false;
        -: 1871:			}
       72: 1872:			if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1873:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1874:				return false;
        -: 1875:			}
       72: 1876:			if( nn.i < -128 || nn.i > 127 ) {
    #####: 1877:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####: 1878:				return false;
        -: 1879:			}
      246: 1880:			if( words.size() > (unsigned)(n + 2) && words[ n + 1 ] == "," && info.is_sss_or_ddd( words[ n + 2 ] ) ){
       30: 1881:				ddd = info.sss_or_ddd_id[ words[ n + 2 ] ];
        -: 1882:			}
        -: 1883:			else{
        -: 1884:				ddd = 6;
        -: 1885:			}
        -: 1886:		}
        -: 1887:		else {
    #####: 1888:			nn.i = 0;
        -: 1889:			ddd = 6;
        -: 1890:		}
       72: 1891:		if( this->is_data_fixed ) {
        -: 1892:			return true;
        -: 1893:		}
       24: 1894:		this->is_data_fixed = true;
       48: 1895:		this->data.push_back( 0xDD );
       24: 1896:		if( op2 != -1 ) {
       19: 1897:			this->data.push_back( op1 );
       38: 1898:			this->data.push_back( nn.i );
       38: 1899:			this->data.push_back( op2 | ddd );
        -: 1900:		}
        -: 1901:		else {
       10: 1902:			this->data.push_back( (unsigned char)(op1 | ddd) );
       10: 1903:			this->data.push_back( nn.i );
        -: 1904:		}
        -: 1905:		return true;
        -: 1906:	}
      183: 1907:	if( words.size() >= 6 && this->check_location_iy( 1 ) ) {
       57: 1908:		if( op2 != -1 ) {
        -: 1909:			this->set_code_size( &info, 4 );
        -: 1910:		}
        -: 1911:		else {
        -: 1912:			this->set_code_size( &info, 3 );
        -: 1913:		}
      114: 1914:		if( words[3] == "+" || words[3] == "-" ) {
       57: 1915:			n = this->expression( info, 3, nn );
       57: 1916:			if( n == 0 ){
    #####: 1917:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1918:				return false;
        -: 1919:			}
      114: 1920:			if( words[ n ] != "]" ){
    #####: 1921:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1922:				return false;
        -: 1923:			}
       57: 1924:			if( nn.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1925:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1926:				return false;
        -: 1927:			}
       57: 1928:			if( nn.i < -128 || nn.i > 127 ) {
    #####: 1929:				put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::OUT_OF_RANGE_RELATIVE_ADDRESS ) );
    #####: 1930:				return false;
        -: 1931:			}
      171: 1932:			if( words.size() > (unsigned)(n + 2) && words[ n + 1 ] == "," && info.is_sss_or_ddd( words[ n + 2 ] ) ){
    #####: 1933:				ddd = info.sss_or_ddd_id[ words[ n + 2 ] ];
        -: 1934:			}
        -: 1935:			else{
        -: 1936:				ddd = 6;
        -: 1937:			}
        -: 1938:		}
        -: 1939:		else{
    #####: 1940:			nn.i = 0;
        -: 1941:			ddd = 6;
        -: 1942:		}
       57: 1943:		if( this->is_data_fixed ) {
        -: 1944:			return true;
        -: 1945:		}
       19: 1946:		this->is_data_fixed = true;
       38: 1947:		this->data.push_back( 0xFD );
       19: 1948:		if( op2 != -1 ) {
       14: 1949:			this->data.push_back( op1 );
       28: 1950:			this->data.push_back( nn.i );
       28: 1951:			this->data.push_back( op2 | ddd );
        -: 1952:		}
        -: 1953:		else {
       10: 1954:			this->data.push_back( (unsigned char)(op1 | ddd) );
       10: 1955:			this->data.push_back( nn.i );
        -: 1956:		}
        -: 1957:		return true;
        -: 1958:	}
        -: 1959:	return false;
        -: 1960:}
        -: 1961:
        -: 1962:// --------------------------------------------------------------------
      182: 1963:bool CZMA_PARSE::opecode_condition_address( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c ) {
        -: 1964:	int ccc, index;
        -: 1965:	CVALUE address;
        -: 1966:
      586: 1967:	if( words.size() == 2 && (words[1] == "HL" || words[1] == "IX" || words[1] == "IY") ) {
        -: 1968:		return false;
        -: 1969:	}
      466: 1970:	if( words.size() >= 4 && info.is_ccc( words[1] ) ) {
        -: 1971:		this->set_code_size( &info, 3 );
      102: 1972:		index = this->expression( info, 3, address );
      102: 1973:		if( index == 0 ) {
    #####: 1974:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1975:			return false;
        -: 1976:		}
      102: 1977:		if( address.value_type != CVALUE_TYPE::CV_INTEGER ) {
    #####: 1978:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
    #####: 1979:			return false;
        -: 1980:		}
      204: 1981:		if( index < (int)words.size() ) {
        -: 1982:			return false;
        -: 1983:		}
      192: 1984:		ccc = info.ccc_id[words[1]];
       96: 1985:		if( this->is_data_fixed ) {
        -: 1986:			return true;
        -: 1987:		}
       32: 1988:		this->is_data_fixed = true;
       64: 1989:		this->data.push_back( (unsigned char)(op1c | (ccc << 3)) );
       64: 1990:		this->data.push_back( address.i & 255 );
       64: 1991:		this->data.push_back( (address.i >> 8) & 255 );
       32: 1992:		return true;
        -: 1993:	}
        -: 1994:	else {
        -: 1995:		this->set_code_size( &info, 3 );
       80: 1996:		index = this->expression( info, 1, address );
       80: 1997:		if( index == 0 ) {
       70: 1998:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
       14: 1999:			return false;
        -: 2000:		}
       66: 2001:		if( address.value_type != CVALUE_TYPE::CV_INTEGER ) {
       35: 2002:			put_error( CZMA_ERROR::get( CZMA_ERROR_CODE::ILLEGAL_OPERAND ) );
        7: 2003:			return false;
        -: 2004:		}
      118: 2005:		if( index < (int)words.size() ) {
        -: 2006:			return false;
        -: 2007:		}
       53: 2008:		if( this->is_data_fixed ) {
        -: 2009:			return true;
        -: 2010:		}
       18: 2011:		this->is_data_fixed = true;
       18: 2012:		this->data.push_back( op1 );
       36: 2013:		this->data.push_back( address.i & 255 );
       36: 2014:		this->data.push_back( (address.i >> 8) & 255 );
       18: 2015:		return true;
        -: 2016:	}
        -: 2017:	return false;
        -: 2018:}
        -: 2019:
        -: 2020:// --------------------------------------------------------------------
       78: 2021:bool CZMA_PARSE::opecode_condition_offset( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c ) {
        -: 2022:	int address, ccc;
        -: 2023:
      279: 2024:	if( words.size() >= 4 && info.is_cc2( words[1] ) ) {
        -: 2025:		this->set_code_size( &info, 2 );
       45: 2026:		address = this->relative_address( info, 3 );
       45: 2027:		if( address == -9999 ) {
        -: 2028:			return false;
        -: 2029:		}
       32: 2030:		ccc = info.cc2_id[words[1]];
       16: 2031:		if( this->is_data_fixed ) {
        -: 2032:			return true;
        -: 2033:		}
        8: 2034:		this->is_data_fixed = true;
       16: 2035:		this->data.push_back( (unsigned char)(op1c | (ccc << 3)) );
       16: 2036:		this->data.push_back( address );
        8: 2037:		return true;
        -: 2038:	}
       66: 2039:	if( words.size() >= 2 ) {
        -: 2040:		this->set_code_size( &info, 2 );
       33: 2041:		address = this->relative_address( info, 1 );
       33: 2042:		if( address == -9999 ) {
        -: 2043:			return false;
        -: 2044:		}
       14: 2045:		if( this->is_data_fixed ) {
        -: 2046:			return true;
        -: 2047:		}
        5: 2048:		this->is_data_fixed = true;
        5: 2049:		this->data.push_back( op1 );
       10: 2050:		this->data.push_back( address );
        5: 2051:		return true;
        -: 2052:	}
        -: 2053:	return false;
        -: 2054:}
        -: 2055:
        -: 2056:// --------------------------------------------------------------------
       87: 2057:bool CZMA_PARSE::opecode_condition( CZMA_INFORMATION& info, unsigned char op1, unsigned char op1c ) {
        -: 2058:	int ccc;
        -: 2059:
      312: 2060:	if( words.size() == 2 && info.is_ccc( words[1] ) ) {
       96: 2061:		ccc = info.ccc_id[words[1]];
        -: 2062:		this->set_code_size( &info, 1 );
       48: 2063:		if( this->is_data_fixed ) {
        -: 2064:			return true;
        -: 2065:		}
       16: 2066:		this->is_data_fixed = true;
       32: 2067:		this->data.push_back( (unsigned char)(op1c | (ccc << 3)) );
       16: 2068:		return true;
        -: 2069:	}
       78: 2070:	else if( words.size() == 1 ) {
        -: 2071:		this->set_code_size( &info, 1 );
       36: 2072:		if( this->is_data_fixed ) {
        -: 2073:			return true;
        -: 2074:		}
       12: 2075:		this->is_data_fixed = true;
       12: 2076:		this->data.push_back( op1 );
       12: 2077:		return true;
        -: 2078:	}
        -: 2079:	return false;
        -: 2080:}
        -: 2081:
        -: 2082:// --------------------------------------------------------------------
       27: 2083:bool CZMA_PARSE::opecode_mulub( CZMA_INFORMATION& info, unsigned char op1, int op2 ) {
        -: 2084:	int ddd;
        -: 2085:
       54: 2086:	if( words.size() != 4 ) {
        -: 2087:		return false;
        -: 2088:	}
       48: 2089:	if( words[1] != "A" || words[2] != "," ) {
        -: 2090:		return false;
        -: 2091:	}
       60: 2092:	if( words[3] != "B" && words[3] != "C" && words[3] != "D" && words[3] != "E" ) {
        -: 2093:		return false;
        -: 2094:	}
       24: 2095:	if( this->is_data_fixed ) {
        -: 2096:		return true;
        -: 2097:	}
        8: 2098:	this->is_data_fixed = true;
        -: 2099:	this->set_code_size( &info, 2 );
        8: 2100:	ddd = info.sss_or_ddd_id[words[3]];
        8: 2101:	this->data.push_back( op1 );
       16: 2102:	this->data.push_back( op2 | (ddd << 3) );
        8: 2103:	return true;
        -: 2104:}
        -: 2105:
        -: 2106:// --------------------------------------------------------------------
       15: 2107:bool CZMA_PARSE::opecode_muluw( CZMA_INFORMATION& info ) {
        -: 2108:
       30: 2109:	if( words.size() != 4 ) {
        -: 2110:		return false;
        -: 2111:	}
       24: 2112:	if( words[1] != "HL" || words[2] != "," ) {
        -: 2113:		return false;
        -: 2114:	}
       12: 2115:	if( words[3] == "BC" ) {
        6: 2116:		if( this->is_data_fixed ) {
        -: 2117:			return true;
        -: 2118:		}
        2: 2119:		this->is_data_fixed = true;
        -: 2120:		this->set_code_size( &info, 2 );
        4: 2121:		this->data.push_back( 0xED );
        4: 2122:		this->data.push_back( 0xC3 );
        2: 2123:		return true;
        -: 2124:	}
        6: 2125:	if( words[3] == "SP" ) {
        6: 2126:		if( this->is_data_fixed ) {
        -: 2127:			return true;
        -: 2128:		}
        2: 2129:		this->is_data_fixed = true;
        -: 2130:		this->set_code_size( &info, 2 );
        4: 2131:		this->data.push_back( 0xED );
        4: 2132:		this->data.push_back( 0xC5 );
        2: 2133:		return true;
        -: 2134:	}
        -: 2135:	return false;
        -: 2136:}
        -: 2137:
        -: 2138:// --------------------------------------------------------------------
      315: 2139:bool CZMA_PARSE::opecode_destination8( CZMA_INFORMATION& info, unsigned char op1, int op2 ) {
        -: 2140:	int ddd;
        -: 2141:	CVALUE nn;
        -: 2142:
     1167: 2143:	if( words.size() == 2 && info.is_sss_or_ddd( words[1] ) ) {
      198: 2144:		ddd = info.sss_or_ddd_id[words[1]];
       99: 2145:		if( this->is_data_fixed ) {
        -: 2146:			return true;
        -: 2147:		}
       33: 2148:		this->is_data_fixed = true;
       33: 2149:		if( op2 != -1 ) {
        -: 2150:			this->set_code_size( &info, 2 );
    #####: 2151:			this->data.push_back( op1 );
    #####: 2152:			this->data.push_back( op2 | (ddd << 3) );
        -: 2153:		}
        -: 2154:		else {
        -: 2155:			this->set_code_size( &info, 1 );
       66: 2156:			this->data.push_back( (unsigned char)(op1 | (ddd << 3)) );
        -: 2157:		}
        -: 2158:		return true;
        -: 2159:	}
      771: 2160:	if( words.size() == 2 && info.is_ix_hl( words[1] ) ) {
       48: 2161:		ddd = info.ix_hl[words[1]];
       24: 2162:		if( this->is_data_fixed ) {
        -: 2163:			return true;
        -: 2164:		}
        8: 2165:		this->is_data_fixed = true;
        8: 2166:		if( op2 != -1 ) {
        -: 2167:			this->set_code_size( &info, 3 );
    #####: 2168:			this->data.push_back( 0xDD );
    #####: 2169:			this->data.push_back( op1 );
    #####: 2170:			this->data.push_back( op2 | (ddd << 3) );
        -: 2171:		}
        -: 2172:		else {
        -: 2173:			this->set_code_size( &info, 2 );
       16: 2174:			this->data.push_back( 0xDD );
       16: 2175:			this->data.push_back( (unsigned char)(op1 | (ddd << 3)) );
        -: 2176:		}
        -: 2177:		return true;
        -: 2178:	}
      675: 2179:	if( words.size() == 2 && info.is_iy_hl( words[1] ) ) {
       48: 2180:		ddd = info.iy_hl[words[1]];
       24: 2181:		if( this->is_data_fixed ) {
        -: 2182:			return true;
        -: 2183:		}
        8: 2184:		this->is_data_fixed = true;
        8: 2185:		if( op2 != -1 ) {
        -: 2186:			this->set_code_size( &info, 3 );
    #####: 2187:			this->data.push_back( 0xFD );
    #####: 2188:			this->data.push_back( op1 );
    #####: 2189:			this->data.push_back( (unsigned char)(op2 | (ddd << 3)) );
        -: 2190:		}
        -: 2191:		else {
        -: 2192:			this->set_code_size( &info, 2 );
       16: 2193:			this->data.push_back( 0xFD );
       16: 2194:			this->data.push_back( (unsigned char)(op1 | (ddd << 3)) );
        -: 2195:		}
        -: 2196:		return true;
        -: 2197:	}
        -: 2198:	return false;
        -: 2199:}
        -: 2200:
        -: 2201:// --------------------------------------------------------------------
    14966: 2202:bool CZMA_PARSE::write_output_and_log( CZMA_INFORMATION &info, std::ofstream *f ) {
        -: 2203:	unsigned char c;
        -: 2204:
    14966: 2205:	if( info.output_type == CZMA_INFORMATION::OUTPUT_TYPE::CZMA_BINARY ){
    80891: 2206:		for( auto d : data ){
    65942: 2207:			c = d;
    65942: 2208:			f->write( (const char *)&c, 1 );
        -: 2209:		}
        -: 2210:	}
        -: 2211:	else{
        -: 2212:		//	CZMA_INFORMATION::OUTPUT_TYPE::CZMA_INTELHEX
       48: 2213:		for( auto d : data ){
       31: 2214:			c = d;
       31: 2215:			info.hexfile.write( *f, c );
        -: 2216:		}
        -: 2217:	}
    47045: 2218:	for( auto &line : log ) {
    32079: 2219:		info.log << line << std::endl;
        -: 2220:	}
    14966: 2221:	return true;
      170: 2222:}
