        -:    0:Source:../zma_information.hpp
        -:    0:Programs:104
        -:    1:// --------------------------------------------------------------------
        -:    2://	Z80 Macro Assembler dictionary
        -:    3:// ====================================================================
        -:    4://	2019/05/05	t.hara
        -:    5:// --------------------------------------------------------------------
        -:    6:
        -:    7:#pragma once
        -:    8:
        -:    9:#include "zma_error.hpp"
        -:   10:#include <string>
        -:   11:#include <map>
        -:   12:#include <vector>
        -:   13:#include <fstream>
        -:   14:#include <sstream>
        -:   15:#include <iomanip>
        -:   16:
        -:   17:// --------------------------------------------------------------------
        -:   18:enum class CVALUE_TYPE {
        -:   19:	CV_UNKNOWN = 0x100,
        -:   20:	CV_UNKNOWN_INTEGER = 0x101,
        -:   21:	CV_UNKNOWN_STRING = 0x102,
        -:   22:	CV_INTEGER = 0x1,
        -:   23:	CV_STRING = 0x2,
        -:   24:};
        -:   25:
        -:   26:// --------------------------------------------------------------------
    94468:   27:class CVALUE {
        -:   28:public:
        -:   29:	CVALUE_TYPE value_type;
        -:   30:
        -:   31:	int			i;
        -:   32:	std::string	s;
        -:   33:
        -:   34:	// --------------------------------------------------------------------
    99702:   35:	CVALUE(): value_type( CVALUE_TYPE::CV_UNKNOWN ), i( 0 ), s( "" ) {
        -:   36:	}
        -:   37:
        -:   38:	// --------------------------------------------------------------------
        -:   39:	bool is_unknown( void ) const{
     4041:   40:		return ( ( (int)value_type & 0x100 ) == 0x100 );
        -:   41:	}
        -:   42:
        -:   43:	// --------------------------------------------------------------------
        -:   44:	bool is_integer( void ) const{
    73742:   45:		return ( ( (int)value_type & 0xFF ) == 0x1 );
        -:   46:	}
        -:   47:
        -:   48:	// --------------------------------------------------------------------
        -:   49:	bool is_string( void ) const{
    #####:   50:		return ( ( (int)value_type & 0xFF ) == 0x2 );
        -:   51:	}
        -:   52:
        -:   53:	// --------------------------------------------------------------------
        -:   54:	void inherit( CVALUE_TYPE base, CVALUE_TYPE inherit_a, CVALUE_TYPE inherit_b ){
       24:   55:		value_type = (CVALUE_TYPE)( (int)base | ( ( (int)inherit_a | (int)inherit_b ) & 0x100 ) );
        -:   56:	}
        -:   57:};
        -:   58:
        -:   59:// --------------------------------------------------------------------
    #####:   60:class CZMA_MACRO_ARG {
        -:   61:public:
        -:   62:	std::string						name;
        -:   63:	bool							is_through;
        -:   64:
        -:   65:	// --------------------------------------------------------------------
    #####:   66:	CZMA_MACRO_ARG(): name( "" ), is_through( false ) {
        -:   67:	}
        -:   68:};
        -:   69:
        -:   70:// --------------------------------------------------------------------
        -:   71:class CZMA_MACRO {
        -:   72:public:
        -:   73:	std::vector< CZMA_MACRO_ARG >	parameter_name_list;
        -:   74:	std::vector<class CZMA_PARSE*>	m_text;
        -:   75:};
        -:   76:
        -:   77:// --------------------------------------------------------------------
        -:   78:class CZMA_REPEAT_T {
        -:   79:public:
        -:   80:	std::string						counter_symbol;
        -:   81:	int								counter_end;
        -:   82:	bool							is_counter_end_fixed;
        -:   83:	std::string						scope_name;
        -:   84:	std::vector<class CZMA_PARSE*>	m_text;
        -:   85:
        -:   86:	// --------------------------------------------------------------------
    #####:   87:	CZMA_REPEAT_T(): counter_symbol( "" ), counter_end( 0 ), is_counter_end_fixed( false ), scope_name( "" ) {
    #####:   88:	}
        -:   89:};
        -:   90:
        -:   91:// --------------------------------------------------------------------
    #####:   92:class CZMA_IF_SUB_T {
        -:   93:public:
        -:   94:	bool							is_condition_fixed = false;
        -:   95:	bool							is_condition = false;
        -:   96:	class CZMA_PARSE_IF				*p_if = nullptr;
        -:   97:	class CZMA_TEXT					*p_text = nullptr;
        -:   98:};
        -:   99:
        -:  100:// --------------------------------------------------------------------
        -:  101:class CZMA_IF_T {
        -:  102:public:
        -:  103:	std::vector<CZMA_IF_SUB_T*>		m_sub;
        -:  104:};
        -:  105:
        -:  106:// --------------------------------------------------------------------
        4:  107:class CZMA_CHAR_SET {
        -:  108:public:
        -:  109:	std::vector< unsigned char >	ascii_to_map;
        -:  110:};
        -:  111:
        -:  112:// --------------------------------------------------------------------
       18:  113:class CZMA_INFORMATION {
        -:  114:public:
        -:  115:	std::map< std::string, CVALUE >	dict;
        -:  116:	std::map< std::string, int >	sss_or_ddd_id { { "B", 0 }, { "C", 1 }, { "D", 2 }, { "E", 3 }, { "H", 4 }, { "L", 5 }, { "A", 7 }, };
        -:  117:	std::map< std::string, int >	ix_hl{ { "IXH", 4 }, { "IXL", 5 }, };
        -:  118:	std::map< std::string, int >	iy_hl{ { "IYH", 4 }, { "IYL", 5 }, };
        -:  119:	std::map< std::string, int >	rp_id { { "BC", 0 }, { "DE", 1 }, { "HL", 2 }, { "SP", 3 }, };
        -:  120:	std::map< std::string, int >	ix_rp_id{ { "BC", 0 }, { "DE", 1 }, { "IX", 2 }, { "SP", 3 }, };
        -:  121:	std::map< std::string, int >	iy_rp_id{ { "BC", 0 }, { "DE", 1 }, { "IY", 2 }, { "SP", 3 }, };
        -:  122:	std::map< std::string, int >	rp_with_af_id{ { "BC", 0 }, { "DE", 1 }, { "HL", 2 }, {"AF", 3 }, };
        -:  123:	std::map< std::string, int >	ccc_id{ { "NZ", 0 }, { "Z", 1 }, { "NC", 2 }, { "C", 3 }, { "PO", 4 }, { "PE", 5 }, { "P", 6 }, { "M", 7 }, };
        -:  124:	std::map< std::string, int >	cc2_id{ { "NZ", 0 }, { "Z", 1 }, { "NC", 2 }, { "C", 3 }, };
        -:  125:	std::vector< std::string >		scope;
        -:  126:	std::vector< std::string >		include_path;
        -:  127:
        -:  128:	unsigned int auto_label_index;
        -:  129:
        -:  130:	bool		defs_is_space;	//	false: DEFS疑似命令は文字列配置(default), true: DEFS疑似命令は領域確保
        -:  131:
        -:  132:	enum class BLOCK_TYPE_T {
        -:  133:		CZMA_INFO_UNKNOWN,
        -:  134:		CZMA_INFO_MACRO_BLOCK,
        -:  135:		CZMA_INFO_REPEAT_BLOCK,
        -:  136:		CZMA_INFO_IF_BLOCK,
        -:  137:	};
        -:  138:	std::map< std::string, BLOCK_TYPE_T >	block_begin_table{ { "REPEAT", { BLOCK_TYPE_T::CZMA_INFO_REPEAT_BLOCK } },
        -:  139:													{ "ELSEIF", BLOCK_TYPE_T::CZMA_INFO_IF_BLOCK }, { "ELSE", BLOCK_TYPE_T::CZMA_INFO_IF_BLOCK }, { "IF", { BLOCK_TYPE_T::CZMA_INFO_IF_BLOCK } } };
        -:  140:	std::map< std::string, BLOCK_TYPE_T >	block_end_table{ { "ENDM", BLOCK_TYPE_T::CZMA_INFO_MACRO_BLOCK }, { "ENDR", BLOCK_TYPE_T::CZMA_INFO_REPEAT_BLOCK },
        -:  141:													{ "ELSEIF", BLOCK_TYPE_T::CZMA_INFO_IF_BLOCK }, { "ELSE", BLOCK_TYPE_T::CZMA_INFO_IF_BLOCK }, { "ENDIF", BLOCK_TYPE_T::CZMA_INFO_IF_BLOCK }  };
        -:  142:	bool is_updated;
        -:  143:	bool is_block_processing;
        -:  144:	BLOCK_TYPE_T block_type;
        -:  145:	std::vector<class CZMA_PARSE*>			*p_text;
        -:  146:
        -:  147:	CZMA_MACRO* p_macro;
        -:  148:	std::map< std::string, CZMA_MACRO* >	macro_list;
        -:  149:	std::map< std::string, std::string >	parameter_list;
        -:  150:
        -:  151:	CZMA_REPEAT_T*							p_repeat;
        -:  152:
        -:  153:	CZMA_IF_T*								p_if;
        -:  154:
        -:  155:	std::map< std::string, CZMA_CHAR_SET >	char_set_list;
        -:  156:	CZMA_CHAR_SET*							p_char_set;
        -:  157:	std::string								s_char_set;
        -:  158:
        -:  159:	CZMA_ERROR								error;
        -:  160:	std::ofstream							log;
        -:  161:
        -:  162:	// --------------------------------------------------------------------
      174:  163:	CZMA_INFORMATION(): is_updated( false ), is_block_processing( false ), block_type( BLOCK_TYPE_T::CZMA_INFO_UNKNOWN  ), auto_label_index( 0 ), p_text( nullptr ), p_macro( nullptr ), p_if( nullptr ), p_repeat( nullptr ), p_char_set( nullptr ), defs_is_space(false) {
        6:  164:	}
        -:  165:
        -:  166:	// --------------------------------------------------------------------
        -:  167:	unsigned int get_auto_label_index( void ) {
    #####:  168:		return auto_label_index++;
        -:  169:	}
        -:  170:
        -:  171:	// --------------------------------------------------------------------
       50:  172:	std::string get_scope_path( void ) const {
       50:  173:		std::string r = "";
       50:  174:		for( std::string s : scope ) {
    #####:  175:			r = r + s + ":";
        -:  176:		}
       50:  177:		return r;
        -:  178:	}
        -:  179:
        -:  180:	// --------------------------------------------------------------------
       53:  181:	bool get_label_value( CVALUE& result, std::string word ) {
        -:  182:		int i, l;
        -:  183:		std::string s;
        -:  184:
      114:  185:		for( l = (int)scope.size(); l >= 0; l-- ) {
        -:  186:			s = "";
       53:  187:			for( i = 0; i < l; i++ ) {
    #####:  188:				s = s + scope[i] + ":";
        -:  189:			}
      106:  190:			s = s + word;
        -:  191:			if( this->dict.count( s ) ) {
       45:  192:				result = this->dict[s];
        -:  193:				return true;
        -:  194:			}
        -:  195:		}
        8:  196:		result.value_type = CVALUE_TYPE::CV_UNKNOWN;
        8:  197:		return false;
        -:  198:	}
        -:  199:
        -:  200:	// --------------------------------------------------------------------
        -:  201:	bool is_sss_or_ddd( std::string word ) const {
     2995:  202:		int d = (int)sss_or_ddd_id.count( word );
        -:  203:		return d;
        -:  204:	}
        -:  205:
        -:  206:	// --------------------------------------------------------------------
        -:  207:	bool is_ix_hl( std::string word ) const {
      733:  208:		int d = (int)ix_hl.count( word );
        -:  209:		return d;
        -:  210:	}
        -:  211:
        -:  212:	// --------------------------------------------------------------------
        -:  213:	bool is_iy_hl( std::string word ) const {
      429:  214:		int d = (int)iy_hl.count( word );
        -:  215:		return d;
        -:  216:	}
        -:  217:
        -:  218:	// --------------------------------------------------------------------
        -:  219:	bool is_rp( std::string word ) const {
      357:  220:		return (int)rp_id.count( word );
        -:  221:	}
        -:  222:
        -:  223:	// --------------------------------------------------------------------
        -:  224:	bool is_ix_rp( std::string word ) const{
       12:  225:		return (int)ix_rp_id.count( word );
        -:  226:	}
        -:  227:
        -:  228:	// --------------------------------------------------------------------
        -:  229:	bool is_iy_rp( std::string word ) const{
       12:  230:		return (int)iy_rp_id.count( word );
        -:  231:	}
        -:  232:
        -:  233:	// --------------------------------------------------------------------
        -:  234:	bool is_rp_with_af( std::string word ) const {
       36:  235:		return (int)rp_with_af_id.count( word );
        -:  236:	}
        -:  237:
        -:  238:	// --------------------------------------------------------------------
        -:  239:	bool is_ccc( std::string word ) const {
       72:  240:		return (int)ccc_id.count( word );
        -:  241:	}
        -:  242:
        -:  243:	// --------------------------------------------------------------------
        -:  244:	bool is_cc2( std::string word ) const {
       12:  245:		return (int)cc2_id.count( word );
        -:  246:	}
        -:  247:
        -:  248:	// --------------------------------------------------------------------
       12:  249:	void add_include_path( const char* p_path, const char *p_sub_path = "" ) {
       12:  250:		std::string s = p_path;
        -:  251:
       30:  252:		for( int i = (int)s.size() - 1; i >= 0; i-- ) {
       60:  253:			if( s[i] == '/' || s[i] == '\\' ) {
       36:  254:				s = s.substr( 0, i );
       12:  255:				break;
        -:  256:			}
        -:  257:		}
       36:  258:		include_path.push_back( s + "/" + p_sub_path );
       12:  259:	}
        -:  260:
        -:  261:	// --------------------------------------------------------------------
       16:  262:	std::string dot( std::string s, int max_length ){
       16:  263:		int length = max_length - s.size();
       16:  264:		std::string s_result = " ";
      124:  265:		for( int i = 0; i < length; i++ ){
      108:  266:			s_result = s_result + ".";
        -:  267:		}
       16:  268:		return s_result;
        -:  269:	}
        -:  270:
        -:  271:	// --------------------------------------------------------------------
        6:  272:	void write( void ) {
        -:  273:		int i, j;
        -:  274:		unsigned char c;
        -:  275:		std::string s;
       12:  276:		std::stringstream s_dump;
        6:  277:		if( dict.size() ){
        2:  278:			log << "<< label >>" << std::endl;
        -:  279:			size_t max_label_length = 0;
       50:  280:			for( auto item : dict ){
       16:  281:				if( item.first.size() > max_label_length ){
        -:  282:					max_label_length = item.first.size();
        -:  283:				}
        -:  284:			}
        2:  285:			max_label_length += 3;
       18:  286:			for( auto &item : dict ){
       64:  287:				s = dot( item.first, max_label_length );
       16:  288:				if( item.second.value_type == CVALUE_TYPE::CV_INTEGER ){
       32:  289:					log << item.first << s << " " << std::dec << item.second.i << " ( 0x" << std::hex << item.second.i << " )" << std::endl;
        -:  290:				}
    #####:  291:				else if( item.second.value_type == CVALUE_TYPE::CV_STRING ){
        -:  292:					log << item.first << s << " \"" << item.second.s << "\"" << std::endl;
        -:  293:				}
        -:  294:				else{
        -:  295:					log << item.first << s << " ????" << std::endl;
        -:  296:				}
        -:  297:			}
        -:  298:		}
        -:  299:
        6:  300:		if( char_set_list.size() ){
        1:  301:			log << "<< character map >>" << std::endl;
        3:  302:			for( auto &item : char_set_list ){
        -:  303:				log << "[" << item.first << "]" << std::endl;
      130:  304:				for( i = 0; i < 256; i += 8 ){
      128:  305:					s_dump.str( "" );
     1088:  306:					for( j = 0; j < 8; j++ ){
        -:  307:						//	ダンプ
      512:  308:						c = i + j;
     1024:  309:						c = item.second.ascii_to_map[ c ];
      512:  310:						s_dump << std::hex << std::setw( 2 ) << std::setfill( '0' ) << (int)c << " ";
        -:  311:						//	記号
        -:  312:						c = i + j;
      512:  313:						if( c < 32 ){
        -:  314:							c = 32;
        -:  315:						}
      448:  316:						else if( c >= 0x7F ){
        -:  317:							c = '?';
        -:  318:						}
        -:  319:						log << c;
        -:  320:					}
       64:  321:					log << ":" << s_dump.str() << std::endl;
        -:  322:				}
        -:  323:				log << std::endl;
        -:  324:			}
        -:  325:		}
        -:  326:
       12:  327:		std::ofstream sym_file;
        6:  328:		sym_file.open( "zma.sym", std::ios::out );
        6:  329:		if( !sym_file ){
    #####:  330:			return;
        -:  331:		}
       54:  332:		for( auto item : dict ){
       16:  333:			if( item.second.value_type != CVALUE_TYPE::CV_INTEGER ){
    #####:  334:				continue;
        -:  335:			}
       16:  336:			sym_file << item.first << " equ 0" << std::hex << item.second.i << "h" << std::endl;
        -:  337:		}
        6:  338:		sym_file.close();
        -:  339:	}
        -:  340:};
