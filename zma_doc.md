# Z80/R800 macro assembler ZMA

## はじめに

ZMAは、Z80/R800用のコードを生成するクロスアセンブラです。ニーモニックで記述されたテキストファイルを処理して機械語コードを生成します。また、いくつかの疑似命令を備えています。

MSXを主なターゲットとしていますが、Z80/R800を搭載している別のシステム向けにも利用可能です。

## インストール

ZMAは、インストーラーを用意していない。zma.exe と、include フォルダを好きな場所に配置し、zma.exe のある場所に実行パスを通せばインストール完了である。

## 実行

zma.exe には2つの引数を指定する。1つ目は入力ファイル名。2つ目は出力ファイル名。

引数を指定せずに実行すると、簡単なヘルプが表示される。

```sh
zma [-options] <input.asm> <output.bin>
```

- <input.asm> は入力ソースファイル名である。
- <output.bin> は出力ファイル名である。
- [-options] はオプション指定である。必要なければ省略することができる。

オプション指定は下記のものがある。

オプション指定一覧

|オプション表記|意味|
|-|-|
|-DEFS|指定すると、DEFS疑似命令が「領域確保命令」になる。<br>指定しないと、DEFS疑似命令が「文字列データ配置命令」(v1.0.15以前と互換) になる。|
|-HELP<br>-H|ヘルプ表示。|
|-I|パス名 指定のパス名をincludeディレクトリとして追加する。<br>-I とパス名の間にスペースを入れてはならない。|
|-D|シンボル名=値 シンボル名で示される値を定義する。<br>-Dとシンボル名の間にスペースを入れてはならない。<br>= の前後にもスペースを入れてはならない。<br>文字列値にする場合は、値を ' で囲むこと。<br>※注意：ダブルクオートでは無く、シングルクオートです。<br>-DMODE=0<br>-DTITLE='HogeHoge'`|
|-HEX|出力ファイルが IntelHEX形式になります。<br>指定しない場合はバイナリ形式になります。|

## ニーモニックの違い

ZMAでは、構文解析の都合等によりザイログニーモニックを一部改変しています。違いを下記の表にまとめる。

ZilogニーモニックとZMAの違い

|Zilogニーモニック|ZMA|備考|
|-|-|-|
|LD A, (HL)|LD A, [HL]|アドレス参照は、数式の優先順位指定の() と区別するために [] を使う。|
|JP (HL)|JP HL|レジスタによる飛び先アドレス指定は () で囲まない。<br>v1.0.16 から JP (HL) も受け付けるようになりました。|
|LD A, (IX+0)|LD A, [IX]|[IX+0] を [IX] と記述できる。IY も同様。|
|SUB B|SUB A, B|演算命令の記述で A を記述する。<br>v1.0.16 から SUB B の記述も受け付けるようになりました。|

## 未定義命令

Z80の未定義命令にも対応している。IXH, IXL, IYH, IYL を利用可能である。

## R800命令

R800の乗算命令に対応している。mulub, muluw を利用可能である。

## 疑似命令

ZMAにはいくつかの疑似命令を利用可能になっている。本章では、各疑似命令について個別に説明する。

### DEFB命令

- 書式: DEFB 式
- 機能
    - 式の評価結果を 8bit 値と見なし、下位8bit を記述箇所に配置する。
    - 式は、カンマで区切って複数記述できる。
    - 複数記述した場合は、左から順に 8bit 値として配置される。

### DEFW命令

- 書式: DEFW 式
- 機能
    - 式の評価結果を 16bit 値と見なし、下位16bit を記述箇所に配置する。
    - 式は、カンマで区切って複数記述できる。
    - 複数記述した場合は、左から順に 16bit 値として配置される。
    - バイトオーダーはリトルエンディアンであり、下位8bit、上位8bit の順で配置される。

### DEFD命令

- 書式: DEFD 式
- 機能
    - 式の評価結果を 32bit 値と見なし、下位32bit を記述箇所に配置する。
    - 式は、カンマで区切って複数記述できる。
    - 複数記述した場合は、左から順に 32bit 値として配置される。
    - バイトオーダーはリトルエンディアンである。

### DEFS命令

- 書式1: DEFS 文字列式
- 書式2: DEFS 領域サイズ [, 初期値]
- 機能
    - コマンドラインオプション -DEFSを指定しなかった場合は書式1を、-DEFSを指定した場合は書式2を採用する。
    - 書式1の場合、文字列式の評価結果を配置する。多くのアセンブラと異なるので注意すること。
    - 書式2の場合、SPACE命令と同様である。多くのアセンブラと近い記述になる。

### SPACE命令

- 書式: SPACE 領域サイズ [, 初期値]
- 機能
    - 領域サイズだけ、初期値(1Byte値)を詰める。

### ALIGN命令

- 書式: ALIGN ブロックサイズ
- 機能
    - アドレスがブロックサイズの倍数の値になるまで、0 を詰める。
    - すでにブロックサイズの倍数の場合は何も詰めない。

### ORG命令

- 書式: ORG 式
- 機能
    - この記述箇所を、式の評価結果の値のアドレスであると見なすようになる。

例えば、下記の2つのプログラムは、出力されるコードが異なる。

```asm
ORG 0
JR 0
```

```asm
ORG 50
JR 0
```

ともに2バイトのコードを生成するが、上の記述の場合 0番地に配置されているつもりで 0番地へ相対ジャンプするコードを生成するため、生成コードは 0x18 0xFE となる。下の記述の場合 50番地に配置されているつもりで 0番地へ総体ジャンプするコードを生成するため、生成コードは0x18 0xCC となる。

生成ファイルの先頭から何バイト目であるかとは独立して、各行が何番地に配置されているかを認識しており、ORGはこれを変更するための疑似命令となる。

これは、例えばROM上のコードを、DRAMへコピーして使う場合など「元々格納されているアドレス」と「実際に実行されるアドレス」が異なる場合にも対応できるようにするための仕組みである

### INCLUDE命令

- 書式: INCLUDE 文字列式
- 機能
    - 文字列式の評価結果による文字列をファイル名と認識し、そのファイルを読み出して記述箇所に挿入する。

### ADD_INCLUDE_PATH命令

- 書式 ADD_INCLUDE_PATH 文字列式
- 機能
    - 文字列式の評価結果による文字列をディレクトリ名と認識し、INCLUDE命令によるファイル名指定の前につけるパス名リストにそのディレクトリ名を追加する。
    - デフォルトでは、カレントディレクトリと、ZMA.exe が格納されているパスの中にある include ディレクトリがリストに含まれている。これ以外の場所から INCLUDE したい場合に使用する命令である。
    - ZMA.exe はオブジェクトファイル生成とリンクの過程を省略するため、INCLUDE が各種ライブラリのリンクの役割を兼ねる。ライブラリのソースの中に特定のパスを記述したくないため、リンクする側のソースに ADD_INCLUDE_PATH を記述して「ライブラリのソース置き場」を指定することで、使い回すライブラリの中にパスの記述をしなくて済む。

### BINARY_LINK命令

- 書式: BINARY_LINK 文字列式
- 機能
    - 文字列式の評価結果による文字列をファイル名と認識し、そのファイルを読み出して記述箇所に挿入する。INCLUDEと異なり、ファイルの内容そのものを、そのままバイナリ値として挿入する。外部ツールで作成したバイナリデータを挿入したい場合に利用する。

### MACRO命令

- 書式
    - マクロ名 MACRO 引数リスト<br>&emsp;文<br>ENDM
- 機能
    - 文に記載の内容を「マクロ名」の記述で表記できるようにする。
    - 文は複数行にわたる記述も可能である。

```asm
HOGE MACRO
  LD D, H
  LD E, L
ENDM
```

このような記述の後に HOGE と記述すると、LD D, H/LD E, L の2行に置き換えられる。

マクロには引数を持たせることができる。
```asm
MOGE MACRO n
  LD A, n
ENDM
```

n は引数であるが、MOGE 100 のように記述すると LD A, 100 と展開されるようになる。

当然 MOGE 10+20 のような式も記述可能であるが、単純置換になるため下記のような記述は注意が必要である。

```asm
FOO MACRO m
  LD A, 10*m
ENDM

FOO 1+2
```

FOO 1+2 は、LD A 10*1+2 に展開されるため、最終的に LD A, 12 になる。下記のように記述するのが安全である。

```asm
FOO MACRO m
  LD A, 10*(m)
ENDM

FOO 1+2
```

引数を複数持たせることもできる。

```asm
BAR MACRO n, m
  LD A, n
  LD B, m
ENDM
```

引数の名前に @ をつけると、その引数は文字列に変換されるようになる。

```asm
LDM MACRO @D, @S
  IF D == "BC"
    IF S == "DE"
      LD B, D
      LD C, E
    ELSEIF S == "HL"
      LD B, H
      LD C, L
    ELSE
      ERROR "LDM macro isn't support the source "+S+"."
    ENDIF
  ENDIF
ENDM

LDM BC, DE
LDM BC, HL
```

このように、あたかもそのような命令があるかのような記述が可能となる。

文字列に変換する際、小文字は大文字に変換される。単語間は半角スペース1つで区切られる。

例えば、a+B + 3 と書かれていても、"A + B + 3"のように変換される。＋の前後に半角スペースが1つ入る。

マクロ名として、実際に存在する命令と同じ名前をつけると、その命令が使えなくなるので注意すること。

MACRO～ENDM, REPEAT～ENDR, IF～ENDIFの中でマクロを宣言することはできない。

### SCOPE命令

- 書式
    - SCOPE スコープ名<br>&emsp;文<br>ENDSCOPE
- 機能
    - SCOPE から ENDSCOPE までの間を、スコープ名で示したスコープに指定する。
    - この中で宣言されたローカルラベルは、この中でのみ有効となる。
    - ネストも可能である。

### REPEAT命令

- 書式
    - REPEAT ループ変数名, 式<br>&emsp;文<br>ENDR
- 機能
    - 式の評価結果で示される回数だけ、文を繰り返し出力する。
    - その際、ループ変数は 0 から順に1ずつインクリメントされ、式-1 まで変化する。
    - 文の中の式でループ変数を利用することも可能である。

```asm
REPEAT I, 2
  REPEAT J, 3
    DEFB I*5 + J
  ENDR
ENDR
```
これにより、 0, 1, 2, 5, 6, 7 の 6byte が生成される。

ループ内は、専用のスコープを形成するが、式はそのスコープの外側の扱いである。

ネストも可能である。

```asm
REPEAT I, 3
  REPEAT I, I+1
    DEFB I
  ENDR
ENDR
```
これにより、0, 0, 1, 0, 1, 2 の 6byte が生成される。

内側の REPEAT の式である I+1 に登場する I は、外側の REPEAT のループ変数である。

DEFB I の I は、内側の REPEAT のループ変数である。

スコープが形成されているため、同じ名前でもループ回数は問題なく展開されるが、一番内側の式の中では、一番内側のループ変数しか使えなくなるため、式の中で使うループ変数名はユニークにしておかねばならない。

### IF命令

- 書式1
    - IF 式<br>&emsp;文<br>ENDIF
- 書式2
    - IF 式1<br>&emsp;文1<br>ELSEIF 式2<br>&emsp;文2<br>ENDIF
- 書式3
    - IF 式<br>&emsp;文1<br>ELSE<br>&emsp;文2<br>ENDIF
- 機能
    - 式の評価結果が 0以外の場合に文を展開する。
    - 主に MACRO の中で、引数の値に応じて生成されるコードを変更したい場合に利用する命令であるが、MACROの外でも利用可能である。
    - ELSEIFを含む記法では、式1が 0以外の場合に文1 を展開し、式1が0でかつ式2が0以外の場合に文2を展開する。
    - ELSEを含む記法では、式が 0以外の場合に文1を、0の場合に文2を展開する。
    - ELSEIFは複数使うことができ、ELSEをELSEIFと組み合わせることもできる。

```asm
IF l1 == 100
  ld a, 100
elseif l1 == 200
  ld a, 100
  ld b, 2
elseif l1 == 300
  ld a, 100
  ld b, 3
else
  ld b, 2
endif
```

### CHG_CHAR_SET命令

- 書式: CHG_CHAR_SET 文字列式
- 機能
    - 文字列式に対応するキャラセットに変更する。
    - キャラセット "DEFAULT" は通常のASCIIコードである。
    - CHAR_SET_NAME変数で、現在のキャラセット名を取得できる。

### MAPPING_CHAR命令

- 書式: MAPPING_CHAR '文字1', コード, '文字2'
- 機能
    - 現在のキャラセットの '文字1' と コードの対応関係を変更する。
    - キャラセット "DEFAULT" の場合は、この命令はエラーになる。
    - '文字2' を指定すると、'文字1'～'文字2' をコードから始まる連番に充てる。

### MESSAGE命令

- 書式: MESSAGE 文字列式
- 機能
    - ログに文字列式の評価結果を出力する。

### ERROR命令

- 書式: ERROR 文字列式
- 機能
    - ログに文字列式の評価結果を出力し、エラーが発生したことにする。

### LINK命令

- 書式
    - LINK トリガー名 [, トリガー名 [, トリガー名 ... ]]<br>&emsp;中身<br>ENDL
- 機能
    - この外側の式の中でトリガー名が使用されると、LINK～ENDL の内容が展開される。
    - 通常は、LINK～ENDLの中のラベルをトリガー名として指定する。
    - トリガー名は最低1つ指定しなければならない。

### ローカルラベル

- 書式: ラベル名:
- 機能
    - ラベル名に、記述位置のコードアドレスを紐つける。
    - ラベル記述位置のスコープに影響される。
    - スコープ内の場合、そのスコープ内からしか参照できない。
    - また、別のスコープの中に同じ名前のラベルがあっても問題ない。

```asm
  ORG 100
LABEL1:
  SCOPE HOGE
  ORG 200
LABEL1:
  MESSAGE "LABEL1 = " + LABEL1
  ENDSCOPE
  MESSAGE "LABEL1 = " + LABEL1
```

これをアセンブルすると、下記のようなメッセージが表示される
```asm
LABEL1 = 200
LABEL1 = 100
```

### グローバルラベル

- 書式: ラベル名::
- 機能
    - ラベル名に、記述位置のコードアドレスを紐つける。
    - スコープには影響されず、コード上のどこからでも参照可能である。
    - サブスコープ内に同名のローカルラベルが存在する場合、ローカルラベルが優先される。

```asm
  ORG 100
LABEL1::
  MESSAGE "LABEL1 = " + LABEL1
```

これをアセンブルすると、下記のようなメッセージが表示される

```asm
LABEL1 = 100
```

### ローカルラベル代入

- 書式: ラベル名 = 式
- 機能
    - ラベル名に、式の評価結果を紐つける。
    - 記述の順序は無関係であり、1つのラベルには1つの値しか紐つけられない。
    - 式は文字列式でもかまわない。

```asm
LABEL1 = LABEL2
LABEL2 = "hoge"
```

### グローバルラベル代入

- 書式: ラベル名 := 式
- 機能
    - 使い方はローカルラベル代入と同様である。
    - スコープ内で使用しても、グローバルなラベルに対する紐つけになる点のみ異なる。

## 式

ZMAでは、様々な場所に式を記述できる。

下記の演算子を利用できる。

演算子と優先順位
|優先順位|演算子|名前|意味|
|-|-|-|-|
|1|+|正値|なにもしない。|
|1|-|負値|符号を反転する。|
|1|!|否定|0は1に。0以外は0になる。|
|1|~|ビット反転|ビットごとに0は1に、1は0になる。|
|1|(|)|優先記述子|()の内側を先に演算する。|
|2|*|乗算|掛ける|
|2|/|除算|割る|
|2|%|剰余|割ったあまり|
|3|+|加算|足す|
|3|-|減算|引く|
|4|<<|左ビットシフト|左ビットシフト|
|4|>>|右ビットシフト|符号付き右ビットシフト|
|5|<|小なり|左項が小さければ1,小さくなければ0|
|5|>|大なり|左項が大きければ1,大きくなければ0|
|5|<=|小なりまたは一致|左項が小さいか一致していれば1,大きければ0|
|5|>=|大なりまたは一致|左項が大きいか一致していれば1,小さければ0|
|6|==|一致|一致していれば1,不一致なら0|
|6|!=|不一致|不一致していれば1,一致なら0|
|7|&|ビットごとの論理積|ビットごとの論理積|
|8|^|ビットごとの排他的論理和|ビットごとの排他的論理和|
|9|\||ビットごとの論理和|ビットごとの論理和|
|10|&&|論理積|左右の項が両方とも0以外なら1,一方でも0なら0|
|11|\|\||論理和|左右の項が一方でも0以外なら1,両方0なら0|

式の中では、下記の定数を利用できる。

利用可能な定数一覧

|定数|意味|
|-|-|
|$|記述行の開始コードアドレス|
|$$|記述行のファイル内アドレス（先頭から何バイト目か）|
|CODE_ADDRESS|$と同じ|
|FILE_ADDRESS|$$と同じ|
|CHAR_SET_NAME|現在のキャラセット名|
|ラベル名|ラベルの値|

## 文字列式

文字列に対してもある程度の演算を行うことができる。

演算子と優先順位（文字列式）

|優先順位|演算子|名前|意味|
|-|-|-|-|
|2|*|乗算|反復。左項または右項は数値でなければならない。|
|3|+|加算|連結。左項または右項が数値なら10進数文字列にして連結。|
|6|==|一致|一致していれば1,不一致なら0|
|6|!=|不一致|不一致していれば1,一致なら0|

例えば、"abc" == "abc" は 1 になる。 "abc" == "xyz" は 0 になる。

"ab" * 3 は、"ababab" になる。

"ab" + 3 は、 "ab3" になる。

式と文字列式は、特に区別が無く混在させることができるため、下記のような記述も可能。

"ab" * (3 + 2)

## コメント

; より右はコメントと見なし、無視される。

## 数値の記述

数値は下記の書式で記述する。

数値の表記

|種類|表記方法|表記例|
|-|-|-|
|10進数|0～9 の数字のみで記入する。桁の区切り記号として _ を含めることができる。|1234<br>1_234_567|
|2進数|0b の後に 0と1の数字のみで記入する。桁の区切り記号として _ を含めることができる。|0b1111_1010_1111<br>0b11_111_1111<br>0b1010101010|
|8進数|0の後に0から7の数字のみで記入する。桁の区切り記号として _ を含めることができる。|0777<br>0655|
|16進数(1)|0xの後に0から9, AからFの記号のみで記入する。桁の区切り記号として _ を含めることができる。|0xDEAD<br>0xDEAD_BEEF<br>0xAA55|
|16進数(2)|0から9, AからFの記号のみで記入し、最後にHを付ける。ラベルと区別するため、最初の文字がAからFの場合は、先頭に0を付ける必要がある。_を含めることができる。|0DEADH<br>0BEEFh<br>1234h<br>0_DEAD_BEEFh|
|16進数(3)|$の後に0から9,AからFの記号のみで記入する。桁の区切り記号として _ を含めることができる。|$DEAD<br>$BEEF<br>$1234<br>$DEAD_BEEF|

## エラーメッセージ

|エラーメッセージ|意味|
|-|-|
|(' are not closed.|式の中で ( に対応する ) が存在しない。|
|Block processing is not close.|ブロック処理(IF,REPEAT,MACRO)が閉じられていない。|
|Cannot evaluate the expression(N)|defb/w/d で N番目の式が評価できない。|
|Cannot open include file 'FILE_NAME'.|INCLUDE に指定されたファイル 'FILE_NAME' が開けない。|
|Description of numerical value<br>'0XABCDEFG' is abnormal.|数値の記述が異常。<br>数値の記述と、ラベルの記述が繋がっていると１つの単語と誤認されてこのエラーになるケースがある。|
|Divided by zero.|除算演算子 / および % において、右側の項が 0 であり、値が確定しない。|
|ENDIF is not need parameters.|ENDIFに不正なパラメータ指定がある。|
|ENDR is not need parameters.|ENDRにパラメータの記述がある。|
|ENDSCOPE command has not parameter.|引数を持たない ENDSCOPE に引数が指定されている。|
|ENDSCOPE in wrong position.|ENDSCOPEの記述位置がおかしい。SCOPEしてないのにENDSCOPEしていたり、MACROやIFの中にENDSCOPEだけ書いていたりすると発生する。|
|Ilegal command|解釈不能な命令がある。|
|Ilegal condition.|IF/ELSEIFの条件式に、値が確定しない式の記述がある。|
|Ilegal ENDIF.|ENDIFが不正な位置に存在する。|
|Ilegal ENDR.|不正な位置にENDRの記述がある。|
|Ilegal expression.|数式の記述が異常。|
|Ilegal operand|オペランドの値を確定できない。|
|Ilegal parameter in ADD_INCLUDE_PATH.|ADD_INCLUDE_PATH命令のパラメータを評価できない。|
|Ilegal parameter in MESSAGE.|MESSAGE命令のパラメータを評価できない。|
|INCLUDE command has only one parameter.|INCLUDE に２つ以上のパラメータが指定されている。|
|Invalid expression.|式の記述に異常があり、評価できない。|
|Invalid operator '-'|二項演算子 - の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '!'|単項演算子 ! に対する値が記述されていない。|
|Invalid operator '!='|二項演算子 != の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '%'|二項演算子 % の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '*'|二項演算子 * の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '-'|単項演算子 - に対する値が記述されていない。|
|Invalid operator '/'|二項演算子 / の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '~'|単項演算子 ~ に対する値が記述されていない。|
|Invalid operator '+'|二項演算子 + の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '+'|単項演算子 + に対する値が記述されていない。|
|Invalid operator '<'|二項演算子 < の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '<<'|二項演算子 << の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '<='|二項演算子 <= の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '=='|二項演算子 == の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '>'|二項演算子 > の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '>='|二項演算子 >= の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Invalid operator '>>'|二項演算子 >> の右側に値が記述されていない。あるいは、左右の項が評価不能な値である。|
|Label name cannot be string.|ラベル名として文字列が指定されている。|
|Message not found in MESSAGE.|MESSAGE命令にメッセージの指定が無い。|
|Mismatched number of arguments.|マクロに対する引数指定が少なすぎる。|
|Multiple arguments of the same name 'XXXX' exist.|マクロ宣言において、引数名 XXXX が複数指定されている。|
|Must be set include file name.|INCLUDEにファイル名指定が無い。|
|Must be set scope name.|SCOPEにスコープ名の指定が無い。|
|Offset value is out of range (N).|[IX+n], [IY+n] の n が、-128～127 の範囲を超えている。N は実際の n の値。|
|Path not found in ADD_INCLUDE_PATH.|ADD_INCLUDE_PATH命令にパスの指定が無い。|
|SCOPE command has only one parameter.|SCOPE に２つ以上のパラメータが指定されている。|
|Scope is not closed.|SCOPEに対応するENDSCOPEが存在しない。|
|Scope of ENDR does not exist.|REPEAT と ENDR の対応関係がとれない。MACROの中にENDRだけ記述されている場合など。|
|There are declarations of the same label 'XXXX' in multiple places.|ラベル XXXX が複数箇所で宣言されている。|
|There is an ELSE description at an incorrect position.|IF無しのELSEがある。|
|There is an ELSEIF description at an incorrect position.|IF無しのELSEIFがある。|
|There is an extra account that can not be interpreted.|解釈不能な余計な記述がある。例えば LD A, B AAA
のような場合。余計な記述 AAA がある。|
|Too many arguments for XXXX.|マクロXXXX に対する引数指定が多すぎる。|
|User error|ERROR命令で引数がない。|
|Default character sets cannot be mapped and changed.|MAPPING_CHAR命令を、DEFAULTキャラセットに指定しようとした。|
|Label "XXXX" is indeterminate.|ラベル"XXXX"の定義が見つかりません。（未定義のラベルXXXXが使われています）|

## 履歴

- 2019/06/26 t.hara v1.0 初版
- 2019/06/27 t.hara v1.0 文字列式の説明を追加
- 2019/06/29 t.hara v1.0 エラーメッセージの説明を追加
- 2020/12/11 t.hara v1.0.13 SPACE/ALIGN疑似命令の説明を追加
- 2020/12/29 t.hara v1.0.14 BINARY_LINK 疑似命令を追加
- 2022/7/12 t.hara v1.0.16 いくつかの命令でザイログニーモニックに寄せた記述も可能にした
    - CHG_CHAR_SET命令/MAPPING_CHAR命令を追加
    - 16進数の表記を $A0, 0A0H のような表記も受け入れるようにした
    - システム変数 CHR_SET_NAME を追加
    - コマンドラインオプションについて追記
    - DEFS疑似命令の説明に追記
    - LINK～ENDL疑似命令を追加
- 2023/6/18 t.hara v1.0.16 Label "XXXX" is indeterminate. の説明が抜けていたのを追記
    - フッターにページ番号を追加
